<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DiNGo - Multiplayer Bingo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;800&display=swap');
        
        body {
            font-family: 'Outfit', sans-serif;
            background-color: #0f1220;
            color: #ffffff;
            overflow-x: hidden;
        }

        .bingo-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
        }

        .bingo-cell {
            aspect-ratio: 1/1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #1f2545;
            border-radius: 12px;
            font-weight: 800;
            font-size: 1.25rem;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            user-select: none;
            border: 2px solid transparent;
        }

        .bingo-cell:hover:not(.marked) {
            background: #2a325a;
            transform: translateY(-2px);
        }

        .bingo-cell.marked {
            background: linear-gradient(135deg, #00e5ff 0%, #0099ff 100%);
            color: #0f1220;
            box-shadow: 0 0 15px rgba(0, 229, 255, 0.4);
            transform: scale(0.95);
        }

        .bingo-cell.last-called {
            border-color: #ffffff;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { border-color: rgba(255,255,255,1); }
            50% { border-color: rgba(255,255,255,0.2); }
            100% { border-color: rgba(255,255,255,1); }
        }

        .bingo-letter {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #161a2f;
            border-radius: 8px;
            font-weight: 800;
            color: #3f4a7a;
            transition: all 0.5s;
        }

        .bingo-letter.active {
            background: #7c5cff;
            color: white;
            box-shadow: 0 0 20px rgba(124, 92, 255, 0.5);
        }

        .glass-panel {
            background: rgba(22, 26, 47, 0.8);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
    </style>
</head>
<body>

<div id="app" class="min-h-screen flex flex-col items-center justify-center p-4">
    <!-- Loading State -->
    <div id="loading" class="flex flex-col items-center">
        <div class="w-12 h-12 border-4 border-t-blue-500 border-gray-700 rounded-full animate-spin"></div>
        <p class="mt-4 text-gray-400">Connecting to DiNGo Arena...</p>
    </div>

    <!-- Main Screens -->
    <div id="screen-home" class="hidden w-full max-w-md space-y-6">
        <div class="text-center">
            <h1 class="text-6xl font-extrabold tracking-tighter mb-2 bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500">
                DiNGo
            </h1>
            <p id="user-display" class="text-gray-400 font-medium"></p>
        </div>

        <div class="glass-panel p-6 rounded-3xl space-y-4">
            <button onclick="findMatch()" class="w-full bg-gradient-to-r from-blue-600 to-blue-500 hover:from-blue-500 hover:to-blue-400 p-4 rounded-2xl font-bold text-lg shadow-lg shadow-blue-900/20 transition-all active:scale-95">
                Play Multiplayer
            </button>
            <div class="relative py-2">
                <div class="absolute inset-0 flex items-center"><div class="w-full border-t border-gray-800"></div></div>
                <div class="relative flex justify-center text-xs uppercase"><span class="bg-[#161a2f] px-2 text-gray-500">Or Private</span></div>
            </div>
            <button onclick="createPrivateRoom()" class="w-full bg-gray-800 hover:bg-gray-700 p-4 rounded-2xl font-bold text-gray-200 transition-all">
                Host Private Game
            </button>
        </div>
    </div>

    <div id="screen-lobby" class="hidden w-full max-w-md glass-panel p-8 rounded-3xl text-center space-y-6">
        <div class="animate-bounce inline-block p-4 bg-blue-900/30 rounded-full text-blue-400">
            <svg xmlns="http://www.w3.org/2000/svg" class="w-10 h-10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>
        </div>
        <h2 class="text-2xl font-bold">Waiting for Opponent</h2>
        <p class="text-gray-400">The arena is being prepared...</p>
        <div id="room-id-display" class="text-xs text-gray-600 font-mono"></div>
        <button onclick="leaveGame()" class="text-sm text-gray-500 hover:text-red-400 underline mt-4">Cancel Search</button>
    </div>

    <div id="screen-game" class="hidden w-full max-w-md flex flex-col items-center">
        <!-- Header Status -->
        <div class="w-full flex justify-between items-end mb-4 px-2">
            <div>
                <p id="opponent-name" class="text-xs text-gray-500 uppercase tracking-widest mb-1">vs Opponent</p>
                <div id="turn-indicator" class="text-xl font-bold">Waiting...</div>
            </div>
            <div class="flex gap-2" id="bingo-progress">
                <div class="bingo-letter" data-letter="D">D</div>
                <div class="bingo-letter" data-letter="I">I</div>
                <div class="bingo-letter" data-letter="N">N</div>
                <div class="bingo-letter" data-letter="G">G</div>
                <div class="bingo-letter" data-letter="O">O</div>
            </div>
        </div>

        <!-- The Board -->
        <div id="game-board" class="bingo-grid w-full glass-panel p-4 rounded-3xl">
            <!-- Cells injected here -->
        </div>

        <div class="w-full mt-6 text-center">
            <p id="game-message" class="text-gray-400 text-sm italic">Tap a number when it's your turn</p>
            <button onclick="leaveGame()" class="mt-8 text-gray-600 hover:text-gray-400 text-sm font-medium">Exit Arena</button>
        </div>
    </div>

    <!-- Win Overlay -->
    <div id="overlay-win" class="hidden fixed inset-0 bg-black/90 backdrop-blur-md z-[1000] flex items-center justify-center p-6 text-center">
        <div class="space-y-8 max-w-xs w-full">
            <h2 id="win-title" class="text-6xl font-extrabold italic bg-clip-text text-transparent bg-gradient-to-b from-yellow-300 to-orange-500">VICTORY</h2>
            <p id="win-subtitle" class="text-gray-300 text-xl font-medium">You completed the DiNGo!</p>
            <div class="space-y-3 pt-4">
                <button onclick="requestRematch()" id="rematch-btn" class="w-full bg-blue-600 p-4 rounded-2xl font-bold shadow-lg active:scale-95 transition-all">Play Again</button>
                <button onclick="leaveGame()" class="w-full bg-white/10 p-4 rounded-2xl font-bold hover:bg-white/20 transition-all">Back to Home</button>
            </div>
        </div>
    </div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, setDoc, getDoc, updateDoc, deleteDoc, collection, query, onSnapshot, addDoc, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    /* --- CONFIG & INIT --- */
    const firebaseConfig = JSON.parse(__firebase_config);
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'dingo-v2';

    let currentUser = null;
    let currentGame = null;
    let unsubscribeGame = null;
    let myBoard = [];
    let myMarks = [];

    // Utils
    const $ = id => document.getElementById(id);
    const show = id => $(id).classList.remove('hidden');
    const hide = id => $(id).classList.add('hidden');
    const generateName = () => "Player_" + Math.random().toString(36).substring(7).toUpperCase();

    /* --- AUTHENTICATION --- */
    async function initAuth() {
        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
            await signInWithCustomToken(auth, __initial_auth_token);
        } else {
            await signInAnonymously(auth);
        }
    }

    onAuthStateChanged(auth, (user) => {
        if (user) {
            currentUser = {
                uid: user.uid,
                name: generateName()
            };
            $('user-display').innerText = currentUser.name;
            hide('loading');
            show('screen-home');
        }
    });

    initAuth();

    /* --- GAME LOGIC --- */

    function createBoard() {
        const numbers = Array.from({length: 25}, (_, i) => i + 1);
        return numbers.sort(() => Math.random() - 0.5);
    }

    async function findMatch() {
        if (!currentUser) return;
        hide('screen-home');
        show('screen-lobby');

        // Simple matchmaking: Look for an existing open room
        const roomsRef = collection(db, 'artifacts', appId, 'public', 'data', 'rooms');
        const querySnap = await getDocs(roomsRef);
        
        let foundRoom = null;
        querySnap.forEach(doc => {
            const data = doc.data();
            if (data.status === 'waiting' && data.player1 && data.player1.uid !== currentUser.uid) {
                foundRoom = { id: doc.id, ...data };
            }
        });

        if (foundRoom) {
            joinRoom(foundRoom.id);
        } else {
            createPrivateRoom();
        }
    }

    async function createPrivateRoom() {
        if (!currentUser) return;
        hide('screen-home');
        show('screen-lobby');

        const roomsRef = collection(db, 'artifacts', appId, 'public', 'data', 'rooms');
        const roomDoc = doc(roomsRef);
        const roomId = roomDoc.id;
        $('room-id-display').innerText = `ID: ${roomId}`;

        await setDoc(roomDoc, {
            status: 'waiting',
            player1: currentUser,
            player2: null,
            called: [],
            turn: currentUser.uid,
            createdAt: Date.now(),
            rematch: {}
        });

        watchRoom(roomId);
    }

    async function joinRoom(roomId) {
        const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', roomId);
        await updateDoc(roomRef, {
            player2: currentUser,
            status: 'playing'
        });
        watchRoom(roomId);
    }

    function watchRoom(roomId) {
        if (unsubscribeGame) unsubscribeGame();

        const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', roomId);
        unsubscribeGame = onSnapshot(roomRef, (snap) => {
            if (!snap.exists()) {
                leaveGame();
                return;
            }
            
            const data = snap.val ? snap.val() : snap.data(); // Standardizing data access
            currentGame = { id: snap.id, ...data };

            if (data.status === 'playing') {
                renderGameScreen();
            } else if (data.status === 'finished') {
                handleGameOver(data);
            }
        }, (error) => {
            console.error("Room watch error:", error);
            leaveGame();
        });
    }

    function renderGameScreen() {
        hide('screen-lobby');
        hide('screen-home');
        show('screen-game');

        if (myBoard.length === 0) {
            myBoard = createBoard();
            myMarks = [];
        }

        const isMyTurn = currentGame.turn === currentUser.uid;
        const opponent = currentGame.player1.uid === currentUser.uid ? currentGame.player2 : currentGame.player1;

        $('opponent-name').innerText = `vs ${opponent?.name || 'Searching...'}`;
        $('turn-indicator').innerText = isMyTurn ? "Your Turn!" : "Waiting for Move...";
        $('turn-indicator').className = `text-xl font-bold ${isMyTurn ? 'text-blue-400' : 'text-gray-600'}`;

        const boardEl = $('game-board');
        boardEl.innerHTML = '';

        myBoard.forEach((num, index) => {
            const isMarked = currentGame.called.includes(num);
            const cell = document.createElement('div');
            cell.className = `bingo-cell ${isMarked ? 'marked' : ''}`;
            
            if (currentGame.called.length > 0 && num === currentGame.called[currentGame.called.length - 1]) {
                cell.classList.add('last-called');
            }

            cell.innerText = num;
            cell.onclick = () => handleCellClick(num, isMarked);
            boardEl.appendChild(cell);
        });

        updateProgress();
    }

    async function handleCellClick(num, isMarked) {
        if (currentGame.turn !== currentUser.uid || isMarked) return;

        const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', currentGame.id);
        const nextTurn = currentGame.player1.uid === currentUser.uid ? currentGame.player2.uid : currentGame.player1.uid;
        
        const newCalled = [...currentGame.called, num];
        
        await updateDoc(roomRef, {
            called: newCalled,
            turn: nextTurn
        });
    }

    function updateProgress() {
        const winningLines = [
            [0,1,2,3,4], [5,6,7,8,9], [10,11,12,13,14], [15,16,17,18,19], [20,21,22,23,24], // Rows
            [0,5,10,15,20], [1,6,11,16,21], [2,7,12,17,22], [3,8,13,18,23], [4,9,14,19,24], // Cols
            [0,6,12,18,24], [4,8,12,16,20] // Diagonals
        ];

        let lineCount = 0;
        winningLines.forEach(line => {
            if (line.every(idx => currentGame.called.includes(myBoard[idx]))) {
                lineCount++;
            }
        });

        const letters = ['D','I','N','G','O'];
        letters.forEach((letter, i) => {
            const el = document.querySelector(`[data-letter="${letter}"]`);
            if (i < lineCount) el.classList.add('active');
            else el.classList.remove('active');
        });

        if (lineCount >= 5 && currentGame.status !== 'finished') {
            finishGame();
        }
    }

    async function finishGame() {
        const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', currentGame.id);
        await updateDoc(roomRef, {
            status: 'finished',
            winner: currentUser.uid
        });
    }

    function handleGameOver(data) {
        const isWinner = data.winner === currentUser.uid;
        show('overlay-win');
        $('win-title').innerText = isWinner ? "VICTORY" : "DEFEAT";
        $('win-subtitle').innerText = isWinner ? "You mastered the DiNGo Arena!" : "Better luck next time, challenger.";
        
        const rematchBtn = $('rematch-btn');
        const myRematch = data.rematch?.[currentUser.uid];
        rematchBtn.innerText = myRematch ? "Waiting for Opponent..." : "Request Rematch";
        rematchBtn.className = myRematch ? 
            "w-full bg-gray-700 p-4 rounded-2xl font-bold opacity-50 cursor-not-allowed" : 
            "w-full bg-blue-600 p-4 rounded-2xl font-bold shadow-lg active:scale-95 transition-all";
    }

    async function requestRematch() {
        if (!currentGame || currentGame.rematch?.[currentUser.uid]) return;

        const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', currentGame.id);
        const updatedRematch = { ...(currentGame.rematch || {}), [currentUser.uid]: true };

        if (Object.keys(updatedRematch).length === 2) {
            // Both agreed, reset room
            await updateDoc(roomRef, {
                status: 'playing',
                called: [],
                winner: null,
                rematch: {},
                turn: currentGame.winner // Loser starts? Actually let's keep it winner starts or random
            });
            myBoard = []; // Force re-generate board
            hide('overlay-win');
        } else {
            await updateDoc(roomRef, {
                rematch: updatedRematch
            });
        }
    }

    async function leaveGame() {
        if (currentGame) {
            // Clean up if we were host and room is empty or logic to handle abandonment
            // For now, just reset local state
            if (unsubscribeGame) unsubscribeGame();
        }

        myBoard = [];
        myMarks = [];
        currentGame = null;

        hide('screen-lobby');
        hide('screen-game');
        hide('overlay-win');
        show('screen-home');
    }

    // Expose to window for onclick handlers
    window.findMatch = findMatch;
    window.createPrivateRoom = createPrivateRoom;
    window.leaveGame = leaveGame;
    window.requestRematch = requestRematch;

</script>
</body>
</html>

