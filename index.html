<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"/>
  <title>DiNGo — Live Multiplayer Bingo</title>

  <!-- ── PWA Meta Tags ── -->
  <meta name="theme-color" content="#00ffcc"/>
  <meta name="mobile-web-app-capable" content="yes"/>
  <meta name="apple-mobile-web-app-capable" content="yes"/>
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
  <meta name="apple-mobile-web-app-title" content="DiNGo"/>
  <meta name="description" content="5-in-a-row live multiplayer bingo. Challenge friends or battle the AI bot."/>
  <!-- Real manifest file — NOT a blob URL -->
  <link rel="manifest" href="manifest.json"/>
  <!-- Apple touch icons — real PNG files -->
  <link rel="apple-touch-icon" sizes="152x152" href="icons/icon-152.png"/>
  <link rel="apple-touch-icon" sizes="192x192" href="icons/icon-192.png"/>
  <link rel="apple-touch-icon" sizes="512x512" href="icons/icon-512.png"/>
  <!-- Favicon -->
  <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png"/>

  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Plus+Jakarta+Sans:wght@400;500;600;700;800&display=swap" rel="stylesheet"/>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Black+Han+Sans&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet"/>
  <style>
  /* ═══════════════════════════════════════════════
     DiNGo — NEON ARCADE
     Direction: Fighting game character select.
     Chunky. Color-blocked. Electric. Zero blur.
     Energy from contrast, not from animation noise.
  ═══════════════════════════════════════════════ */
  :root {
    --bg:      #0d0d0f;
    --ink:     #ffffff;
    --ink2:    rgba(255,255,255,0.5);
    --ink3:    rgba(255,255,255,0.18);
    --c1:      #00ffcc;   /* electric mint  */
    --c2:      #ff2d55;   /* hot red        */
    --c3:      #ffcc00;   /* arcade yellow  */
    --c4:      #7b61ff;   /* deep violet    */
    --c5:      #00b4ff;   /* sky blue       */
    --panel:   #141416;
    --panel2:  #1c1c1f;
    --edge:    rgba(255,255,255,0.08);
    --edge2:   rgba(255,255,255,0.14);
    --r:       8px;
    --r-lg:    16px;
  }
  body.light {
    --bg:    #f5f5f0;
    --ink:   #0d0d0f;
    --ink2:  rgba(0,0,0,0.5);
    --ink3:  rgba(0,0,0,0.15);
    --panel: #ffffff;
    --panel2:#f0f0eb;
    --edge:  rgba(0,0,0,0.08);
    --edge2: rgba(0,0,0,0.14);
  }

  *,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
  html,body{width:100%;height:100%;overflow:hidden}
  body{
    font-family:'Space Grotesk',sans-serif;
    background:var(--bg);color:var(--ink);
    display:flex;align-items:center;justify-content:center;
  }

  /* ── Scanline texture via CSS only ── */
  body::after{
    content:'';position:fixed;inset:0;pointer-events:none;z-index:9999;
    background:repeating-linear-gradient(
      0deg,
      transparent,transparent 2px,
      rgba(0,0,0,0.04) 2px,rgba(0,0,0,0.04) 3px
    );
  }
  body.light::after{background:repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(0,0,0,0.015) 2px,rgba(0,0,0,0.015) 3px)}

  /* Kill all canvas/particle elements */
  #bg-canvas,.bg-grid,.particles,.home-grid-bg,.home-grid-canvas,.scanlines,#splash-canvas{display:none!important}

  /* ── UI Buttons (Home + Theme) ── */
  /* ── In-card toolbar — travels inside every card, never floats over the page ── */
  #ui-toolbar{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px 4px;
    gap:6px;
    /* No position:fixed — just a normal flex row at the top of each card */
  }
  .toolbar-left{ display:flex;align-items:center;gap:6px; }
  .toolbar-right{ display:flex;align-items:center;gap:6px; }

  /* Shared base style for all three icon buttons */
  .ui-pill, #hard-refresh-btn{
    width:32px;height:32px;border-radius:7px;
    display:flex;align-items:center;justify-content:center;
    font-size:15px;cursor:pointer;
    border:none;outline:none;padding:0;
    transition:transform .12s,filter .12s,background .12s;
    flex-shrink:0;
  }
  .ui-pill:hover, #hard-refresh-btn:hover{ transform:translate(-1px,-1px);filter:brightness(1.2); }
  .ui-pill:active, #hard-refresh-btn:active{ transform:translate(1px,1px);filter:none; }
  .ui-pill .pill-icon{ display:flex;align-items:center;justify-content:center;width:32px;height:32px; }
  .ui-pill .pill-label{ display:none; } /* icon-only — no text label */

  /* Home button — mint */
  #global-home-btn{
    background:var(--c1);color:#000;
    box-shadow:2px 2px 0 rgba(0,255,204,0.25);
  }

  /* Hard Refresh button */
  #hard-refresh-btn{
    background:rgba(255,255,255,0.07);
    border:2px solid rgba(255,255,255,0.14)!important;
    color:var(--ink2);
    box-shadow:2px 2px 0 rgba(0,0,0,0.2);
  }
  #hard-refresh-btn:hover{
    background:rgba(255,255,255,0.13);color:var(--ink);
    transform:translate(-1px,-1px) rotate(-20deg);
  }
  body.light #hard-refresh-btn{ background:rgba(0,0,0,0.05);border-color:rgba(0,0,0,0.12)!important; }

  /* Theme button — violet */
  #theme-toggle{
    background:var(--c4);color:#fff;
    box-shadow:2px 2px 0 rgba(123,97,255,0.25);
  }
  body.light #theme-toggle{ background:#222;color:#fff; }

  /* Fullscreen button */
  #fullscreen-btn{
    background:rgba(255,255,255,0.07);
    border:2px solid rgba(255,255,255,0.14)!important;
    color:var(--ink2);
    box-shadow:2px 2px 0 rgba(0,0,0,0.2);
  }
  #fullscreen-btn:hover{
    background:rgba(255,255,255,0.13);color:var(--ink);
    transform:translate(-1px,-1px);
  }
  body.light #fullscreen-btn{ background:rgba(0,0,0,0.05);border-color:rgba(0,0,0,0.12)!important; }

  /* ── FOOTER ── */
  #game-footer{
    position:fixed;bottom:0;left:0;right:0;
    z-index:50;
    padding:7px 16px;
    display:flex;align-items:center;justify-content:space-between;
    background:var(--panel);
    border-top:1px solid var(--edge);
    pointer-events:none;
  }
  .footer-left{
    font-family:'Space Grotesk',sans-serif;
    font-size:9px;font-weight:700;letter-spacing:2px;
    text-transform:uppercase;color:var(--ink3);
  }
  .footer-brand{
    font-family:'Black Han Sans',sans-serif;
    font-size:11px;letter-spacing:2px;
    color:var(--c1);
  }
  .footer-right{
    font-family:'Space Grotesk',sans-serif;
    font-size:9px;font-weight:600;letter-spacing:1.5px;
    text-transform:uppercase;color:var(--ink3);
  }
  .footer-author{color:var(--c3);font-weight:800;}
  /* hide footer during gameplay screens */
  body.in-game #game-footer{ display:none; }

  /* ── Screen system ── */
  .screen{
    position:fixed;inset:0;
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    padding:12px 12px 40px;
    opacity:0;pointer-events:none;
    transform:translateY(14px);
    transition:opacity .28s ease,transform .28s ease;
    z-index:10;
  }
  .screen.active{opacity:1;pointer-events:all;transform:translateY(0)}
  .screen.exit{opacity:0;transform:translateY(-10px)}

  /* ── CARD ──
     Hard border + color accent bar on the left edge.
     Depth via nested dark panels not blur.
  ── */
  .card{
    background:var(--panel);
    border:2px solid var(--edge2);
    border-radius:var(--r-lg);
    width:100%;max-width:440px;
    position:relative;overflow:hidden;
    box-shadow:
      0 0 0 1px rgba(0,255,204,0.06),
      8px 8px 0 rgba(0,0,0,0.35);
  }
  body.light .card{box-shadow:8px 8px 0 rgba(0,0,0,0.08),0 0 0 1px rgba(0,0,0,0.06)}
  /* Color-block top bar */
  .card::before{
    content:'';position:absolute;top:0;left:0;right:0;height:3px;
    background:linear-gradient(90deg, var(--c1) 0%, var(--c2) 50%, var(--c3) 100%);
  }
  .card::after{display:none}
  .card-body{
    padding:26px 24px 22px;
    overflow-y:auto;max-height:calc(100vh - 90px);
    scrollbar-width:none;
  }
  .card-body::-webkit-scrollbar{display:none}

  /* ═══════════════════════════════════════════════
     SPLASH
  ═══════════════════════════════════════════════ */
  #splash-screen{background:transparent;padding:0}
  #splash-screen .card{
    max-width:480px;text-align:center;
    /* Big diagonal color stripe behind the logo */
    background:var(--panel);
    overflow:hidden;
  }
  #splash-screen .card-body{padding:48px 32px 52px;overflow:visible}

  /* Diagonal stripe */
  #splash-screen .card-body::before{
    content:'';position:absolute;
    top:-60px;right:-80px;
    width:260px;height:260px;
    background:var(--c1);
    opacity:0.04;
    transform:rotate(35deg);
    border-radius:var(--r);
    pointer-events:none;
  }

  .splash-top-badge{
    display:inline-flex;align-items:center;gap:7px;
    background:var(--panel2);
    border:2px solid var(--c1);
    border-radius:var(--r);padding:4px 12px;
    font-size:9px;letter-spacing:3px;text-transform:uppercase;font-weight:700;
    color:var(--c1);margin-bottom:28px;animation:fadeUp .4s .1s both;
  }
  .badge-live-dot{width:5px;height:5px;border-radius:50%;background:var(--c1);animation:blink2 1.4s infinite}
  @keyframes blink2{0%,100%{opacity:1}50%{opacity:.2}}

  .splash-ring{display:none}
  .splash-logo-wrap{display:block;margin-bottom:4px}

  /* LOGO — massive, two-tone, no gradient */
  .splash-logo{
    font-family:'Black Han Sans',sans-serif;
    font-size:clamp(88px,22vw,148px);
    color:var(--ink);
    display:block;line-height:.88;
    letter-spacing:-2px;
    animation:logoIn .6s cubic-bezier(.2,.8,.4,1.1) both;
    position:relative;
  }
  /* Drop shadow colored echo */
  .splash-logo::after{
    content:'DiNGo';
    position:absolute;left:4px;top:4px;
    color:var(--c1);
    z-index:-1;
    opacity:0.4;
  }
  @keyframes logoIn{0%{opacity:0;transform:scale(.85)}100%{opacity:1;transform:scale(1)}}

  .splash-tagline{
    font-size:11px;letter-spacing:4px;text-transform:uppercase;
    color:var(--ink2);margin-top:12px;margin-bottom:4px;
    animation:fadeUp .4s .25s both;font-weight:700;
  }
  .splash-game-sub{
    font-size:11px;letter-spacing:3px;text-transform:uppercase;
    color:var(--ink3);margin-bottom:24px;
    animation:fadeUp .4s .35s both;
  }
  .splash-desc{
    font-size:14px;color:var(--ink2);line-height:1.7;
    margin-bottom:30px;max-width:300px;margin-inline:auto;
    animation:fadeUp .4s .4s both;
  }
  .splash-desc strong{color:var(--ink);font-weight:700}

  /* Stats — color-block cells */
  .splash-stats{
    display:flex;justify-content:center;
    margin-bottom:30px;animation:fadeUp .4s .45s both;
    border:2px solid var(--edge2);border-radius:var(--r);overflow:hidden;
  }
  .splash-stat{display:flex;flex-direction:column;align-items:center;gap:2px;padding:12px 22px;flex:1;border-right:2px solid var(--edge2)}
  .splash-stat:last-child{border-right:none}
  .splash-stat-num{font-family:'Black Han Sans',sans-serif;font-size:26px;color:var(--ink);line-height:1}
  .splash-stat-label{font-size:8px;letter-spacing:2px;text-transform:uppercase;color:var(--ink3);font-weight:700}
  .splash-stat-divider{display:none}

  .btn-splash-enter{
    display:inline-flex;align-items:center;justify-content:center;gap:10px;
    padding:16px 44px;font-size:14px;letter-spacing:2px;text-transform:uppercase;
    font-family:'Space Grotesk',sans-serif;font-weight:800;
    border:2px solid var(--c1);border-radius:var(--r);cursor:pointer;
    background:var(--c1);color:#000;
    box-shadow:4px 4px 0 rgba(0,255,204,0.3);
    animation:fadeUp .4s .55s both;
    transition:transform .12s,box-shadow .12s;
  }
  .btn-splash-enter:hover{transform:translate(-2px,-2px);box-shadow:6px 6px 0 rgba(0,255,204,0.4)}
  .btn-splash-enter:active{transform:translate(2px,2px);box-shadow:2px 2px 0 rgba(0,255,204,0.2)}
  .btn-enter-icon{font-size:16px}
  @keyframes splashShimmer{}@keyframes splashBtnPulse{}@keyframes enterIconSpin{}
  .splash-micro{margin-top:14px;font-size:10px;color:var(--ink3);letter-spacing:1.5px;text-transform:uppercase;animation:fadeUp .3s .7s both}
  /* How to Play button on splash screen */
  .btn-splash-htp{
    display:inline-flex;align-items:center;gap:6px;
    margin-top:10px;
    background:transparent;
    border:2px solid rgba(0,255,204,0.35);
    border-radius:var(--r);
    padding:8px 20px;
    font-family:'Space Grotesk',sans-serif;font-size:11px;font-weight:800;
    letter-spacing:1.5px;text-transform:uppercase;
    color:var(--c1);cursor:pointer;
    box-shadow:2px 2px 0 rgba(0,255,204,0.15);
    transition:background .12s,border-color .12s,transform .1s,box-shadow .1s;
    animation:fadeUp .3s .65s both;
  }
  .btn-splash-htp:hover{
    background:rgba(0,255,204,0.08);border-color:var(--c1);
    transform:translate(-1px,-1px);box-shadow:4px 4px 0 rgba(0,255,204,0.22);
  }
  .btn-splash-htp:active{transform:translate(1px,1px);box-shadow:none}
  @keyframes fadeUp{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}

  /* ═══════════════════════════════════════════════
     BUTTONS
  ═══════════════════════════════════════════════ */
  .btn{
    display:inline-flex;align-items:center;justify-content:center;gap:7px;
    border:2px solid transparent;outline:none;cursor:pointer;
    font-family:'Space Grotesk',sans-serif;font-weight:700;
    font-size:12px;letter-spacing:1.5px;text-transform:uppercase;
    border-radius:var(--r);padding:11px 18px;
    transition:transform .1s,box-shadow .1s,background .1s;
    position:relative;overflow:hidden;
  }
  .btn::before{display:none}
  .btn:active{transform:translate(2px,2px)!important;box-shadow:none!important}
  .btn:disabled{opacity:.3;cursor:not-allowed;transform:none!important}
  .btn-full{width:100%}

  .btn-primary{
    background:var(--c1);color:#000;border-color:var(--c1);
    box-shadow:3px 3px 0 rgba(0,255,204,0.25);
  }
  .btn-primary:hover{transform:translate(-1px,-1px);box-shadow:4px 4px 0 rgba(0,255,204,0.3)}

  .btn-pink{
    background:var(--c2);color:#fff;border-color:var(--c2);
    box-shadow:3px 3px 0 rgba(255,45,85,0.25);
  }
  .btn-pink:hover{transform:translate(-1px,-1px);box-shadow:4px 4px 0 rgba(255,45,85,0.3)}

  .btn-gold{
    background:var(--c3);color:#000;border-color:var(--c3);
    box-shadow:3px 3px 0 rgba(255,204,0,0.25);
  }
  .btn-gold:hover{transform:translate(-1px,-1px);box-shadow:4px 4px 0 rgba(255,204,0,0.3)}

  .btn-ghost{
    background:transparent;color:var(--ink2);border-color:var(--edge2);
  }
  .btn-ghost:hover{color:var(--ink);border-color:var(--ink2)}
  body.light .btn-ghost{color:var(--ink2);border-color:var(--edge2)}

  /* ═══════════════════════════════════════════════
     NAME SCREEN
  ═══════════════════════════════════════════════ */
  .screen-logo{
    font-family:'Black Han Sans',sans-serif;
    font-size:40px;letter-spacing:2px;color:var(--ink);margin-bottom:4px;
  }
  .screen-sub{font-size:13px;color:var(--ink2);margin-bottom:22px;letter-spacing:.2px}
  .field-label{
    font-size:10px;font-weight:700;color:var(--ink2);
    margin-bottom:8px;letter-spacing:2.5px;text-transform:uppercase;
  }
  input[type="text"]{
    width:100%;background:var(--panel2);
    border:2px solid var(--edge2);border-radius:var(--r);
    padding:11px 13px;font-family:'Space Grotesk',sans-serif;font-size:15px;font-weight:500;
    color:var(--ink);outline:none;
    transition:border-color .12s;
  }
  input[type="text"]:focus{border-color:var(--c1)}
  input[type="text"]::placeholder{color:var(--ink3)}

  .avatar-grid{display:grid;grid-template-columns:repeat(6,1fr);gap:6px;margin-bottom:18px}
  .avatar-opt{
    aspect-ratio:1;border-radius:var(--r);border:2px solid var(--edge);
    background:var(--panel2);display:flex;align-items:center;justify-content:center;
    font-size:20px;cursor:pointer;transition:border-color .12s,transform .12s;
    overflow:hidden;padding:4px;
  }
  .avatar-opt svg{ width:100%;height:100%;display:block;border-radius:4px; }
  .avatar-opt:hover{border-color:var(--edge2);transform:scale(1.08)}
  .avatar-opt.selected{border-color:var(--c1);background:rgba(0,255,204,.08);transform:scale(1.1);box-shadow:0 0 0 2px rgba(0,255,204,0.2)}
  /* Avatar display in player boxes, home, stats — make SVG fill container */
  .player-avatar svg,.home-avatar svg,.stats-big-avatar svg,.pc-avatar svg{
    width:100%;height:100%;display:block;
  }
  .player-avatar{display:flex;align-items:center;justify-content:center;overflow:hidden;width:36px;height:36px;min-width:36px;min-height:36px;border-radius:6px}
  .home-avatar{display:flex;align-items:center;justify-content:center;overflow:hidden}
  .stats-big-avatar{display:flex;align-items:center;justify-content:center;overflow:hidden;width:48px;height:48px}
  .pc-avatar{display:flex;align-items:center;justify-content:center;overflow:hidden;width:64px;height:64px;margin:0 auto 8px}

  .color-strip{display:flex;gap:8px;margin-bottom:18px;flex-wrap:wrap}
  .color-swatch{
    width:26px;height:26px;border-radius:50%;cursor:pointer;
    border:3px solid transparent;transition:transform .12s, box-shadow .12s;
    flex-shrink:0;
  }
  .color-swatch:hover{transform:scale(1.18); box-shadow:0 0 0 2px rgba(255,255,255,0.3)}
  .color-swatch.selected{border-color:var(--ink);transform:scale(1.22); box-shadow:0 0 8px rgba(255,255,255,0.4)}

  /* ═══════════════════════════════════════════════
     HOME SCREEN
  ═══════════════════════════════════════════════ */
  #home-screen .card{max-width:460px}

  /* Profile strip — dark band with accent */
  .home-profile-strip{
    display:flex;align-items:center;gap:11px;
    background:var(--panel2);border:2px solid var(--edge);
    border-radius:var(--r);padding:10px 12px;
    margin-bottom:14px;
    position:relative;overflow:hidden;
  }
  /* Accent left stripe */
  .home-profile-strip::before{
    content:'';position:absolute;left:0;top:0;bottom:0;width:3px;
    background:var(--c1);
  }
  .home-avatar-wrap{position:relative;flex-shrink:0;margin-left:6px}
  .home-avatar{
    width:42px;height:42px;border-radius:var(--r);
    background:var(--panel);border:2px solid var(--edge2);
    display:flex;align-items:center;justify-content:center;font-size:21px;
  }
  .home-rank-badge{
    position:absolute;bottom:-6px;right:-6px;
    font-size:7px;font-weight:800;letter-spacing:1px;text-transform:uppercase;
    background:var(--c3);color:#000;border-radius:3px;padding:2px 5px;
  }
  .home-profile-info{flex:1;min-width:0}
  .home-username{font-size:15px;font-weight:700;margin-bottom:1px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  .home-rank-label{font-size:10px;color:var(--ink2);letter-spacing:1px}
  .home-profile-nodes{display:flex;gap:4px;margin-left:auto;flex-shrink:0;align-items:center}
  .node-dot{width:6px;height:6px;border-radius:2px}
  .node-dot:nth-child(1){background:var(--c1);opacity:.7}
  .node-dot:nth-child(2){background:var(--c3);opacity:.5}
  .node-dot:nth-child(3){background:var(--c2);opacity:.35}
  @keyframes nodePulse{}

  /* Banners */
  .home-banners{
    margin-bottom:12px;overflow:hidden;border-radius:var(--r);
    border:2px solid var(--edge);height:48px;background:var(--panel2);position:relative;
  }
  .banner-slide{position:absolute;inset:0;display:flex;align-items:center;gap:9px;padding:0 12px;opacity:0;transition:opacity .4s ease;pointer-events:none}
  .banner-slide.active{opacity:1;pointer-events:all}
  .banner-slide.banner-rush,.banner-slide.banner-event,.banner-slide.banner-skin{background:none}
  .banner-icon{font-size:18px;flex-shrink:0}
  .banner-title{font-size:12px;font-weight:700;letter-spacing:.1px;line-height:1.3}
  .banner-sub{font-size:10px;color:var(--ink2);margin-top:1px}
  .banner-dots{display:flex;gap:4px;position:absolute;bottom:4px;right:9px}
  .banner-dot{width:4px;height:4px;border-radius:2px;background:var(--edge2);transition:background .2s}
  .banner-dot.active{background:var(--c1)}

  /* Puzzle section */
  .home-puzzle-section{
    background:var(--panel2);border:2px solid var(--edge);
    border-radius:var(--r);padding:11px 12px;margin-bottom:12px;cursor:pointer;
    transition:border-color .12s;position:relative;overflow:hidden;
  }
  .home-puzzle-section:hover{border-color:var(--c3)}
  .home-puzzle-section::before{
    content:'';position:absolute;right:-20px;top:-20px;
    width:80px;height:80px;border-radius:50%;
    background:var(--c3);opacity:.04;pointer-events:none;
  }
  .puzzle-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
  .puzzle-label{font-size:9px;letter-spacing:2.5px;text-transform:uppercase;color:var(--c3);font-weight:700}
  .puzzle-timer{font-size:10px;color:var(--ink2)}
  .puzzle-mini-board{display:grid;grid-template-columns:repeat(5,1fr);gap:2px}
  .puzzle-cell{aspect-ratio:1;border-radius:3px;background:var(--panel);border:2px solid var(--edge);display:flex;align-items:center;justify-content:center;font-size:8px;font-weight:700;color:var(--ink3)}
  .puzzle-cell.filled{background:rgba(0,255,204,.08);border-color:rgba(0,255,204,.3);color:var(--c1)}
  .puzzle-cell.clickable{cursor:pointer;border-color:rgba(255,204,0,.3);color:var(--ink2);transition:border-color .12s,background .12s,transform .1s}
  .puzzle-cell.clickable:hover{background:rgba(255,204,0,.1);border-color:var(--c3);color:var(--c3);transform:scale(1.1)}
  .puzzle-cell.correct{background:rgba(0,255,204,.2)!important;border-color:var(--c1)!important;color:var(--c1)!important;animation:correctPop .3s cubic-bezier(.2,.8,.4,1.2)}
  .puzzle-cell.wrong{animation:wrongShake .35s ease}
  .puzzle-cell.revealed-win{background:rgba(255,204,0,.15)!important;border-color:var(--c3)!important;color:var(--c3)!important;animation:hintGlow 1.4s infinite}
  .puzzle-cell.done-filled{background:rgba(0,255,204,.08);border-color:rgba(0,255,204,.3);color:var(--c1)}
  .puzzle-cell.done-answer{background:rgba(255,204,0,.15);border-color:var(--c3);color:var(--c3)}
  @keyframes correctPop{0%{transform:scale(.7);opacity:.4}100%{transform:scale(1);opacity:1}}
  @keyframes wrongShake{0%,100%{transform:translateX(0)}25%{transform:translateX(-4px)}75%{transform:translateX(4px)}}
  @keyframes hintGlow{0%,100%{box-shadow:none}50%{box-shadow:0 0 8px rgba(255,204,0,.4)}}
  .puzzle-cta{font-size:10px;color:var(--ink2);margin-top:6px;text-align:center}
  .puzzle-result{margin-top:7px;text-align:center;font-size:11px;font-weight:700;letter-spacing:.5px;padding:5px 10px;border-radius:5px}
  .puzzle-result.win{color:var(--c1);background:rgba(0,255,204,.08);border:1px solid rgba(0,255,204,.2)}
  .puzzle-result.lose{color:var(--c2);background:rgba(255,45,85,.08);border:1px solid rgba(255,45,85,.2)}
  .puzzle-result.done{color:var(--c3);background:rgba(255,204,0,.08);border:1px solid rgba(255,204,0,.2)}

  /* Lobby chat */
  .home-lobby-chat{background:var(--panel2);border:2px solid var(--edge);border-radius:var(--r);padding:10px 12px;margin-bottom:12px}
  .lobby-chat-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:6px}
  .lobby-chat-label{font-size:9px;letter-spacing:2.5px;text-transform:uppercase;color:var(--c5);font-weight:700;display:flex;align-items:center;gap:5px}
  .lobby-live-dot{width:5px;height:5px;border-radius:50%;background:var(--c1);animation:blink2 1.4s infinite}
  .lobby-chat-count{font-size:10px;color:var(--ink2)}

  /* ── Online counter pill ── */
  .online-pill{
    display:inline-flex;align-items:center;gap:5px;
    background:rgba(0,255,204,0.08);
    border:1px solid rgba(0,255,204,0.25);
    border-radius:20px;padding:3px 10px;
    font-size:10px;font-weight:700;letter-spacing:1.5px;
    text-transform:uppercase;color:var(--c1);
  }
  .online-dot{
    width:6px;height:6px;border-radius:50%;
    background:var(--c1);
    box-shadow:0 0 6px var(--c1);
    animation:blink2 1.4s infinite;
    flex-shrink:0;
  }
  .online-pill.zero{ color:var(--ink3);border-color:var(--edge);background:transparent; }
  .online-pill.zero .online-dot{ background:var(--ink3);box-shadow:none;animation:none; }
  .lobby-messages{display:flex;flex-direction:column;gap:3px}
  .lobby-msg{display:flex;align-items:center;gap:6px;font-size:12px}
  .lobby-msg-avatar{font-size:12px;flex-shrink:0}
  .lobby-msg-name{font-weight:700;color:var(--ink2);font-size:10px;white-space:nowrap}
  .lobby-msg-text{color:var(--ink);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;flex:1}

  .home-action-zone{position:relative}

  /* PLAY NOW — biggest energy button on screen */
  .btn-play-now{
    width:100%;padding:18px 24px;font-size:16px;letter-spacing:2.5px;text-transform:uppercase;
    font-family:'Black Han Sans',sans-serif;
    background:var(--c1);color:#000;
    border:2px solid var(--c1);border-radius:var(--r);cursor:pointer;
    display:flex;align-items:center;justify-content:center;gap:10px;margin-bottom:8px;
    box-shadow:4px 4px 0 rgba(0,255,204,0.3);
    transition:transform .1s,box-shadow .1s;
    position:relative;overflow:hidden;
  }
  .btn-play-now::after{
    content:'';position:absolute;inset:0;
    background:linear-gradient(90deg,transparent 0%,rgba(255,255,255,.12) 50%,transparent 100%);
    transform:skewX(-20deg);
  }
  .btn-play-now::before{display:none}
  .btn-play-now:hover{transform:translate(-2px,-2px);box-shadow:6px 6px 0 rgba(0,255,204,0.35)}
  .btn-play-now:active{transform:translate(2px,2px);box-shadow:2px 2px 0 rgba(0,255,204,0.15)}
  .play-now-icon{font-size:18px;position:relative;z-index:1}
  .btn-play-now span:last-child{position:relative;z-index:1}
  @keyframes playIconBounce{}@keyframes playNowShimmer{}@keyframes playNowPulse{}

  /* VS Bot */
  .btn-vs-bot{
    width:100%;padding:12px 18px;font-size:11px;letter-spacing:2px;text-transform:uppercase;
    font-family:'Space Grotesk',sans-serif;font-weight:700;
    background:transparent;color:var(--c4);
    border:2px solid var(--c4);border-radius:var(--r);cursor:pointer;
    display:flex;align-items:center;justify-content:center;gap:8px;margin-bottom:8px;
    box-shadow:3px 3px 0 rgba(123,97,255,0.2);
    transition:transform .1s,box-shadow .1s,background .1s;
  }
  .btn-vs-bot::before{display:none}
  .btn-vs-bot:hover{background:rgba(123,97,255,.1);transform:translate(-1px,-1px);box-shadow:4px 4px 0 rgba(123,97,255,0.3)}
  .bot-icon{font-size:14px}

  .home-private-row{display:flex;gap:7px;margin-bottom:4px}
  .home-private-row button{flex:1;font-size:10px}
  .join-row input{flex:1;letter-spacing:4px;text-transform:uppercase}
  #home-msg{min-height:16px;font-size:12px;font-weight:700;text-align:center;margin-top:10px;color:var(--c2);letter-spacing:.5px}

  /* AI Modal */
  #ai-difficulty-modal{
    position:fixed;inset:0;z-index:700;
    display:flex;align-items:center;justify-content:center;
    background:rgba(0,0,0,.8);
    opacity:0;pointer-events:none;transition:opacity .2s;padding:20px;
  }
  #ai-difficulty-modal.show{opacity:1;pointer-events:all}
  .diff-card{
    background:var(--panel);border:2px solid var(--edge2);
    border-radius:var(--r-lg);padding:24px 20px;width:100%;max-width:320px;
    box-shadow:6px 6px 0 rgba(0,0,0,.5);
    animation:diffCardIn .2s ease both;position:relative;overflow:hidden;
  }
  .diff-card::before{
    content:'';position:absolute;top:0;left:0;right:0;height:3px;
    background:linear-gradient(90deg,var(--c4),var(--c2));
  }
  @keyframes diffCardIn{0%{transform:translateY(14px);opacity:0}100%{transform:translateY(0);opacity:1}}
  .diff-title{font-family:'Black Han Sans',sans-serif;font-size:28px;letter-spacing:3px;color:var(--ink);text-align:center;margin-bottom:4px}
  .diff-sub{font-size:9px;text-align:center;color:var(--ink2);letter-spacing:3px;text-transform:uppercase;margin-bottom:18px;font-weight:700}
  .diff-option{
    display:flex;align-items:center;gap:12px;
    background:var(--panel2);border:2px solid var(--edge);
    border-radius:var(--r);padding:11px 13px;margin-bottom:7px;
    cursor:pointer;transition:border-color .12s,transform .1s;
  }
  .diff-option:last-of-type{margin-bottom:0}
  .diff-option:hover{border-color:var(--edge2);transform:translate(-1px,-1px)}
  .diff-option:active{transform:translate(1px,1px)}
  .diff-emoji{font-size:22px;flex-shrink:0}
  .diff-info{flex:1}
  .diff-name{font-size:14px;font-weight:700;margin-bottom:1px}
  .diff-desc{font-size:11px;color:var(--ink2);line-height:1.4}
  .diff-badge{font-size:8px;font-weight:700;letter-spacing:1.5px;text-transform:uppercase;border-radius:3px;padding:3px 7px;flex-shrink:0}
  .badge-easy{background:rgba(0,255,204,.1);color:var(--c1);border:2px solid rgba(0,255,204,.25)}
  .badge-medium{background:rgba(255,204,0,.1);color:var(--c3);border:2px solid rgba(255,204,0,.25)}
  .badge-hard{background:rgba(255,45,85,.1);color:var(--c2);border:2px solid rgba(255,45,85,.25)}
  .badge-expert{background:rgba(123,97,255,.15);color:#a78bfa;border:2px solid rgba(123,97,255,.35)}
  .badge-nightmare{background:rgba(255,20,20,.18);color:#ff4444;border:2px solid rgba(255,20,20,.4);animation:nightmarePulse 1.8s infinite}
  @keyframes nightmarePulse{0%,100%{box-shadow:none}50%{box-shadow:0 0 8px rgba(255,20,20,.5)}}

  /* ═══════════════════════════════════════════
     FEATURE 6 — STATS POPUP
  ═══════════════════════════════════════════ */
  #stats-popup{
    position:fixed;inset:0;z-index:900;
    display:flex;align-items:center;justify-content:center;
    background:rgba(0,0,0,.82);padding:20px;
    opacity:0;pointer-events:none;transition:opacity .22s;
  }
  #stats-popup.show{opacity:1;pointer-events:all}
  .stats-card{
    background:var(--panel);border:2px solid var(--edge2);
    border-radius:var(--r-lg);padding:0;width:100%;max-width:340px;
    box-shadow:8px 8px 0 rgba(0,0,0,.5);
    position:relative;overflow:hidden;
  }
  .stats-card::before{content:'';position:absolute;top:0;left:0;right:0;height:3px;
    background:linear-gradient(90deg,var(--c1),var(--c4),var(--c2))}
  .stats-header{display:flex;align-items:center;justify-content:space-between;padding:16px 18px 0}
  .stats-title{font-family:'Black Han Sans',sans-serif;font-size:24px;letter-spacing:3px;color:var(--ink)}
  .stats-close{background:none;border:2px solid var(--edge2);color:var(--ink2);
    width:30px;height:30px;border-radius:6px;cursor:pointer;font-size:14px;
    display:flex;align-items:center;justify-content:center;transition:border-color .12s,color .12s}
  .stats-close:hover{border-color:var(--c2);color:var(--c2)}
  .stats-body{padding:14px 18px 20px}
  .stats-avatar-row{display:flex;align-items:center;gap:12px;margin-bottom:16px;
    background:var(--panel2);border:2px solid var(--edge);border-radius:var(--r);padding:12px}
  .stats-big-avatar{font-size:36px;line-height:1}
  .stats-name-col{flex:1}
  .stats-player-name{font-family:'Black Han Sans',sans-serif;font-size:20px;letter-spacing:1px;color:var(--ink)}
  .stats-color-dot{width:12px;height:12px;border-radius:50%;display:inline-block;margin-right:6px;vertical-align:middle}
  .stats-color-label{font-size:10px;color:var(--ink2);letter-spacing:1.5px;text-transform:uppercase;font-weight:700}
  .stats-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:14px}
  .stats-cell{background:var(--panel2);border:2px solid var(--edge);border-radius:var(--r);
    padding:10px 12px;text-align:center}
  .stats-cell-num{font-family:'Black Han Sans',sans-serif;font-size:26px;color:var(--ink);line-height:1}
  .stats-cell-lbl{font-size:8px;color:var(--ink3);letter-spacing:2px;text-transform:uppercase;font-weight:700;margin-top:2px}
  .stats-reset-btn{width:100%;background:none;border:2px solid var(--edge2);color:var(--ink3);
    border-radius:var(--r);padding:8px;font-family:'Space Grotesk',sans-serif;font-size:10px;
    letter-spacing:2px;text-transform:uppercase;font-weight:700;cursor:pointer;transition:color .12s,border-color .12s}
  .stats-reset-btn:hover{color:var(--c2);border-color:var(--c2)}
  .home-avatar-wrap{cursor:pointer}
  .home-avatar-wrap:hover .home-avatar{transform:scale(1.1)}

  /* ═══════════════════════════════════════════
     FEATURE 9 — BOARD THEMES
  ═══════════════════════════════════════════ */
  #theme-picker-btn{
    background:rgba(255,255,255,.07);border:2px solid var(--edge2);
    border-radius:var(--r);padding:4px 8px;
    font-size:14px;color:var(--ink2);cursor:pointer;
    transition:background .12s,color .12s;flex-shrink:0;
  }
  #theme-picker-btn:hover{background:rgba(255,255,255,.13);color:var(--ink)}
  #theme-picker-modal{
    position:fixed;inset:0;z-index:900;
    display:flex;align-items:center;justify-content:center;
    background:rgba(0,0,0,.82);padding:20px;
    opacity:0;pointer-events:none;transition:opacity .22s;
  }
  #theme-picker-modal.show{opacity:1;pointer-events:all}
  .theme-picker-card{
    background:var(--panel);border:2px solid var(--edge2);
    border-radius:var(--r-lg);padding:0;width:100%;max-width:360px;
    box-shadow:8px 8px 0 rgba(0,0,0,.5);position:relative;overflow:hidden;
  }
  .theme-picker-card::before{content:'';position:absolute;top:0;left:0;right:0;height:3px;
    background:linear-gradient(90deg,var(--c3),var(--c1),var(--c4))}
  .theme-picker-header{display:flex;align-items:center;justify-content:space-between;padding:16px 18px 0}
  .theme-picker-title{font-family:'Black Han Sans',sans-serif;font-size:22px;letter-spacing:3px;color:var(--ink)}
  .theme-close{background:none;border:2px solid var(--edge2);color:var(--ink2);
    width:30px;height:30px;border-radius:6px;cursor:pointer;font-size:14px;
    display:flex;align-items:center;justify-content:center;transition:border-color .12s}
  .theme-close:hover{border-color:var(--c2);color:var(--c2)}
  .theme-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;padding:14px 18px 20px}
  .theme-opt{
    border:3px solid var(--edge);border-radius:var(--r);padding:10px;cursor:pointer;
    transition:border-color .12s,transform .1s;text-align:center;
  }
  .theme-opt:hover{transform:translate(-1px,-1px)}
  .theme-opt.active{border-color:var(--c1)}
  .theme-opt-preview{
    width:100%;aspect-ratio:1;border-radius:5px;margin-bottom:7px;
    display:grid;grid-template-columns:repeat(5,1fr);gap:2px;padding:4px;
  }
  .tp-cell{border-radius:2px;aspect-ratio:1}
  .theme-opt-name{font-size:10px;font-weight:700;letter-spacing:1.5px;text-transform:uppercase;color:var(--ink2)}
  /* Theme applied to board */
  /* ── FRIENDS SYSTEM ── */
  #friends-screen .card-body{ padding:20px 18px; }
  .friend-card{ transition:border-color .15s; }
  .friend-card:hover{ border-color:var(--edge2)!important; }
  #welcome-back-popup .btn{ font-size:13px; }
  #wb-avatar{ text-shadow:0 0 30px rgba(0,255,204,.3); }

  /* ── RETRO (green terminal) ── */
  body.theme-retro .board{border:2px solid #00ff00;box-shadow:0 0 20px rgba(0,255,0,.2);background:#001100}
  body.theme-retro .cell{border-color:#00aa00;color:#00ff00;background:#001a00;font-family:monospace;letter-spacing:1px}
  body.theme-retro .cell:not(.crossed):hover{background:rgba(0,255,0,.1)!important;border-color:#00ff00!important}
  body.theme-retro .cell.crossed{background:rgba(0,255,0,.12)!important;border-color:#00ff00!important}
  body.theme-retro .cell.crossed::after{content:'■';color:#00ff00!important}
  body.theme-retro .cell.win-line{background:rgba(0,255,0,.2)!important;border-color:#00ff00!important;color:#00ff00!important}

  /* ── ICE (blue) ── */
  body.theme-ice .board{border:2px solid #7ee8ff;box-shadow:0 0 20px rgba(100,200,255,.2);background:#050d1a}
  body.theme-ice .cell{border-color:#1a4a6a;color:#7ee8ff;background:#071220}
  body.theme-ice .cell:not(.crossed):hover{background:rgba(100,200,255,.1)!important;border-color:#7ee8ff!important}
  body.theme-ice .cell.crossed{background:rgba(100,200,255,.15)!important;border-color:rgba(100,200,255,.5)!important}
  body.theme-ice .cell.crossed::after{color:#7ee8ff!important}
  body.theme-ice .cell.win-line{background:rgba(100,200,255,.2)!important;border-color:#7ee8ff!important;color:#7ee8ff!important}

  /* ── FIRE (orange) ── */
  body.theme-fire .board{border:2px solid #ff6a00;box-shadow:0 0 20px rgba(255,100,0,.2);background:#1a0500}
  body.theme-fire .cell{border-color:#6a1a00;color:#ff6a00;background:#200800}
  body.theme-fire .cell:not(.crossed):hover{background:rgba(255,100,0,.1)!important;border-color:#ff6a00!important}
  body.theme-fire .cell.crossed{background:rgba(255,100,0,.15)!important;border-color:rgba(255,120,0,.5)!important}
  body.theme-fire .cell.crossed::after{color:#ff6a00!important}
  body.theme-fire .cell.win-line{background:rgba(255,100,0,.2)!important;border-color:#ff6a00!important;color:#ff6a00!important}

  /* ── VOID (purple) ── */
  body.theme-purple .board{border:2px solid #bf7aff;box-shadow:0 0 20px rgba(160,80,255,.2);background:#0a0014}
  body.theme-purple .cell{border-color:#3a0060;color:#bf7aff;background:#0f0020}
  body.theme-purple .cell:not(.crossed):hover{background:rgba(160,80,255,.1)!important;border-color:#bf7aff!important}
  body.theme-purple .cell.crossed{background:rgba(160,80,255,.15)!important;border-color:rgba(160,80,255,.5)!important}
  body.theme-purple .cell.crossed::after{color:#bf7aff!important}
  body.theme-purple .cell.win-line{background:rgba(160,80,255,.2)!important;border-color:#ff7aff!important;color:#ff7aff!important}

  /* ── ROSE (pink) ── */
  body.theme-rose .board{border:2px solid #ff6eb4;box-shadow:0 0 20px rgba(255,80,160,.2);background:#1a000a}
  body.theme-rose .cell{border-color:#6a0030;color:#ff6eb4;background:#200010}
  body.theme-rose .cell:not(.crossed):hover{background:rgba(255,80,160,.1)!important;border-color:#ff6eb4!important}
  body.theme-rose .cell.crossed{background:rgba(255,80,160,.15)!important;border-color:rgba(255,100,180,.5)!important}
  body.theme-rose .cell.crossed::after{color:#ff6eb4!important}
  body.theme-rose .cell.win-line{background:rgba(255,80,160,.2)!important;border-color:#ffd6ec!important;color:#ffd6ec!important}

  /* ═══════════════════════════════════════════
     FEATURE 10 — MUSIC PLAYER
  ═══════════════════════════════════════════ */
  /* Music button in toolbar */
  #music-toggle-btn{ font-size:14px; }
  #music-toggle-btn.playing{ color:var(--c1) !important; border-color:var(--c1) !important; }
  .music-btn:hover{ opacity:.7; }

  /* ═══════════════════════════════════════════
     FEATURE 11 — WIN ANIMATION PICKER
  ═══════════════════════════════════════════ */
  .win-anim-row{
    display:flex;gap:6px;margin-top:10px;justify-content:center;
  }
  .win-anim-opt{
    flex:1;background:var(--panel2);border:2px solid var(--edge);
    border-radius:var(--r);padding:8px 4px;text-align:center;
    cursor:pointer;transition:border-color .12s,transform .1s;font-size:18px;
  }
  .win-anim-opt:hover{transform:scale(1.05)}
  .win-anim-opt.active{border-color:var(--c1)}
  .win-anim-opt span{display:block;font-size:8px;letter-spacing:1px;text-transform:uppercase;
    color:var(--ink3);font-weight:700;margin-top:3px;font-family:'Space Grotesk',sans-serif}
  /* Lightning overlay */
  #lightning-canvas{position:fixed;inset:0;pointer-events:none;z-index:198;display:none}
  /* Fire canvas */
  #fire-canvas{position:fixed;inset:0;pointer-events:none;z-index:197;display:none}
  /* Diamond canvas */
  #diamond-canvas{position:fixed;inset:0;pointer-events:none;z-index:196;display:none}

  /* ═══════════════════════════════════════════
     FEATURE 12 — PLAYER CARD
  ═══════════════════════════════════════════ */
  #player-card-popup{
    position:fixed;inset:0;z-index:900;
    display:flex;align-items:center;justify-content:center;
    background:rgba(0,0,0,.82);padding:20px;
    opacity:0;pointer-events:none;transition:opacity .22s;
  }
  #player-card-popup.show{opacity:1;pointer-events:all}
  .player-card{
    width:100%;max-width:300px;
    border-radius:var(--r-lg);
    position:relative;overflow:hidden;
    box-shadow:10px 10px 0 rgba(0,0,0,.5);
    border:2px solid var(--edge2);
  }
  .pc-bg{
    background:var(--panel);
    padding:28px 24px 20px;
    text-align:center;
  }
  .pc-top-bar{height:4px;background:linear-gradient(90deg,var(--c1),var(--c4),var(--c2));
    position:absolute;top:0;left:0;right:0}
  .pc-name{font-family:'Black Han Sans',sans-serif;font-size:28px;letter-spacing:2px;
    color:var(--ink);margin-bottom:6px}
  .pc-color-bar{height:6px;border-radius:3px;margin:0 auto 12px;width:60px}
  .pc-badge{display:inline-block;font-size:8px;letter-spacing:2.5px;text-transform:uppercase;
    font-weight:700;padding:3px 10px;border-radius:3px;margin-bottom:16px;
    background:rgba(0,255,204,.1);color:var(--c1);border:2px solid rgba(0,255,204,.25)}
  .pc-divider{border:none;border-top:1px solid var(--edge);margin:0 0 14px}
  .pc-footer{font-size:9px;letter-spacing:2px;text-transform:uppercase;color:var(--ink3);
    font-weight:700;margin-bottom:12px}
  .pc-actions{display:flex;gap:8px;margin-top:4px}
  .pc-btn{flex:1;background:none;border:2px solid var(--edge2);color:var(--ink2);
    border-radius:var(--r);padding:8px;font-family:'Space Grotesk',sans-serif;
    font-size:10px;letter-spacing:1.5px;text-transform:uppercase;font-weight:700;
    cursor:pointer;transition:color .12s,border-color .12s}
  .pc-btn:hover{color:var(--ink);border-color:var(--c1)}
  .pc-btn.primary{background:var(--c1);color:#000;border-color:var(--c1)}
  .pc-btn.primary:hover{opacity:.85}
  /* Card button in home screen */
  #show-card-btn{
    display:flex;align-items:center;gap:5px;
    background:transparent;border:2px solid var(--edge2);
    border-radius:var(--r);padding:5px 10px;font-family:'Space Grotesk',sans-serif;
    font-size:9px;letter-spacing:1.5px;text-transform:uppercase;font-weight:700;
    color:var(--ink2);cursor:pointer;transition:color .12s,border-color .12s;
  }
  #show-card-btn:hover{color:var(--c1);border-color:var(--c1)}

  /* ═══════════════════════════════════════════
     FEATURE 13 — TOURNAMENT MODE
  ═══════════════════════════════════════════ */
  #tournament-screen .card{max-width:480px}
  .tourn-badge{
    display:inline-flex;align-items:center;gap:6px;
    background:rgba(255,204,0,.08);border:2px solid rgba(255,204,0,.3);
    border-radius:var(--r);padding:4px 12px;font-size:9px;letter-spacing:3px;
    text-transform:uppercase;font-weight:700;color:var(--c3);margin-bottom:16px;
  }
  .tourn-code-display{
    font-family:'Black Han Sans',sans-serif;font-size:42px;letter-spacing:8px;
    color:var(--c3);text-align:center;
    background:var(--panel2);border:2px solid rgba(255,204,0,.25);
    border-radius:var(--r);padding:14px;margin:12px 0;
    text-shadow:0 0 20px rgba(255,204,0,.3);
  }
  .tourn-slots{display:flex;flex-direction:column;gap:6px;margin:12px 0}
  .tourn-slot{
    display:flex;align-items:center;gap:10px;
    background:var(--panel2);border:2px solid var(--edge);
    border-radius:var(--r);padding:8px 12px;
    transition:border-color .2s;
  }
  .tourn-slot.filled{border-color:rgba(0,255,204,.3)}
  .tourn-slot.active-match{border-color:var(--c3);background:rgba(255,204,0,.04)}
  .tourn-slot-num{font-family:'Black Han Sans',sans-serif;font-size:16px;
    color:var(--ink3);width:20px;flex-shrink:0}
  .tourn-slot-avatar{font-size:20px;flex-shrink:0}
  .tourn-slot-name{flex:1;font-size:13px;font-weight:700;color:var(--ink)}
  .tourn-slot-status{font-size:9px;letter-spacing:1.5px;text-transform:uppercase;
    font-weight:700;color:var(--ink3)}
  .tourn-slot-status.win{color:var(--c1)}.tourn-slot-status.out{color:var(--c2);opacity:.5}
  .tourn-bracket{margin:12px 0}
  .bracket-round{margin-bottom:12px}
  .bracket-round-label{font-size:9px;letter-spacing:2.5px;text-transform:uppercase;
    color:var(--ink3);font-weight:700;margin-bottom:6px}
  .bracket-match{
    display:flex;align-items:center;justify-content:space-between;
    background:var(--panel2);border:2px solid var(--edge);
    border-radius:var(--r);padding:8px 12px;margin-bottom:5px;
  }
  .bracket-match.current{border-color:var(--c3)}
  .bracket-player{display:flex;align-items:center;gap:6px;font-size:12px;font-weight:700}
  .bracket-player.winner{color:var(--c1)}
  .bracket-player.loser{opacity:.4;text-decoration:line-through}
  .bracket-vs{font-size:10px;color:var(--ink3);font-weight:700}
  .tourn-status-bar{
    text-align:center;font-size:11px;font-weight:700;letter-spacing:1px;
    color:var(--c3);padding:8px;margin:8px 0;
    background:rgba(255,204,0,.06);border:1px solid rgba(255,204,0,.15);
    border-radius:var(--r);
  }
  #tourn-start-btn{margin-top:10px}
  .diff-cancel{display:block;width:100%;margin-top:10px;background:none;border:none;color:var(--ink2);font-family:'Space Grotesk',sans-serif;font-size:11px;letter-spacing:2px;text-transform:uppercase;cursor:pointer;font-weight:700;padding:8px;transition:color .12s}
  .diff-cancel:hover{color:var(--ink)}

  /* ── How to Play Modal ── */
  #htp-modal{
    position:fixed;inset:0;z-index:800;
    display:flex;align-items:center;justify-content:center;
    background:rgba(0,0,0,.82);backdrop-filter:blur(4px);
    opacity:0;pointer-events:none;transition:opacity .22s;padding:16px;
  }
  #htp-modal.show{opacity:1;pointer-events:all}
  .htp-card{
    background:var(--panel);border:2px solid var(--edge2);
    border-radius:var(--r-lg);padding:0;width:100%;max-width:360px;
    box-shadow:8px 8px 0 rgba(0,0,0,.5);
    animation:diffCardIn .22s ease both;
    position:relative;overflow:hidden;max-height:90vh;overflow-y:auto;
    scrollbar-width:none;
  }
  .htp-card::-webkit-scrollbar{display:none}
  .htp-card::before{content:'';position:absolute;top:0;left:0;right:0;height:3px;
    background:linear-gradient(90deg,var(--c1),var(--c4),var(--c2));z-index:1}
  .htp-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:18px 18px 0;
  }
  .htp-title{font-family:'Black Han Sans',sans-serif;font-size:26px;letter-spacing:3px;color:var(--ink)}
  .htp-close{background:none;border:2px solid var(--edge2);color:var(--ink2);
    width:30px;height:30px;border-radius:6px;cursor:pointer;font-size:14px;
    display:flex;align-items:center;justify-content:center;
    transition:border-color .12s,color .12s}
  .htp-close:hover{border-color:var(--c2);color:var(--c2)}
  .htp-body{padding:12px 18px 22px}
  .htp-step{
    display:flex;align-items:flex-start;gap:12px;
    padding:10px 0;border-bottom:1px solid var(--edge);
  }
  .htp-step:last-child{border-bottom:none}
  .htp-step-num{
    width:26px;height:26px;border-radius:6px;flex-shrink:0;
    display:flex;align-items:center;justify-content:center;
    font-family:'Black Han Sans',sans-serif;font-size:13px;
    background:var(--panel2);border:2px solid var(--edge2);color:var(--c1);
  }
  .htp-step-text{flex:1;font-size:12px;color:var(--ink2);line-height:1.6}
  .htp-step-text strong{color:var(--ink);font-weight:700}
  .htp-win-demo{
    margin:12px 0;display:grid;grid-template-columns:repeat(5,1fr);gap:3px;
  }
  .htp-cell{
    aspect-ratio:1;border-radius:4px;border:2px solid var(--edge);
    background:var(--panel2);display:flex;align-items:center;justify-content:center;
    font-size:9px;font-weight:700;color:var(--ink3);font-family:'Black Han Sans',sans-serif;
  }
  .htp-cell.cx{background:rgba(0,255,204,.1);border-color:rgba(0,255,204,.4);color:var(--c1)}
  .htp-cell.win{background:rgba(255,204,0,.18);border-color:var(--c3);color:var(--c3);
    animation:winLineGlowOnce 2s ease-out forwards}
  .htp-tag{display:inline-block;font-size:8px;font-weight:700;letter-spacing:1.5px;
    text-transform:uppercase;border-radius:3px;padding:2px 7px;margin-top:4px}
  .htp-tag.green{background:rgba(0,255,204,.1);color:var(--c1);border:1px solid rgba(0,255,204,.25)}
  .htp-tag.gold{background:rgba(255,204,0,.1);color:var(--c3);border:1px solid rgba(255,204,0,.25)}
  .htp-tag.red{background:rgba(255,45,85,.1);color:var(--c2);border:1px solid rgba(255,45,85,.25)}

  /* ── Opponent Left Popup ── */
  #opponent-left-popup{
    position:fixed;top:56px;left:50%;transform:translateX(-50%) translateY(-20px);
    z-index:950;opacity:0;pointer-events:none;
    transition:opacity .3s,transform .3s;
    background:var(--panel);border:2px solid var(--c2);border-radius:var(--r-lg);
    padding:14px 18px;display:flex;align-items:center;gap:12px;
    box-shadow:5px 5px 0 rgba(255,45,85,.3);
    white-space:nowrap;min-width:280px;
  }
  #opponent-left-popup.show{opacity:1;pointer-events:all;transform:translateX(-50%) translateY(0)}
  .opp-left-icon{font-size:22px;flex-shrink:0}
  .opp-left-body{flex:1}
  .opp-left-title{font-family:'Black Han Sans',sans-serif;font-size:16px;letter-spacing:1.5px;color:var(--c2)}
  .opp-left-sub{font-size:10px;color:var(--ink2);letter-spacing:.5px;margin-top:2px}
  .opp-left-close-wrap{flex-shrink:0}
  .opp-left-timer-ring{position:relative;width:36px;height:36px;display:flex;align-items:center;justify-content:center}
  .opp-left-ring-svg{position:absolute;inset:0;width:36px;height:36px;transform:rotate(-90deg)}
  #opp-left-secs{font-family:'Black Han Sans',sans-serif;font-size:13px;color:var(--c2);position:relative;z-index:1}

  /* ── Abandon countdown banner (hidden — kept for legacy win logic) ── */
  #abandon-banner{
    position:fixed;top:56px;left:50%;transform:translateX(-50%) translateY(-20px);
    z-index:900;opacity:0;pointer-events:none;
    background:var(--panel);border:2px solid var(--c2);border-radius:var(--r);
    padding:9px 16px;display:none;align-items:center;gap:10px;
    box-shadow:4px 4px 0 rgba(255,45,85,.25);
    white-space:nowrap;
  }
  #abandon-banner.show{opacity:1;pointer-events:all;transform:translateX(-50%) translateY(0)}
  .abandon-icon{font-size:18px}
  .abandon-text{font-size:11px;color:var(--ink2);font-weight:600}
  .abandon-text strong{color:var(--c2)}
  #abandon-timer{
    font-family:'Black Han Sans',sans-serif;font-size:22px;color:var(--c2);
    min-width:28px;text-align:center;line-height:1;
  }

  /* ── Move Timer Bar ── */
  #move-timer-wrap{
    display:none;align-items:center;gap:7px;
    margin-bottom:6px;
  }
  #move-timer-wrap.active{display:flex}
  #move-timer-bar-track{
    flex:1;height:6px;background:var(--edge);border-radius:999px;overflow:hidden;
  }
  #move-timer-bar-fill{
    height:100%;width:100%;background:var(--c1);border-radius:999px;
    transition:width 1s linear, background .3s;
  }
  #move-timer-bar-fill.warning{background:var(--c3)}
  #move-timer-bar-fill.danger{background:var(--c2)}
  #move-timer-secs{
    font-family:'Black Han Sans',sans-serif;font-size:15px;color:var(--ink2);
    min-width:22px;text-align:right;line-height:1;
    transition:color .3s;
  }
  #move-timer-secs.warning{color:var(--c3)}
  #move-timer-secs.danger{color:var(--c2)}

  /* ── Lifelines — embedded in each player box ── */
  .player-avatar-wrap{
    display:flex;flex-direction:column;align-items:center;gap:3px;flex-shrink:0;
  }
  .lifelines-chips.inline{
    display:flex;flex-direction:row;gap:2px;justify-content:center;
  }
  .lifelines-chips.inline.hidden{display:none}
  .lifeline-chip{font-size:9px;transition:opacity .25s,transform .25s;display:inline-block;line-height:1}
  .lifeline-chip.used{opacity:.15;transform:scale(.7)}
  /* p2's avatar-wrap is reversed (box is row-reverse) so chips read left→right from avatar */
  .player-box.p2 .player-avatar-wrap{align-items:center}

  /* AI thinking */
  #ai-thinking-bar{display:none;align-items:center;gap:6px;justify-content:center;font-size:10px;color:var(--c4);letter-spacing:2.5px;text-transform:uppercase;font-weight:700;margin-bottom:6px}
  #ai-thinking-bar.show{display:flex}
  .think-dot{width:4px;height:4px;border-radius:1px;background:var(--c4);animation:thinkBounce .9s ease-in-out infinite}
  .think-dot:nth-child(2){animation-delay:.18s}.think-dot:nth-child(3){animation-delay:.36s}
  @keyframes thinkBounce{0%,100%{transform:translateY(0);opacity:.3}50%{transform:translateY(-5px);opacity:1}}
  .ai-mode-pill{font-size:8px;letter-spacing:1.5px;text-transform:uppercase;font-weight:700;background:rgba(123,97,255,.1);color:var(--c4);border:2px solid rgba(123,97,255,.2);border-radius:3px;padding:2px 7px;display:none}
  .ai-mode-pill.show{display:inline-block}
  .player-box.is-bot{border-color:rgba(123,97,255,.2)}
  .player-box.is-bot.active-turn{border-color:var(--c4)!important;box-shadow:4px 4px 0 rgba(123,97,255,.15)!important}
  .player-box.is-bot::after{background:linear-gradient(180deg,var(--c4),var(--c2))!important}

  /* ═══════════════════════════════════════════════
     ROOM BADGE
  ═══════════════════════════════════════════════ */
  .room-badge{
    background:var(--panel2);border:2px solid var(--edge);
    border-radius:var(--r);padding:12px 14px;margin-bottom:16px;
    display:flex;align-items:center;justify-content:space-between;gap:12px;
    position:relative;overflow:hidden;
  }
  .room-badge::before{content:'';position:absolute;left:0;top:0;bottom:0;width:3px;background:var(--c1)}
  .room-badge-label{font-size:9px;letter-spacing:2px;text-transform:uppercase;color:var(--ink2);margin-bottom:4px;font-weight:700}
  .room-badge-code{font-family:'Black Han Sans',sans-serif;font-size:30px;letter-spacing:6px;color:var(--c1)}
  .waiting-dots{display:flex;align-items:center;gap:5px;font-size:10px;color:var(--ink2)}
  .dot{width:4px;height:4px;border-radius:1px;background:var(--c1);animation:blink 1.2s ease-in-out infinite}
  .dot:nth-child(2){animation-delay:.2s}.dot:nth-child(3){animation-delay:.4s}
  @keyframes blink{0%,100%{opacity:.2}50%{opacity:1}}

  /* ═══════════════════════════════════════════════
     SETUP BOARD
  ═══════════════════════════════════════════════ */
  .section-title{font-family:'Black Han Sans',sans-serif;font-size:24px;letter-spacing:3px;margin-bottom:4px}
  .section-sub{font-size:12px;color:var(--ink2);margin-bottom:12px;line-height:1.5}
  .progress-bar{height:3px;background:var(--edge);border-radius:999px;overflow:hidden;margin-bottom:12px}
  .progress-fill{height:100%;background:var(--c1);width:0%;transition:width .3s ease;border-radius:999px}
  .setup-actions{display:flex;gap:6px;margin-bottom:10px}
  .setup-actions .btn{flex:1;font-size:10px;padding:8px 4px}

  /* ═══════════════════════════════════════════════
     BINGO CELLS
  ═══════════════════════════════════════════════ */
  .board-wrap{display:flex;justify-content:center;margin-bottom:10px}
  .board{
    display:grid;grid-template-columns:repeat(5,1fr);gap:4px;
    width:min(100%,min(calc(100vw - 52px),calc(100vh - 330px)));
  }
  .cell{
    border-radius:var(--r);border:2px solid var(--edge);
    background:var(--panel2);
    display:flex;align-items:center;justify-content:center;
    font-family:'Black Han Sans',sans-serif;
    font-size:clamp(13px,3.8vw,22px);
    color:var(--ink2);cursor:pointer;
    transition:background .12s,border-color .12s,color .12s,transform .1s;
    user-select:none;position:relative;overflow:hidden;aspect-ratio:1;
  }
  .cell::before{display:none}
  #setup-board .cell:not([data-filled]):hover{
    background:rgba(0,255,204,.07);border-color:rgba(0,255,204,.4);
    color:var(--ink);transform:scale(1.07)
  }
  #setup-board .cell[data-filled]{
    background:rgba(0,255,204,.1);border-color:var(--c1);
    color:var(--c1);animation:cellPop .18s cubic-bezier(.2,.8,.4,1.2);
  }
  @keyframes cellPop{0%{transform:scale(.5);opacity:0}100%{transform:scale(1);opacity:1}}
  #game-board .cell:not(.crossed):hover{
    background:rgba(255,204,0,.07);border-color:rgba(255,204,0,.4);
    color:var(--ink);transform:scale(1.06)
  }
  .cell.crossed{
    background:rgba(0,255,204,.08);border-color:rgba(0,255,204,.3);
    color:rgba(0,255,204,.3);cursor:default;
    animation:crossPop .18s ease;
  }
  .cell.crossed::after{
    content:'✕';position:absolute;inset:0;
    display:flex;align-items:center;justify-content:center;
    color:var(--c1);font-size:1.2em;opacity:.5;font-family:'Space Grotesk',sans-serif;
  }
  @keyframes crossPop{0%{transform:scale(1.3)}100%{transform:scale(1)}}
  .cell.win-line{
    background:rgba(255,204,0,.18)!important;border-color:var(--c3)!important;
    color:var(--c3)!important;z-index:2;
    animation:winLineGlowOnce 2s ease-out forwards!important;
  }
  .cell.win-line::after{color:var(--c3)!important}
  /* One-shot glow: peaks at 1s then fades to a calm steady gold state */
  @keyframes winLineGlowOnce{
    0%  {box-shadow:0 0 6px  rgba(255,204,0,.3), inset 0 0 4px  rgba(255,204,0,.06)}
    40% {box-shadow:0 0 28px rgba(255,204,0,.9), 0 0 56px rgba(255,204,0,.45),
                    inset 0 0 16px rgba(255,204,0,.18)}
    100%{box-shadow:0 0 8px  rgba(255,204,0,.35),inset 0 0 6px  rgba(255,204,0,.07)}
  }
  /* Flash overlay that fires once when a new line is found */
  @keyframes lineBurst{
    0%{opacity:1;transform:scale(1.18)}
    100%{opacity:0;transform:scale(1)}
  }
  .cell.line-burst{
    animation:lineBurst .35s ease-out forwards, winLineGlowOnce 2s ease-out forwards .35s!important;
    background:rgba(255,204,0,.35)!important;border-color:#ffe066!important;
    box-shadow:0 0 30px rgba(255,204,0,1),0 0 60px rgba(255,204,0,.5)!important;
  }
  /* Full-screen flash when a line is completed */
  #line-flash{
    position:fixed;inset:0;z-index:9000;
    background:rgba(255,204,0,.12);
    pointer-events:none;opacity:0;
    animation:none;
  }
  #line-flash.flash{animation:flashFade .45s ease-out forwards}
  @keyframes flashFade{0%{opacity:1}100%{opacity:0}}

  /* ═══════════════════════════════════════════════
     GAME SCREEN
  ═══════════════════════════════════════════════ */
  #game-screen .card{max-width:500px}
  #game-screen .card-body{padding:12px 12px 10px}

  .score-bar{display:flex;align-items:center;justify-content:center;gap:8px;margin-bottom:8px}
  .score-chip{
    display:flex;flex-direction:column;align-items:center;
    background:var(--panel2);border:2px solid var(--edge);
    border-radius:var(--r);padding:5px 14px;min-width:52px;
  }
  .score-num{font-family:'Black Han Sans',sans-serif;font-size:30px;letter-spacing:2px;line-height:1}
  .score-num.c1{color:var(--c1)}.score-num.c2{color:var(--c2)}
  .score-lbl{font-size:8px;color:var(--ink2);letter-spacing:2px;text-transform:uppercase;margin-top:2px;font-weight:700}
  .vs-dot{font-size:12px;color:var(--ink3);letter-spacing:1px;font-weight:700}

  .players-row{display:flex;justify-content:space-between;align-items:stretch;gap:6px;margin-bottom:7px}
  .player-box{
    display:flex;align-items:center;gap:7px;
    background:var(--panel2);border:2px solid var(--edge);
    border-radius:var(--r);padding:7px 9px;flex:1;min-width:0;
    transition:border-color .18s;position:relative;overflow:hidden;
  }
  .player-box.p2{flex-direction:row-reverse;text-align:right}
  .player-box.active-turn{
    border-color:var(--c3)!important;
    box-shadow:4px 4px 0 rgba(255,204,0,.15);
  }
  .player-box::after{content:'';position:absolute;top:0;bottom:0;width:3px;background:var(--c1);opacity:0;transition:opacity .2s}
  .player-box.p1::after{left:0}.player-box.p2::after{right:0;background:var(--c2)}
  .player-box.active-turn::after{opacity:1}
  .player-avatar{font-size:17px;flex-shrink:0;width:36px;height:36px;min-width:36px;border-radius:6px;overflow:hidden}
  .player-info{flex:1;min-width:0}
  .player-label{font-size:8px;color:var(--ink2);letter-spacing:1.5px;text-transform:uppercase;font-weight:700}
  .player-name{font-size:13px;font-weight:700;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;margin-bottom:1px}
  .player-status{font-size:10px;color:var(--ink2);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:100%;font-style:italic;opacity:0;transition:opacity .3s;height:13px;line-height:13px}
  .player-status.visible{opacity:1}
  .vs-badge{font-size:11px;color:var(--ink3);flex-shrink:0;font-weight:700;letter-spacing:1px}

  #turn-indicator{
    font-family:'Black Han Sans',sans-serif;
    font-size:clamp(13px,3.5vw,18px);letter-spacing:2px;text-transform:uppercase;
    text-align:center;min-height:22px;transition:color .2s;
  }
  .action-row{display:flex;gap:6px;margin-top:8px}
  .action-row .btn{flex:1;font-size:10px;padding:9px 4px}

  /* ═══════════════════════════════════════════════
     NUMBER ANNOUNCEMENT
  ═══════════════════════════════════════════════ */
  #number-announce{display:flex!important;position:fixed;inset:0;z-index:150;align-items:center;justify-content:center;pointer-events:none}
  .announce-bubble{
    background:var(--panel);
    border:3px solid var(--c3);
    border-radius:var(--r-lg);padding:20px 44px;text-align:center;
    box-shadow:6px 6px 0 rgba(255,204,0,.25),0 24px 60px rgba(0,0,0,.7);
    transform:scale(0) translateY(12px);opacity:0;transition:none;
  }
  .announce-bubble.pop{animation:annPop .38s cubic-bezier(.2,.8,.4,1.3) forwards}
  .announce-bubble.fade-out{animation:annFade .22s ease forwards}
  @keyframes annPop{0%{transform:scale(.2) translateY(20px);opacity:0}60%{transform:scale(1.06) translateY(-3px);opacity:1}100%{transform:scale(1) translateY(0);opacity:1}}
  @keyframes annFade{0%{transform:scale(1);opacity:1}100%{transform:scale(.7) translateY(-12px);opacity:0}}
  .announce-who{font-size:9px;letter-spacing:3px;text-transform:uppercase;color:var(--c3);margin-bottom:4px;font-weight:700}
  .announce-num{font-family:'Black Han Sans',sans-serif;font-size:clamp(64px,16vw,100px);letter-spacing:4px;line-height:1;color:var(--ink)}
  .announce-sub{font-size:11px;color:var(--ink2);letter-spacing:1.5px;margin-top:4px;text-transform:uppercase}

  /* ═══════════════════════════════════════════════
     WIN OVERLAY
  ═══════════════════════════════════════════════ */
  #win-overlay{
    position:fixed;inset:0;z-index:200;
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    background:rgba(0,0,0,.88);
    opacity:0;pointer-events:none;transition:opacity .3s;padding:24px;
  }
  #win-overlay.show{opacity:1;pointer-events:all}
  .win-title{
    font-family:'Black Han Sans',sans-serif;
    font-size:clamp(72px,20vw,120px);letter-spacing:6px;line-height:1;
    color:var(--c3);
    text-shadow:6px 6px 0 rgba(255,204,0,.2);
    animation:winBounce .7s cubic-bezier(.2,.8,.4,1.3) both;text-align:center;
  }
  @keyframes winBounce{0%{transform:scale(0.3) rotate(-4deg);opacity:0}65%{transform:scale(1.08) rotate(1deg)}80%{transform:scale(.97)}100%{transform:scale(1) rotate(0);opacity:1}}
  .win-subtitle{font-size:14px;color:var(--ink2);margin-top:8px;margin-bottom:28px;letter-spacing:1.5px;text-align:center;animation:fadeUp .4s .3s both;text-transform:uppercase;font-weight:700}
  .win-buttons{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;animation:fadeUp .4s .45s both}
  /* auto-rematch countdown removed */
  #confetti-canvas{position:fixed;inset:0;pointer-events:none;z-index:199}

  /* ═══════════════════════════════════════════════
     CHAT FAB + PANEL
  ═══════════════════════════════════════════════ */
  .chat-fab{
    position:fixed;bottom:22px;right:22px;
    width:50px;height:50px;border-radius:50%;
    background:var(--c1);border:2px solid var(--c1);
    cursor:pointer;display:flex;align-items:center;justify-content:center;
    font-size:20px;z-index:100;
    box-shadow:4px 4px 0 rgba(0,255,204,.25);
    transition:transform .1s,box-shadow .1s;
    color:#000;
  }
  .chat-fab:hover{transform:translate(-2px,-2px);box-shadow:6px 6px 0 rgba(0,255,204,.3)}
  .chat-fab:active{transform:translate(2px,2px);box-shadow:2px 2px 0 rgba(0,255,204,.15)}
  .chat-badge{position:absolute;top:-3px;right:-3px;width:14px;height:14px;border-radius:50%;background:var(--c2);border:2px solid var(--bg);display:none}
  .chat-badge.show{display:block}

  .chat-panel{
    position:fixed;bottom:82px;right:20px;width:285px;
    background:var(--panel);border:2px solid var(--edge2);
    border-radius:var(--r-lg);
    box-shadow:6px 6px 0 rgba(0,0,0,.4);
    z-index:99;display:flex;flex-direction:column;overflow:hidden;
    transform:scale(.88) translateY(14px);transform-origin:bottom right;
    opacity:0;pointer-events:none;
    transition:transform .22s ease,opacity .22s ease;
    position:fixed;
  }
  .chat-panel.open{transform:scale(1) translateY(0);opacity:1;pointer-events:all}
  .chat-panel::before{
    content:'';position:absolute;top:0;left:0;right:0;height:3px;
    background:linear-gradient(90deg,var(--c1),var(--c2));
  }
  .chat-header{padding:14px 14px 9px;font-size:10px;letter-spacing:2.5px;text-transform:uppercase;color:var(--ink2);border-bottom:2px solid var(--edge);font-weight:700}
  .chat-messages{flex:1;overflow-y:auto;padding:9px 11px;display:flex;flex-direction:column;gap:6px;max-height:185px;scrollbar-width:thin;scrollbar-color:var(--edge) transparent}
  .chat-msg{display:flex;flex-direction:column;gap:2px}
  .chat-msg.mine{align-items:flex-end}
  .chat-bubble{
    display:inline-block;padding:6px 11px;border-radius:var(--r);
    font-size:13px;max-width:200px;word-break:break-word;line-height:1.5;
    background:var(--panel2);border:2px solid var(--edge);
    animation:bubblePop .16s ease;
  }
  .chat-bubble.emoji-only{font-size:24px;padding:7px 10px;animation:emojiBubblePop .28s cubic-bezier(.2,.8,.4,1.4)}
  @keyframes emojiBubblePop{0%{transform:scale(.2) rotate(-8deg);opacity:0}65%{transform:scale(1.1) rotate(2deg)}100%{transform:scale(1) rotate(0);opacity:1}}
  .chat-msg.mine .chat-bubble{background:rgba(0,255,204,.08);border-color:rgba(0,255,204,.25)}
  .chat-sender{font-size:9px;color:var(--ink3);letter-spacing:.3px;font-weight:700}
  @keyframes bubblePop{from{transform:scale(.5);opacity:0}to{transform:scale(1);opacity:1}}
  .chat-emojis{display:flex;flex-wrap:wrap;gap:4px;padding:8px 10px;border-top:2px solid var(--edge)}
  .emoji-btn{
    font-size:17px;width:35px;height:35px;border-radius:var(--r);
    background:var(--panel2);border:2px solid var(--edge);
    cursor:pointer;display:flex;align-items:center;justify-content:center;
    transition:transform .1s,border-color .1s;
  }
  .emoji-btn::before{display:none}
  .emoji-btn:hover{transform:scale(1.2) translateY(-2px);border-color:var(--c1)}
  .emoji-btn:active{transform:scale(1.05)}
  @keyframes emojiFloat{}
  .chat-input-row{display:flex;gap:5px;padding:7px 10px;border-top:2px solid var(--edge)}
  .chat-text-input{flex:1;background:var(--panel2);border:2px solid var(--edge);border-radius:var(--r);padding:7px 10px;color:var(--ink);font-family:'Space Grotesk',sans-serif;font-size:13px;outline:none;transition:border-color .12s}
  .chat-text-input:focus{border-color:var(--c1)}
  .chat-text-input::placeholder{color:var(--ink3);font-size:12px}
  .chat-send-btn{width:33px;height:33px;border-radius:var(--r);border:2px solid var(--c1);background:var(--c1);cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:13px;flex-shrink:0;transition:opacity .12s;color:#000}
  .chat-send-btn:hover{opacity:.8}

  /* ── INVITE TO GAME TOAST — improved ── */
  #game-invite-toast {
    animation: inviteSlideIn .3s cubic-bezier(.2,.8,.4,1.1) both;
  }
  @keyframes inviteSlideIn {
    from { opacity:0; transform:translateX(-50%) translateY(20px) scale(.9); }
    to   { opacity:1; transform:translateX(-50%) translateY(0) scale(1); }
  }
  /* Notification badge — supports count number */
  #friends-notif-dot {
    min-width:10px;min-height:10px;
    display:flex;align-items:center;justify-content:center;
    border-radius:10px;padding:0 2px;
    font-size:7px;line-height:1;font-weight:800;
  }

  #pwa-install-banner{
    position:fixed;bottom:0;left:0;right:0;z-index:10000;
    background:var(--panel);
    border-top:3px solid var(--c1);
    padding:16px 18px 20px;
    display:flex;align-items:center;gap:14px;
    transform:translateY(100%);
    transition:transform .4s cubic-bezier(.2,.8,.4,1);
    box-shadow:0 -6px 30px rgba(0,0,0,.5);
  }
  #pwa-install-banner.show{transform:translateY(0)}
  .pwa-icon{
    width:52px;height:52px;border-radius:12px;flex-shrink:0;
    background:linear-gradient(135deg,#0d0d0f 0%,#1c1c1f 100%);
    border:2px solid var(--c1);
    display:flex;align-items:center;justify-content:center;
    box-shadow:3px 3px 0 rgba(0,255,204,.25);
    overflow:hidden;
  }
  .pwa-icon svg{width:36px;height:36px}
  .pwa-text{flex:1;min-width:0}
  .pwa-title{font-family:'Black Han Sans',sans-serif;font-size:18px;letter-spacing:2px;color:var(--ink);line-height:1}
  .pwa-sub{font-size:10px;color:var(--ink2);letter-spacing:1.5px;text-transform:uppercase;margin-top:3px;font-weight:700}
  .pwa-actions{display:flex;flex-direction:column;gap:6px;flex-shrink:0}
  .pwa-install-btn{
    background:var(--c1);color:#000;border:none;cursor:pointer;
    font-family:'Space Grotesk',sans-serif;font-weight:800;font-size:11px;
    letter-spacing:1.5px;text-transform:uppercase;
    padding:8px 16px;border-radius:6px;
    box-shadow:3px 3px 0 rgba(0,255,204,.3);
    transition:transform .1s,box-shadow .1s;white-space:nowrap;
  }
  .pwa-install-btn:hover{transform:translate(-1px,-1px);box-shadow:4px 4px 0 rgba(0,255,204,.4)}
  .pwa-install-btn:active{transform:translate(1px,1px)}
  .pwa-dismiss-btn{
    background:none;border:none;color:var(--ink3);cursor:pointer;
    font-family:'Space Grotesk',sans-serif;font-size:10px;
    letter-spacing:1px;text-transform:uppercase;font-weight:700;
    text-align:center;padding:4px;transition:color .12s;
  }
  .pwa-dismiss-btn:hover{color:var(--ink2)}
  </style>
</head>
<body>

<!-- PWA Install Banner -->
<div id="pwa-install-banner">
  <div class="pwa-icon">
    <svg viewBox="0 0 36 36" fill="none" xmlns="http://www.w3.org/2000/svg">
      <!-- Board grid background -->
      <rect width="36" height="36" rx="8" fill="#0d0d0f"/>
      <!-- 5×5 mini grid (very small dots) -->
      <g opacity="0.3" fill="#00ffcc">
        <rect x="5" y="5" width="3" height="3" rx="1"/>
        <rect x="10" y="5" width="3" height="3" rx="1"/>
        <rect x="15" y="5" width="3" height="3" rx="1"/>
        <rect x="20" y="5" width="3" height="3" rx="1"/>
        <rect x="25" y="5" width="3" height="3" rx="1"/>
        <rect x="5" y="10" width="3" height="3" rx="1"/>
        <rect x="25" y="10" width="3" height="3" rx="1"/>
        <rect x="5" y="15" width="3" height="3" rx="1"/>
        <rect x="25" y="15" width="3" height="3" rx="1"/>
        <rect x="5" y="20" width="3" height="3" rx="1"/>
        <rect x="25" y="20" width="3" height="3" rx="1"/>
        <rect x="5" y="25" width="3" height="3" rx="1"/>
        <rect x="10" y="25" width="3" height="3" rx="1"/>
        <rect x="15" y="25" width="3" height="3" rx="1"/>
        <rect x="20" y="25" width="3" height="3" rx="1"/>
        <rect x="25" y="25" width="3" height="3" rx="1"/>
      </g>
      <!-- Diagonal win line — glowing gold -->
      <g fill="#ffcc00">
        <rect x="5" y="5" width="4" height="4" rx="1"/>
        <rect x="10.5" y="10.5" width="4" height="4" rx="1"/>
        <rect x="16" y="16" width="4" height="4" rx="1"/>
        <rect x="21.5" y="21.5" width="4" height="4" rx="1"/>
        <rect x="27" y="27" width="4" height="4" rx="1"/>
      </g>
      <!-- "Di" text top-left in neon mint -->
      <text x="7" y="16" font-family="Arial Black,sans-serif" font-size="8" font-weight="900" fill="#00ffcc" opacity="0.9">Di</text>
      <!-- "Go" text bottom-right in hot red -->
      <text x="20" y="32" font-family="Arial Black,sans-serif" font-size="8" font-weight="900" fill="#ff2d55" opacity="0.9">Go</text>
      <!-- Center lightning bolt star -->
      <text x="14" y="21" font-family="Arial,sans-serif" font-size="9" fill="#ffcc00">⚡</text>
    </svg>
  </div>
  <div class="pwa-text">
    <div class="pwa-title">DiNGo</div>
    <div class="pwa-sub">Add to Home Screen · Play Offline</div>
  </div>
  <div class="pwa-actions">
    <button class="pwa-install-btn" id="pwa-install-btn">⚡ Install</button>
    <button class="pwa-dismiss-btn" id="pwa-dismiss-btn">Not now</button>
  </div>
</div>

<div class="bg-grid"></div>
<canvas id="bg-canvas"></canvas>
<div class="particles" id="particles"></div>
<canvas id="confetti-canvas"></canvas>
<canvas id="lightning-canvas"></canvas>
<canvas id="fire-canvas"></canvas>
<canvas id="diamond-canvas"></canvas>

<!-- ── STATS POPUP ── -->
<div id="stats-popup">
  <div class="stats-card">
    <div class="stats-header">
      <div class="stats-title">MY STATS</div>
      <button class="stats-close" id="stats-close-btn">✕</button>
    </div>
    <div class="stats-body">
      <div class="stats-avatar-row">
        <div class="stats-big-avatar" id="stats-avatar">👹</div>
        <div class="stats-name-col">
          <div class="stats-player-name" id="stats-name">Player</div>
          <div><span class="stats-color-dot" id="stats-color-dot"></span><span class="stats-color-label" id="stats-color-label">Cyan</span></div>
        </div>
      </div>
      <div class="stats-grid">
        <div class="stats-cell">
          <div class="stats-cell-num" id="stat-played">0</div>
          <div class="stats-cell-lbl">Played</div>
        </div>
        <div class="stats-cell">
          <div class="stats-cell-num" id="stat-wins">0</div>
          <div class="stats-cell-lbl">Wins</div>
        </div>
        <div class="stats-cell">
          <div class="stats-cell-num" id="stat-losses">0</div>
          <div class="stats-cell-lbl">Losses</div>
        </div>
        <div class="stats-cell">
          <div class="stats-cell-num" id="stat-winrate">0%</div>
          <div class="stats-cell-lbl">Win Rate</div>
        </div>
      </div>
      <!-- Win animation picker lives here -->
      <div style="font-size:9px;letter-spacing:2px;text-transform:uppercase;font-weight:700;color:var(--ink3);margin-bottom:6px">Win Animation</div>
      <div class="win-anim-row" id="win-anim-row"></div>
      <br>
      <button class="stats-reset-btn" id="stats-reset-btn">↺ Reset Stats</button>
    </div>
  </div>
</div>

<!-- ── PLAYER CARD POPUP ── -->
<div id="player-card-popup">
  <div class="player-card" id="the-player-card">
    <div class="pc-bg">
      <div class="pc-top-bar"></div>
      <span class="pc-avatar" id="pc-avatar">👹</span>
      <div class="pc-name" id="pc-name">Player</div>
      <div class="pc-color-bar" id="pc-color-bar"></div>
      <div class="pc-badge" id="pc-badge">Arena Fighter</div>
      <hr class="pc-divider">
      <div class="pc-footer">DiNGo · Live Multiplayer Bingo</div>
      <div class="pc-actions">
        <button class="pc-btn" id="pc-close-btn">✕ Close</button>
        <button class="pc-btn primary" id="pc-share-btn">📸 Share</button>
      </div>
    </div>
  </div>
</div>

<!-- ── BOARD THEME PICKER MODAL ── -->
<div id="theme-picker-modal">
  <div class="theme-picker-card">
    <div class="theme-picker-header">
      <div class="theme-picker-title">BOARD THEME</div>
      <button class="theme-close" id="theme-modal-close">✕</button>
    </div>
    <div class="theme-grid" id="theme-grid"></div>
  </div>
</div>



<!-- ── UI Toolbar: refresh · home · theme — moves into each card via showScreen() ── -->
<div id="ui-toolbar">
  <div class="toolbar-left">
    <button id="hard-refresh-btn" title="Hard Refresh">↺</button>
    <button class="ui-pill" id="global-home-btn" style="display:none"><span class="pill-icon">🏠</span></button>
  </div>
  <div class="toolbar-right">
    <button class="ui-pill" id="music-toggle-btn" title="Music">🎵</button>
    <button class="ui-pill" id="mailbox-btn" title="Mailbox" style="position:relative">
      📬
      <span id="mailbox-badge" style="display:none;position:absolute;top:2px;right:2px;
        background:var(--c2);color:#fff;font-size:7px;font-weight:800;
        min-width:12px;height:12px;border-radius:6px;
        display:none;align-items:center;justify-content:center;padding:0 2px;
        line-height:12px;text-align:center">0</span>
    </button>
    <button class="ui-pill" id="fullscreen-btn" title="Fullscreen"><span class="pill-icon" id="fullscreen-icon">⛶</span></button>
    <button class="ui-pill" id="theme-toggle"><span class="pill-icon" id="theme-icon">🌙</span></button>
  </div>
</div>

<!-- Compact music panel - slides in below toolbar, inside card -->
<div id="music-panel" style="display:none;padding:6px 12px 4px;background:var(--panel2);border-bottom:1px solid var(--edge);align-items:center;gap:8px;flex-wrap:wrap">
  <button class="music-btn" id="music-prev-btn" style="background:none;border:none;cursor:pointer;font-size:14px;color:var(--ink2)">⏮</button>
  <button class="music-btn" id="music-play-btn" style="background:none;border:none;cursor:pointer;font-size:14px;color:var(--ink2)">▶</button>
  <button class="music-btn" id="music-next-btn" style="background:none;border:none;cursor:pointer;font-size:14px;color:var(--ink2)">⏭</button>
  <span id="music-track-name" style="font-size:9px;letter-spacing:1.5px;text-transform:uppercase;font-weight:700;color:var(--ink2);flex:1;text-align:center">No Track</span>
  <button id="music-style-btn" style="font-size:8px;letter-spacing:1px;text-transform:uppercase;font-weight:700;background:var(--panel);border:2px solid var(--edge);border-radius:10px;padding:2px 8px;cursor:pointer;color:var(--ink3)">Lofi</button>
</div>


<!-- ── MAILBOX PANEL (drops down below toolbar) ─────────────────────────── -->
<div id="mailbox-panel" style="display:none;position:relative;z-index:200;
  background:var(--panel2);border-bottom:2px solid var(--edge);
  padding:8px 12px 10px;max-height:240px;overflow-y:auto">
  <div style="font-size:9px;letter-spacing:2px;text-transform:uppercase;
    font-weight:800;color:var(--ink3);margin-bottom:6px">📬 Missed Friend Requests</div>
  <div id="mailbox-list">
    <div style="font-size:11px;color:var(--ink3);text-align:center;padding:12px 0">
      No missed requests
    </div>
  </div>
</div>

<!-- ── GAME HISTORY POPUP ───────────────────────────────────────────────── -->
<div id="history-popup" style="display:none;position:fixed;
  top:50%;left:50%;transform:translate(-50%,-50%);
  z-index:900;width:min(340px,92vw);max-height:80vh;overflow-y:auto;
  background:var(--panel);border:2px solid var(--edge2);
  border-radius:var(--r-lg);box-shadow:0 8px 40px rgba(0,0,0,.55);
  padding:16px">
  <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:12px">
    <div style="font-family:'Black Han Sans',sans-serif;font-size:16px;letter-spacing:2px">
      MATCH HISTORY
    </div>
    <button id="history-close-btn" style="background:none;border:none;cursor:pointer;
      font-size:18px;color:var(--ink3);line-height:1">✕</button>
  </div>
  <div id="history-list"></div>
</div>
<div id="history-overlay" style="display:none;position:fixed;inset:0;
  background:rgba(0,0,0,.5);z-index:895"></div>

<!-- Number Announcement -->
<div id="number-announce" style="display:none">
  <div class="announce-bubble" id="announce-bubble">
    <div class="announce-who" id="announce-who">CALLED</div>
    <div class="announce-num" id="announce-num">—</div>
    <div class="announce-sub" id="announce-sub">picks this number</div>
  </div>
</div>

<!-- Line completion flash overlay -->
<div id="line-flash"></div>

<!-- Win Overlay -->
<div id="win-overlay">
  <div class="win-title" id="win-title-text">YOU WIN!</div>
  <div class="win-subtitle" id="win-subtitle-text">Incredible performance 🎯</div>
  <div class="win-buttons">
    <button class="btn btn-gold" id="win-restart-btn">↺ &nbsp;Restart Match</button>
    <button class="btn btn-ghost" id="win-reset-btn">⏏ &nbsp;Exit</button>
  </div>
  <!-- Auto-rematch removed — players choose manually via Restart or Exit -->
</div>


<!-- SPLASH CANVAS — live animated background -->
<canvas id="splash-canvas"></canvas>

<!-- ① WELCOME / SPLASH -->
<div id="splash-screen" class="screen">
  <div class="card">
    <div class="card-body" style="padding:40px 28px 44px">

      <!-- Live badge -->
      <div class="splash-top-badge">
        <span class="badge-live-dot"></span>
        Live Multiplayer · Real-time
      </div>

      <!-- Logo + rings -->
      <div class="splash-logo-wrap">
        <div class="splash-ring ring1"></div>
        <div class="splash-ring ring2"></div>
        <div class="splash-ring ring3"></div>
        <div class="splash-ring ring4"></div>
        <span class="splash-logo">DiNGo</span>
      </div>

      <p class="splash-tagline">5 in a row · first to win</p>
      <p class="splash-game-sub">The Arena Awaits</p>

      <p class="splash-desc">
        Place your numbers. Call the shots.<br>
        <strong>First to 5 lines</strong> claims the arena.
      </p>

      <!-- Live stats row -->
      <div class="splash-stats">
        <div class="splash-stat">
          <span class="splash-stat-num">5×5</span>
          <span class="splash-stat-label">Grid</span>
        </div>
        <div class="splash-stat-divider"></div>
        <div class="splash-stat">
          <span class="splash-stat-num">3</span>
          <span class="splash-stat-label">AI Levels</span>
        </div>
        <div class="splash-stat-divider"></div>
        <div class="splash-stat">
          <span class="splash-stat-num">∞</span>
          <span class="splash-stat-label">Rematches</span>
        </div>
      </div>

      <!-- Enter button -->
      <button class="btn-splash-enter" id="enter-arena-btn">
        <span class="btn-enter-icon">⚡</span>
        Enter the Arena
      </button>

      <!-- How to Play — on the welcome screen where new players see it first -->
      <button id="htp-btn" class="btn-splash-htp">
        <span>❓</span> How to Play
      </button>

      <p class="splash-micro">No account needed · Instant play</p>

    </div>
  </div>
</div>


<!-- ② NAME ENTRY -->
<div id="name-screen" class="screen">
  <div class="card">
    <div class="card-body">
      <div class="screen-logo">DiNGo</div>
      <p class="screen-sub">Choose your identity</p>

      <p class="field-label">Pick an avatar</p>
      <div class="avatar-grid" id="avatar-row"></div>

      <p class="field-label">Pick your colour</p>
      <div class="color-strip" id="color-row"></div>

      <p class="field-label">Your name</p>
      <input type="text" id="player-name-input" maxlength="14" placeholder="e.g. Nova, Ace, Zara…" style="margin-bottom:10px"/>

      <p class="field-label">Username <span style="color:var(--ink2);font-size:10px;font-weight:500">(used by friends to find you)</span></p>
      <div style="position:relative;margin-bottom:20px">
        <span style="position:absolute;left:12px;top:50%;transform:translateY(-50%);color:var(--ink2);font-weight:700">@</span>
        <input type="text" id="username-input" maxlength="16" placeholder="e.g. nova4821" style="padding-left:26px;margin-bottom:0"/>
      </div>

      <button class="btn btn-primary btn-full" id="name-confirm-btn">→ &nbsp;Enter the Arena</button>
    </div>
  </div>
</div>

<!-- ── WELCOME BACK POPUP ── -->
<div id="welcome-back-popup" style="
  display:none;position:fixed;inset:0;z-index:950;
  background:rgba(0,0,0,.85);
  align-items:center;justify-content:center;padding:20px">
  <div style="
    background:var(--panel);border:2px solid var(--c1);border-radius:var(--r-lg);
    padding:28px 24px;max-width:320px;width:100%;text-align:center;
    box-shadow:0 0 40px rgba(0,255,204,.15)">
    <div id="wb-avatar" style="font-size:52px;margin-bottom:8px;width:64px;height:64px;margin:0 auto 12px;display:flex;align-items:center;justify-content:center"></div>
    <div style="font-family:'Black Han Sans',sans-serif;font-size:22px;letter-spacing:2px;color:var(--c1)" id="wb-greeting">WELCOME BACK</div>
    <div style="font-size:18px;font-weight:700;margin:6px 0 4px" id="wb-name">Player</div>
    <div style="font-size:12px;color:var(--ink2);margin-bottom:6px" id="wb-username">@username</div>
    <div style="font-size:11px;color:var(--ink3);margin-bottom:20px" id="wb-stats-line">0 wins · 0 games</div>
    <button class="btn btn-primary btn-full" id="wb-go-btn" style="margin-bottom:10px">⚡ Let's Play!</button>
    <button class="btn btn-ghost btn-full" id="wb-edit-btn" style="font-size:11px">✏️ Edit Profile</button>
  </div>
</div>


<!-- ③ HOME / LOBBY — Hardware Aesthetic v4 -->
<div id="home-screen" class="screen">
  <div class="card" style="max-width:480px">

    <!-- Animated grid background -->
    <div class="home-grid-bg">
      <canvas class="home-grid-canvas" id="home-grid-canvas"></canvas>
    </div>
    <!-- Hardware scan lines -->
    <div class="scanlines"></div>

    <div class="card-body" style="position:relative;z-index:3">

      <!-- ① PROFILE STRIP -->
      <div class="home-profile-strip">
        <div class="home-avatar-wrap">
          <div class="home-avatar" id="home-avatar-display">👹</div>
          <div class="home-rank-badge" id="home-rank-badge">ARENA</div>
        </div>
        <div class="home-profile-info">
          <div class="home-username" id="home-username-display">Player</div>
          <div class="home-rank-label" id="home-rank-label-el">⚡ Ready to dominate</div>
        </div>
        <div class="home-profile-nodes">
          <div class="node-dot"></div>
          <div class="node-dot"></div>
          <div class="node-dot"></div>
          <button id="show-card-btn">🪪 Card</button>
        </div>
      </div>

      <!-- ② EVENT BANNERS CAROUSEL -->
      <div class="home-banners" id="home-banners">
        <div class="banner-slide banner-rush active">
          <div class="banner-icon">⚡</div>
          <div class="banner-text">
            <div class="banner-title" style="color:var(--gold)">Weekend Rush: Double Points</div>
            <div class="banner-sub">Diagonal wins count double this weekend!</div>
          </div>
        </div>
        <div class="banner-slide banner-event">
          <div class="banner-icon">🎯</div>
          <div class="banner-text">
            <div class="banner-title" style="color:var(--cyan)">Clutch Mode Unlocked</div>
            <div class="banner-sub">Win 3 in a row to earn the Clutch title</div>
          </div>
        </div>
        <div class="banner-slide banner-skin">
          <div class="banner-icon">💎</div>
          <div class="banner-text">
            <div class="banner-title" style="color:var(--pink)">New Neon Board Skin</div>
            <div class="banner-sub">Unlock it in the Store — limited time!</div>
          </div>
        </div>
        <div class="banner-dots">
          <div class="banner-dot active" data-idx="0"></div>
          <div class="banner-dot" data-idx="1"></div>
          <div class="banner-dot" data-idx="2"></div>
        </div>
      </div>

      <!-- ④ GLOBAL LOBBY CHAT -->
      <div class="home-lobby-chat">
        <div class="lobby-chat-header">
          <span class="lobby-chat-label">
            <span class="lobby-live-dot"></span>
            Global Lobby
          </span>
          <span id="online-count-pill" class="online-pill zero">
            <span class="online-dot"></span>
            <span id="online-count-num">—</span> Online
          </span>
        </div>
        <div class="lobby-messages" id="lobby-messages">
          <div class="lobby-msg">
            <span class="lobby-msg-avatar">👾</span>
            <span class="lobby-msg-name">Nova:</span>
            <span class="lobby-msg-text">anyone up for a match? 🔥</span>
          </div>
          <div class="lobby-msg">
            <span class="lobby-msg-avatar">🦊</span>
            <span class="lobby-msg-name">Ace:</span>
            <span class="lobby-msg-text">5 lines or bust 😤</span>
          </div>
          <div class="lobby-msg">
            <span class="lobby-msg-avatar">🐉</span>
            <span class="lobby-msg-name">Zara:</span>
            <span class="lobby-msg-text">gg everyone good luck today!</span>
          </div>
        </div>
      </div>

      <!-- ⑤ ACTION ZONE -->
      <div class="home-action-zone">
        <!-- PLAY NOW mega button (auto-match) -->
        <button class="btn-play-now" id="play-now-btn">
          <span class="play-now-icon">⚡</span>
          <span>PLAY NOW</span>
          <span id="play-now-online" style="font-size:10px;font-family:'Space Grotesk',sans-serif;font-weight:600;letter-spacing:1px;opacity:0.7;margin-left:4px"></span>
        </button>

        <!-- VS BOT button -->
        <button class="btn-vs-bot" id="vs-bot-btn">
          <span class="bot-icon">🤖</span>
          Play vs AI Bot
        </button>

        <!-- Private match row -->
        <div class="home-private-row">
          <button id="create-btn" class="btn btn-ghost">＋ Create Room</button>
          <button id="join-btn-toggle" class="btn btn-ghost">🔗 Join with Code</button>
        </div>
        <!-- Tournament row -->
        <div class="home-private-row" style="margin-top:4px">
          <button id="tournament-btn" class="btn btn-ghost" style="flex:1;border-color:rgba(255,204,0,.3);color:var(--c3)">🏆 Tournament</button>
          <button id="friends-btn" class="btn btn-ghost" style="flex:1;border-color:rgba(0,229,255,.3);color:var(--c5);position:relative">
            👥 Friends
            <span id="friends-notif-dot" style="display:none;position:absolute;top:6px;right:8px;width:8px;height:8px;background:var(--c2);border-radius:50%"></span>
          </button>
        </div>

        <!-- History row -->
        <div class="home-private-row" style="margin-top:4px">
          <button id="history-btn" class="btn btn-ghost" style="flex:1;border-color:rgba(150,200,255,.3);color:var(--ink2)">📋 Match History</button>
        </div>

        <!-- Join row (hidden by default) -->
        <div class="join-row" id="join-row" style="display:none;margin-top:8px">
          <input id="room-code-input" type="text" maxlength="4" placeholder="Room code e.g. A3K9"/>
          <button id="join-btn" class="btn btn-primary">Join</button>
        </div>

      </div>

      <p id="home-msg"></p>

      <!-- Firebase connection status -->
      <div id="firebase-status" style="display:none;text-align:center;font-size:11px;letter-spacing:1px;padding:8px 12px;border-radius:10px;margin-top:8px;font-weight:600"></div>

      <!-- Firebase rules help (shown on permission error) -->
      <div id="firebase-rules-help" style="display:none;margin-top:10px;background:rgba(255,209,102,0.08);border:1px solid rgba(255,209,102,0.25);border-radius:12px;padding:12px 14px;font-size:11px;line-height:1.7;color:var(--text2)">
        <div style="color:var(--gold);font-weight:800;letter-spacing:1px;margin-bottom:6px">🔧 FIX: Firebase Rules</div>
        Go to <strong style="color:var(--cyan)">Firebase Console → Realtime Database → Rules</strong> and paste:<br>
        <code style="display:block;margin-top:6px;padding:8px;background:rgba(0,0,0,0.3);border-radius:8px;color:var(--green);font-size:10px;letter-spacing:.3px">{ "rules": { ".read": true, ".write": true } }</code>
        <span style="color:var(--muted);font-size:10px">⚠️ For development only — add auth rules for production</span>
      </div>
    </div>
  </div>
</div>


<!-- ④ SETUP -->
<!-- ── FRIENDS SCREEN ── -->
<div id="friends-screen" class="screen">
  <div class="card">
    <div class="card-body">
      <div style="display:flex;align-items:center;gap:10px;margin-bottom:18px">
        <div style="font-family:'Black Han Sans',sans-serif;font-size:22px;letter-spacing:2px;flex:1">FRIENDS</div>
        <button class="btn btn-ghost" id="friends-back-btn" style="font-size:11px">← Back</button>
      </div>

      <!-- My shareable username -->
      <div style="background:var(--panel2);border:2px solid var(--edge2);border-radius:var(--r);padding:12px 14px;margin-bottom:16px">
        <div style="font-size:10px;color:var(--ink2);letter-spacing:1.5px;text-transform:uppercase;margin-bottom:4px">Your Username</div>
        <div style="display:flex;align-items:center;gap:8px">
          <div style="font-size:18px;font-weight:800;color:var(--c1);flex:1" id="my-username-display">@—</div>
          <button class="btn btn-ghost" id="copy-username-btn" style="font-size:10px;padding:4px 10px">📋 Copy</button>
        </div>
        <div style="font-size:10px;color:var(--ink3);margin-top:4px">Share this with friends so they can add you</div>
      </div>

      <!-- Add friend input -->
      <div style="display:flex;gap:6px;margin-bottom:16px">
        <input type="text" id="add-friend-input" maxlength="16" placeholder="@username" style="flex:1;margin-bottom:0"/>
        <button class="btn btn-primary" id="add-friend-btn" style="white-space:nowrap;padding:0 14px">＋ Add</button>
      </div>
      <div id="add-friend-msg" style="font-size:11px;min-height:14px;margin-bottom:10px;text-align:center;color:var(--c2)"></div>

      <!-- Friends list -->
      <div style="font-size:10px;color:var(--ink2);letter-spacing:1.5px;text-transform:uppercase;margin-bottom:8px">
        Friends <span id="friends-count" style="color:var(--ink3)">(0)</span>
      </div>
      <div id="friends-list" style="display:flex;flex-direction:column;gap:6px;min-height:60px">
        <div style="text-align:center;color:var(--ink3);font-size:12px;padding:20px 0" id="friends-empty">
          No friends yet. Add someone by their @username!
        </div>
      </div>

    </div>
  </div>
</div>

<!-- ── FRIEND REQUEST NOTIFICATION ── -->
<div id="friend-req-toast" style="
  display:none;position:fixed;bottom:80px;left:50%;transform:translateX(-50%);
  z-index:800;background:var(--panel);border:2px solid var(--c1);
  border-radius:var(--r-lg);padding:12px 16px;min-width:240px;
  box-shadow:0 4px 20px rgba(0,0,0,.4);text-align:center">
  <div style="font-size:11px;color:var(--ink2);margin-bottom:6px" id="freq-text">Friend request from @someone</div>
  <div style="display:flex;gap:6px;justify-content:center">
    <button class="btn btn-primary" id="freq-accept-btn" style="font-size:11px;padding:5px 14px">✓ Accept</button>
    <button class="btn btn-ghost" id="freq-decline-btn" style="font-size:11px;padding:5px 14px">✕ Decline</button>
  </div>
</div>

<!-- ── INVITE TO GAME TOAST ── -->
<div id="game-invite-toast" style="
  display:none;position:fixed;bottom:80px;left:50%;transform:translateX(-50%);
  z-index:800;background:var(--panel);border:2px solid var(--c3);
  border-radius:var(--r-lg);padding:12px 16px;min-width:240px;
  box-shadow:0 4px 20px rgba(0,0,0,.4);text-align:center">
  <div style="font-size:11px;color:var(--ink2);margin-bottom:6px" id="ginv-text">🎮 @someone invited you to play!</div>
  <div style="display:flex;gap:6px;justify-content:center">
    <button class="btn btn-gold" id="ginv-accept-btn" style="font-size:11px;padding:5px 14px">⚡ Join Game</button>
    <button class="btn btn-ghost" id="ginv-decline-btn" style="font-size:11px;padding:5px 14px">✕ Decline</button>
  </div>
</div>

<!-- ══════════════════════════════════════════
     TOURNAMENT SCREEN
══════════════════════════════════════════ -->
<div id="tournament-screen" class="screen">
  <div class="card">
    <div class="card-body">
      <div style="text-align:center;margin-bottom:4px">
        <span class="tourn-badge">🏆 Tournament Mode</span>
        <div class="screen-logo" style="font-size:28px;margin-bottom:2px">4-PLAYER BRACKET</div>
        <p class="screen-sub" id="tourn-sub">Create or join a tournament</p>
      </div>

      <!-- Host view -->
      <div id="tourn-host-view" style="display:none">
        <div style="font-size:9px;letter-spacing:2px;text-transform:uppercase;font-weight:700;color:var(--ink3);margin-bottom:4px;text-align:center">Share this code</div>
        <div class="tourn-code-display" id="tourn-code-display">----</div>
        <div class="tourn-slots" id="tourn-slots"></div>
        <div class="tourn-status-bar" id="tourn-status-bar">Waiting for players…</div>
        <button class="btn btn-gold" id="tourn-start-btn" disabled style="width:100%">⚡ Start Tournament</button>
        <button class="btn btn-ghost" id="tourn-cancel-btn" style="width:100%;margin-top:6px">✕ Cancel</button>
      </div>

      <!-- Join view -->
      <div id="tourn-join-view" style="display:none">
        <input type="text" id="tourn-join-input" maxlength="4"
          style="width:100%;text-align:center;font-family:'Black Han Sans',sans-serif;font-size:32px;letter-spacing:8px;
                 background:var(--panel2);border:2px solid var(--edge);border-radius:var(--r);
                 color:var(--c3);padding:12px;margin-bottom:10px;text-transform:uppercase"
          placeholder="CODE"/>
        <button class="btn btn-gold" id="tourn-join-confirm-btn" style="width:100%">🔗 Join Tournament</button>
        <button class="btn btn-ghost" id="tourn-join-cancel-btn" style="width:100%;margin-top:6px">✕ Back</button>
      </div>

      <!-- Bracket view (shown when tournament is running) -->
      <div id="tourn-bracket-view" style="display:none">
        <div class="tourn-bracket" id="tourn-bracket"></div>
        <div class="tourn-status-bar" id="tourn-bracket-status">Match in progress…</div>
        <button class="btn btn-gold" id="tourn-play-match-btn" style="width:100%;display:none">⚡ Play My Match</button>
        <button class="btn btn-ghost" id="tourn-leave-btn" style="width:100%;margin-top:6px">⏏ Leave Tournament</button>
      </div>

      <!-- Initial choice -->
      <div id="tourn-choice-view">
        <div style="display:flex;gap:8px;margin-top:8px">
          <button class="btn btn-gold" id="tourn-host-btn" style="flex:1">＋ Host</button>
          <button class="btn btn-ghost" id="tourn-join-btn" style="flex:1">🔗 Join</button>
        </div>
        <button class="btn btn-ghost" id="tourn-back-btn" style="width:100%;margin-top:8px">← Back</button>
      </div>

    </div>
  </div>
</div>

<div id="setup-screen" class="screen">
  <div class="card">
    <div class="card-body">
      <div class="room-badge">
        <div>
          <div class="room-badge-label">Room Code</div>
          <div class="room-badge-code" id="display-room-code">——</div>
          <div class="waiting-dots">
            <span class="dot"></span><span class="dot"></span><span class="dot"></span>
            <span id="waiting-label">Waiting for opponent</span>
          </div>
        </div>
      </div>
      <div class="section-title">Arrange Your Board</div>
      <p class="section-sub">Tap cells to place 1→25 in any order, or shuffle randomly.</p>
      <div class="progress-bar"><div class="progress-fill" id="setup-progress"></div></div>
      <div class="setup-actions">
        <button class="btn btn-ghost" id="home-from-setup">🏠 Home</button>
        <button class="btn btn-ghost" id="shuffle-btn">🔀 Random</button>
        <button class="btn btn-ghost" id="clear-btn">✕ Clear</button>
      </div>
      <div class="board-wrap"><div class="board" id="setup-board"></div></div>
      <button id="ready-btn" class="btn btn-pink btn-full" disabled>✓ &nbsp;I'm Ready!</button>
    </div>
  </div>
</div>


<!-- ⑤ GAME -->
<div id="game-screen" class="screen">
  <div class="card">
    <div class="card-body">

      <!-- Score bar — labels are set dynamically from real player names -->
      <div class="score-bar">
        <div class="score-chip">
          <div class="score-num c1" id="score-p1">0</div>
          <div class="score-lbl" id="score-lbl-p1">—</div>
        </div>
        <div style="display:flex;flex-direction:column;align-items:center;gap:4px">
          <div class="vs-dot">:</div>
          <span class="ai-mode-pill" id="ai-mode-pill">AI</span>
        </div>
        <div class="score-chip">
          <div class="score-num c2" id="score-p2">0</div>
          <div class="score-lbl" id="score-lbl-p2">—</div>
        </div>
      </div>

      <!-- Player boxes with live status message -->
      <div class="players-row">
        <div class="player-box p1" id="p1-box">
          <div class="player-avatar-wrap">
            <span class="player-avatar" id="p1-avatar">🎮</span>
            <div id="lifelines-p1" class="lifelines-chips inline">
              <span class="lifeline-chip" data-n="1">❤️</span>
              <span class="lifeline-chip" data-n="2">❤️</span>
              <span class="lifeline-chip" data-n="3">❤️</span>
            </div>
          </div>
          <div class="player-info">
            <div class="player-label">Player 1</div>
            <div class="player-name" id="p1-name">—</div>
            <div class="player-status" id="p1-status"></div>
          </div>
        </div>
        <div class="vs-badge">VS</div>
        <div class="player-box p2" id="p2-box">
          <div class="player-avatar-wrap">
            <span class="player-avatar" id="p2-avatar">🕹️</span>
            <div id="lifelines-p2" class="lifelines-chips inline">
              <span class="lifeline-chip" data-n="1">❤️</span>
              <span class="lifeline-chip" data-n="2">❤️</span>
              <span class="lifeline-chip" data-n="3">❤️</span>
            </div>
          </div>
          <div class="player-info" style="text-align:right">
            <div class="player-label">Player 2</div>
            <div class="player-name" id="p2-name">—</div>
            <div class="player-status" id="p2-status"></div>
          </div>
        </div>
      </div>

      <div style="display:flex;align-items:center;justify-content:center;gap:8px;margin-bottom:7px">
        <div id="turn-indicator" style="margin-bottom:0">Loading…</div>
        <button id="theme-picker-btn">🎨</button>
      </div>

      <!-- ── MOVE TIMER BAR ── -->
      <div id="move-timer-wrap">
        <div id="move-timer-bar-track">
          <div id="move-timer-bar-fill"></div>
        </div>
        <div id="move-timer-secs">25</div>
      </div>

      <div id="ai-thinking-bar">
        <span class="think-dot"></span><span class="think-dot"></span><span class="think-dot"></span>
        AI is thinking…
      </div>

      <div class="board-wrap">
        <div class="board" id="game-board"></div>
      </div>

      <div class="action-row">
        <button class="btn btn-ghost" id="home-from-game">🏠 Home</button>
        <button class="btn btn-gold" id="restart-btn">↺ Restart</button>
        <button class="btn btn-ghost" id="reset-btn">⏏ Exit</button>
      </div>
    </div>
  </div>
</div>


<!-- ── HOW TO PLAY MODAL ── -->
<div id="htp-modal">
  <div class="htp-card">
    <div class="htp-header">
      <div class="htp-title">HOW TO PLAY</div>
      <button class="htp-close" id="htp-close-btn">✕</button>
    </div>
    <div class="htp-body">

      <div class="htp-step">
        <div class="htp-step-num">1</div>
        <div class="htp-step-text">
          <strong>Build your board.</strong> You get a blank 5×5 grid. Tap cells to fill them with numbers 1–25 in any order you like, or hit <strong>Random</strong> to shuffle instantly. Your arrangement is your secret weapon.
        </div>
      </div>

      <div class="htp-step">
        <div class="htp-step-num">2</div>
        <div class="htp-step-text">
          <strong>Take turns calling numbers.</strong> Each player picks one uncalled number per turn. When a number is called, every player who has it on their board crosses it out automatically.
        </div>
      </div>

      <div class="htp-step">
        <div class="htp-step-num">3</div>
        <div class="htp-step-text">
          <strong>Complete 5 in a row to score a line.</strong> A line can run horizontally, vertically, or diagonally — any direction counts. Watch all three directions!
          <!-- Mini demo board -->
          <div class="htp-win-demo" id="htp-demo-board"></div>
          <span class="htp-tag gold">Row ✓</span>
          <span class="htp-tag gold" style="margin-left:4px">Column ✓</span>
          <span class="htp-tag gold" style="margin-left:4px">Diagonal ✓</span>
        </div>
      </div>

      <div class="htp-step">
        <div class="htp-step-num">4</div>
        <div class="htp-step-text">
          <strong>First to 5 lines wins the match.</strong> Every completed line glows gold on your board. Stack lines fast — your opponent is racing you.
          <br><span class="htp-tag green" style="margin-top:6px">5 Lines = WIN</span>
        </div>
      </div>

      <div class="htp-step">
        <div class="htp-step-num">5</div>
        <div class="htp-step-text">
          <strong>Strategy tip:</strong> Numbers near the center of your board belong to more lines (rows + columns + both diagonals), so placing small, easy-to-call numbers in the center gives you the fastest path to 5 lines.
          <br><span class="htp-tag red" style="margin-top:6px">Center = More Lines</span>
        </div>
      </div>

      <div class="htp-step">
        <div class="htp-step-num">6</div>
        <div class="htp-step-text">
          <strong>Hard Refresh button <span style="display:inline-flex;align-items:center;justify-content:center;width:20px;height:20px;border-radius:4px;background:rgba(255,255,255,0.08);border:1.5px solid rgba(255,255,255,0.18);font-size:13px;vertical-align:middle;margin:0 2px">↺</span></strong> — visible at the top-left on every screen. Tap it any time the game feels stuck, a connection drops, or you want a completely fresh start. It unregisters the service worker cache and reloads everything from scratch — faster than closing and reopening the tab.
          <br><span class="htp-tag green" style="margin-top:6px">↺ Top-left corner — always there</span>
        </div>
      </div>

    </div>
  </div>
</div>

<!-- ── OPPONENT LEFT POPUP — shows only when opponent clicks Exit, only in game screen, auto-closes 5s ── -->
<div id="opponent-left-popup">
  <div class="opp-left-icon">🏃</div>
  <div class="opp-left-body">
    <div class="opp-left-title">Opponent Left!</div>
    <div class="opp-left-sub">Your opponent has exited the game.</div>
  </div>
  <div class="opp-left-close-wrap">
    <div class="opp-left-timer-ring">
      <svg viewBox="0 0 36 36" class="opp-left-ring-svg">
        <circle cx="18" cy="18" r="15.9" fill="none" stroke="var(--edge2)" stroke-width="2.5"/>
        <circle cx="18" cy="18" r="15.9" fill="none" stroke="var(--c2)" stroke-width="2.5"
          stroke-dasharray="100 100" stroke-dashoffset="0"
          id="opp-ring-progress" stroke-linecap="round"/>
      </svg>
      <span id="opp-left-secs">5</span>
    </div>
  </div>
</div>

<!-- ── ABANDON BANNER (kept for legacy graceful-leave win logic, but now hidden visually) ── -->
<div id="abandon-banner" style="display:none">
  <span class="abandon-icon">🏃</span>
  <div class="abandon-text">Opponent left! You win in <strong id="abandon-timer">60</strong>s</div>
</div>

<!-- AI DIFFICULTY SELECTION MODAL -->
<div id="ai-difficulty-modal">
  <div class="diff-card">
    <div class="diff-title">VS AI BOT</div>
    <p class="diff-sub">Choose your opponent's difficulty</p>

    <div class="diff-option" data-level="easy">
      <span class="diff-emoji">🎲</span>
      <div class="diff-info">
        <div class="diff-name" style="color:var(--green)">Easy</div>
        <div class="diff-desc">Plays randomly. Great for learning the ropes.</div>
      </div>
      <span class="diff-badge badge-easy">CHILL</span>
    </div>

    <div class="diff-option" data-level="medium">
      <span class="diff-emoji">🛡️</span>
      <div class="diff-info">
        <div class="diff-name" style="color:var(--gold)">Medium</div>
        <div class="diff-desc">Blocks your wins and builds its own lines.</div>
      </div>
      <span class="diff-badge badge-medium">FAIR</span>
    </div>

    <div class="diff-option" data-level="hard">
      <span class="diff-emoji">🧠</span>
      <div class="diff-info">
        <div class="diff-name" style="color:var(--pink)">Hard</div>
        <div class="diff-desc">Heuristic scoring — hunts traps and defends well.</div>
      </div>
      <span class="diff-badge badge-hard">PRO</span>
    </div>

    <div class="diff-option" data-level="expert">
      <span class="diff-emoji">⚔️</span>
      <div class="diff-info">
        <div class="diff-name" style="color:#a78bfa">Expert</div>
        <div class="diff-desc">Creates double-threat forks. Blocks all 2+ line threats simultaneously.</div>
      </div>
      <span class="diff-badge badge-expert">ELITE</span>
    </div>

    <div class="diff-option" data-level="nightmare">
      <span class="diff-emoji">💀</span>
      <div class="diff-info">
        <div class="diff-name" style="color:#ff4444">Nightmare</div>
        <div class="diff-desc">Near-perfect AI. Calculates every threat. Almost unbeatable.</div>
      </div>
      <span class="diff-badge badge-nightmare">⚠ INSANE</span>
    </div>

    <button class="diff-cancel" id="diff-cancel-btn">✕ Cancel</button>
  </div>
</div>


<!-- CHAT FAB + PANEL -->
<button class="chat-fab" id="chat-fab" style="display:none;">
  💬
  <div class="chat-badge" id="chat-badge"></div>
</button>
<div class="chat-panel" id="chat-panel">
  <div class="chat-header">💬 &nbsp;Chat</div>
  <div class="chat-messages" id="chat-messages"></div>
  <div class="chat-emojis" id="chat-emojis"></div>
  <div class="chat-input-row">
    <input type="text" class="chat-text-input" id="chat-text-input" placeholder="Type a message…" maxlength="80"/>
    <button class="chat-send-btn" id="chat-send-btn">➤</button>
  </div>
</div>


<!-- ═══════════════════════════════════════════════
     PLAIN SCRIPT — instant UI, no Firebase dependency
═══════════════════════════════════════════════ -->
<script>
/* ── Screen transitions ───────────────────────────────────────── */
function showScreen(name) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  const screen = document.getElementById(name + '-screen');
  if (!screen) return;
  screen.classList.add('active');

  // Move toolbar + music panel into the top of this card
  const toolbar = document.getElementById('ui-toolbar');
  const musicPanel = document.getElementById('music-panel');
  const card = screen.querySelector('.card');
  if (toolbar && card) {
    card.insertBefore(toolbar, card.firstChild);
    if (musicPanel) card.insertBefore(musicPanel, card.children[1] || card.firstChild.nextSibling);
  }

  // Hide the home button when already on home/splash
  document.getElementById('global-home-btn').style.display =
    (name === 'splash' || name === 'home') ? 'none' : 'flex';
}

// Place the toolbar in the initial splash card right away
showScreen('splash');

/* ── Theme toggle ─────────────────────────────────────────────── */
let isLight = false;
document.getElementById('theme-toggle').addEventListener('click', () => {
  isLight = !isLight;
  document.body.classList.toggle('light', isLight);
  document.getElementById('theme-icon').textContent  = isLight ? '☀️' : '🌙';
});

/* ── Hard Refresh — forces full reload bypassing cache ── */
document.getElementById('hard-refresh-btn').addEventListener('click', () => {
  window.location.reload(true);
});

/* ── Global home pill ─────────────────────────────────────────── */
document.getElementById('global-home-btn').addEventListener('click', () => {
  winShown = false; lastLineCount = 0; cleanupScheduled = false; botWinShown = false;
  detachRoomListeners();
  leaveRoomCleanup();
  showScreen('home');
  document.getElementById('chat-fab').style.display = 'none';
  document.getElementById('chat-panel').classList.remove('open');
  document.getElementById('win-overlay').classList.remove('show');
});

/* ── In-card home buttons ─────────────────────────────────────── */
document.getElementById('home-from-setup').addEventListener('click', () => {
  leaveRoomCleanup();
  showScreen('home');
  document.getElementById('chat-fab').style.display = 'none';
  document.getElementById('chat-panel').classList.remove('open');
});
/* home-from-game is handled in the Firebase module with bot-mode support */

/* ── Enter arena ──────────────────────────────────────────────── */
document.getElementById('enter-arena-btn').addEventListener('click', () => {
  const saved = loadProfile();
  if (saved) {
    showWelcomeBack(saved);
  } else {
    showScreen('name');
  }
});

/* ══════════════════════════════════════════════════════════════
   PHASE 1+2 — PERSISTENT PROFILE
══════════════════════════════════════════════════════════════ */

const PROFILE_KEY = 'dingo_profile';

function loadProfile() {
  try { return JSON.parse(localStorage.getItem(PROFILE_KEY)) || null; }
  catch(e) { return null; }
}

function saveProfile(data) {
  localStorage.setItem(PROFILE_KEY, JSON.stringify(data));
}

function applyProfile(p) {
  window.DINGO.playerName    = p.name;
  window.DINGO.selectedAvatar= p.avatar;
  window.DINGO.selectedColor = p.color;
  window.DINGO.username      = p.username;
  applyAccentColor(p.color);
}

/* Generate suggested @username from display name */
function suggestUsername(name) {
  const base = (name || 'player').toLowerCase().replace(/[^a-z0-9]/g,'');
  const num  = Math.floor(1000 + Math.random()*8999);
  return (base || 'player') + num;
}

/* Welcome back popup */
function showWelcomeBack(profile) {
  applyProfile(profile);
  const s = loadStats();
  renderAvatar(document.getElementById('wb-avatar'), profile.avatar);
  document.getElementById('wb-name').textContent     = profile.name;
  document.getElementById('wb-username').textContent = '@' + (profile.username || '—');
  document.getElementById('wb-stats-line').textContent = `${s.wins} wins · ${s.played} games`;
  const popup = document.getElementById('welcome-back-popup');
  popup.style.display = 'flex';
}

document.getElementById('wb-go-btn').addEventListener('click', () => {
  document.getElementById('welcome-back-popup').style.display = 'none';
  showScreen('home');
  refreshHomeProfile();
  if (typeof registerUserPresence === 'function') registerUserPresence();
});

document.getElementById('wb-edit-btn').addEventListener('click', () => {
  document.getElementById('welcome-back-popup').style.display = 'none';
  prefillNameScreen(loadProfile());
  showScreen('name');
});

/* Pre-fill name screen with saved data */
function prefillNameScreen(profile) {
  if (!profile) return;
  // Select matching avatar by id first, then fall back to svg string comparison
  let matched = false;
  document.querySelectorAll('.avatar-opt').forEach(el => {
    const isMatch = (el.dataset.avatarId && el.dataset.avatarId === profile.avatarId)
                 || el.innerHTML === profile.avatar;
    el.classList.toggle('selected', isMatch);
    if (isMatch) {
      window.DINGO.selectedAvatar   = profile.avatar;
      window.DINGO.selectedAvatarId = profile.avatarId || el.dataset.avatarId;
      matched = true;
    }
  });
  // If no match (e.g. old emoji profile), default to first avatar
  if (!matched && AVATAR_DEFS.length) {
    document.querySelectorAll('.avatar-opt')[0]?.classList.add('selected');
    window.DINGO.selectedAvatar   = AVATAR_DEFS[0].svg;
    window.DINGO.selectedAvatarId = AVATAR_DEFS[0].id;
  }
  // Select matching colour
  document.querySelectorAll('.color-swatch').forEach((sw, i) => {
    if (COLORS[i] && COLORS[i].val === profile.color) {
      document.querySelectorAll('.color-swatch').forEach(x => x.classList.remove('selected'));
      sw.classList.add('selected');
      applyAccentColor(profile.color);
    }
  });
  document.getElementById('player-name-input').value  = profile.name     || '';
  document.getElementById('username-input').value     = profile.username  || '';
}

/* Auto-suggest username when name is typed */
document.getElementById('player-name-input').addEventListener('input', () => {
  const unInput = document.getElementById('username-input');
  if (!unInput.value || unInput.dataset.autoSuggested === 'true') {
    unInput.value = suggestUsername(document.getElementById('player-name-input').value);
    unInput.dataset.autoSuggested = 'true';
  }
});
document.getElementById('username-input').addEventListener('input', () => {
  // Once user manually edits, stop auto-suggesting
  document.getElementById('username-input').dataset.autoSuggested = 'false';
  // Sanitise: lowercase, alphanumeric only
  const el = document.getElementById('username-input');
  el.value = el.value.toLowerCase().replace(/[^a-z0-9_]/g, '');
});






/* ── Shared player data (read by Firebase module script) ─────── */
/* DINGO shared state — selectedAvatar is set after AVATAR_DEFS are declared below */
window.DINGO = { selectedAvatar:'', selectedAvatarId:'', selectedColor:'#00e5ff', playerName:'Player' };

/* ══════════════════════════════════════════
   HOME SCREEN — Hardware UI upgrades
══════════════════════════════════════════ */

/* Update profile strip when entering home */
function refreshHomeProfile() {
  const p = loadProfile();
  if (p) applyProfile(p);
  const d = window.DINGO;
  renderAvatar(document.getElementById('home-avatar-display'), d.selectedAvatar || AVATAR_DEFS[0].svg);
  document.getElementById('home-username-display').textContent = d.playerName || 'Player';
  const ranks = ['ARENA','CLUTCH','ELITE','BEAST','LEGEND'];
  const s = (typeof loadStats === 'function') ? loadStats() : {wins:0};
  const rank = s.wins >= 50 ? 'MASTER' : s.wins >= 20 ? 'LEGEND' : s.wins >= 10 ? 'ELITE' : s.wins >= 3 ? 'CLUTCH' : 'ARENA';
  document.getElementById('home-rank-badge').textContent = rank;
  // Show @username under name if available
  const unEl = document.getElementById('home-rank-label-el');
  if (unEl) unEl.textContent = d.username ? '@' + d.username : '⚡ Ready to dominate';
}



let homeGridCleanup = null; function initHomeGrid(){return null;}

/* Banner carousel */
(function initBanners() {
  const slides = document.querySelectorAll('.banner-slide');
  const dots   = document.querySelectorAll('.banner-dot');
  let cur = 0;
  function go(i) {
    slides[cur].classList.remove('active');
    dots[cur].classList.remove('active');
    cur = (i + slides.length) % slides.length;
    slides[cur].classList.add('active');
    dots[cur].classList.add('active');
  }
  setInterval(() => go(cur + 1), 3500);
  dots.forEach(d => d.addEventListener('click', () => go(+d.dataset.idx)));
})();

/* Join toggle */
document.getElementById('join-btn-toggle').addEventListener('click', () => {
  const row = document.getElementById('join-row');
  const visible = row.style.display !== 'none';
  row.style.display = visible ? 'none' : 'flex';
  if (!visible) document.getElementById('room-code-input').focus();
});

/* ── How to Play modal ─────────────────────────── */
(function initHTP() {
  // Build the mini demo board: a 5×5 showing a diagonal win line
  const demo = document.getElementById('htp-demo-board');
  // Layout: indices 0,6,12,18,24 are the diagonal win line; some others are crossed
  const crossed  = new Set([1,5,7,10,15,20]);
  const winLine  = new Set([0,6,12,18,24]);
  const nums = [7,14,3,19,5, 23,8,2,11,21, 16,25,6,17,9, 4,12,22,13,24, 18,1,15,20,10];
  nums.forEach((n, i) => {
    const cell = document.createElement('div');
    cell.className = 'htp-cell' + (winLine.has(i) ? ' win' : crossed.has(i) ? ' cx' : '');
    cell.textContent = n;
    demo.appendChild(cell);
  });

  const modal   = document.getElementById('htp-modal');
  const openBtn = document.getElementById('htp-btn');
  const closeBtn= document.getElementById('htp-close-btn');

  openBtn.addEventListener('click', () => {
    modal.classList.add('show');
    if (navigator.vibrate) navigator.vibrate(20);
  });
  closeBtn.addEventListener('click', () => modal.classList.remove('show'));
  modal.addEventListener('click', e => { if (e.target === modal) modal.classList.remove('show'); });
})();

/* ── VS Bot button — opens difficulty modal ───── */
document.getElementById('vs-bot-btn').addEventListener('click', () => {
  if (navigator.vibrate) navigator.vibrate(30);
  document.getElementById('ai-difficulty-modal').classList.add('show');
});
document.getElementById('diff-cancel-btn').addEventListener('click', () => {
  document.getElementById('ai-difficulty-modal').classList.remove('show');
});
// Difficulty selection — dispatches a custom event picked up by the Firebase module
document.querySelectorAll('.diff-option').forEach(opt => {
  opt.addEventListener('click', () => {
    const level = opt.dataset.level;
    if (navigator.vibrate) navigator.vibrate([30, 10, 30]);
    document.getElementById('ai-difficulty-modal').classList.remove('show');
    document.dispatchEvent(new CustomEvent('startBotGame', { detail: { level } }));
  });
});

/* Haptic on create / play now */
function haptic(pattern) { if (navigator.vibrate) navigator.vibrate(pattern); }

/* Hook: run home setup whenever home screen is shown */
const _baseShowScreen = showScreen;
window.showScreen = function(name) {
  _baseShowScreen(name);
  if (name === 'home') {
    refreshHomeProfile();
    rotateLobbyMessages();
  }
};

/* Lobby chat placeholder messages */
const LOBBY_FAKE = [
  {a:'👹',n:'Ryze',t:'anyone wanna get destroyed? 😈'},
  {a:'🦊',n:'Nova',t:'just hit 5 lines on my first game!!'},
  {a:'🤖',n:'XR7',t:'looking for a match 🎯'},
  {a:'🐉',n:'Zara',t:'this game is so addictive omg'},
  {a:'💎',n:'Prism',t:'gg wp last round, good luck all'},
  {a:'⚡',n:'Bolt',t:'5 lines let\'s goooo 🔥'},
  {a:'🌙',n:'Luna',t:'anyone else play daily puzzles?'},
  {a:'🎯',n:'Ace',t:'room code: A3K9 — join me!'},
];
function rotateLobbyMessages() {
  const container = document.getElementById('lobby-messages');
  if (!container) return;
  container.innerHTML = '';
  const pool = [...LOBBY_FAKE].sort(() => Math.random()-.5).slice(0,3);
  pool.forEach(({a,n,t}) => {
    const div = document.createElement('div');
    div.className = 'lobby-msg';
    div.innerHTML = `<span class="lobby-msg-avatar">${a}</span><span class="lobby-msg-name">${n}:</span><span class="lobby-msg-text">${t}</span>`;
    container.appendChild(div);
  });
  document.getElementById('lobby-chat-count') && (document.getElementById('lobby-chat-count').textContent = '');
}

/* ══════════════════════════════════════════════════════════
   DYNAMIC SVG AVATARS — 12 unique character faces
   Each avatar stores: id (for matching), svg (full markup),
   label (display name). DINGO.selectedAvatar holds the svg.
══════════════════════════════════════════════════════════ */
const AVATAR_DEFS = [
  { id:'ninja', label:'Ninja', svg:`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><circle cx="20" cy="20" r="19" fill="#12132a"/><circle cx="20" cy="20" r="19" fill="url(#ng)" opacity="0.4"/><defs><radialGradient id="ng" cx="30%" cy="25%"><stop offset="0%" stop-color="#3a3a7a"/><stop offset="100%" stop-color="#12132a"/></radialGradient></defs><rect x="5" y="17" width="30" height="7" rx="3.5" fill="#e63946"/><rect x="5" y="17" width="30" height="2.5" rx="1.5" fill="#ff6b6b"/><circle cx="14" cy="13.5" r="3.2" fill="white"/><circle cx="26" cy="13.5" r="3.2" fill="white"/><circle cx="15" cy="13.5" r="1.8" fill="#12132a"/><circle cx="27" cy="13.5" r="1.8" fill="#12132a"/><circle cx="15.6" cy="12.8" r="0.7" fill="white"/><circle cx="27.6" cy="12.8" r="0.7" fill="white"/><path d="M8 9 Q14 5 20 8 Q26 5 32 9" stroke="#e63946" stroke-width="2" fill="none" stroke-linecap="round"/></svg>` },
  { id:'dragon', label:'Dragon', svg:`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><defs><radialGradient id="dg" cx="35%" cy="30%"><stop offset="0%" stop-color="#4dd9e0"/><stop offset="100%" stop-color="#0a6a70"/></radialGradient></defs><circle cx="20" cy="20" r="19" fill="url(#dg)"/><ellipse cx="10" cy="9" rx="5" ry="7" rx="5" fill="#0a6a70" transform="rotate(-25,10,9)"/><ellipse cx="30" cy="9" rx="5" ry="7" fill="#0a6a70" transform="rotate(25,30,9)"/><ellipse cx="10" cy="8" rx="3" ry="4.5" fill="#4dd9e0" opacity="0.5" transform="rotate(-25,10,8)"/><ellipse cx="30" cy="8" rx="3" ry="4.5" fill="#4dd9e0" opacity="0.5" transform="rotate(25,30,8)"/><ellipse cx="14" cy="19" rx="5" ry="3.5" fill="#072e30"/><ellipse cx="26" cy="19" rx="5" ry="3.5" fill="#072e30"/><ellipse cx="14" cy="19" rx="2" ry="3" fill="#ffe066"/><ellipse cx="26" cy="19" rx="2" ry="3" fill="#ffe066"/><path d="M14 27 Q20 31 26 27" stroke="#072e30" stroke-width="1.5" fill="none" stroke-linecap="round"/><circle cx="14" cy="24" r="1" fill="#072e30"/><circle cx="26" cy="24" r="1" fill="#072e30"/></svg>` },
  { id:'fox', label:'Fox', svg:`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><defs><radialGradient id="fg" cx="40%" cy="30%"><stop offset="0%" stop-color="#ff9f43"/><stop offset="100%" stop-color="#d35400"/></radialGradient></defs><circle cx="20" cy="22" r="17" fill="url(#fg)"/><polygon points="6,8 14,20 2,18" fill="#d35400"/><polygon points="34,8 26,20 38,18" fill="#d35400"/><polygon points="7,7 13,18 4,17" fill="#ff9f43" opacity="0.7"/><polygon points="33,7 27,18 36,17" fill="#ff9f43" opacity="0.7"/><ellipse cx="20" cy="26" rx="10" ry="7" fill="#fff0e6"/><circle cx="14.5" cy="20" r="3.5" fill="white"/><circle cx="25.5" cy="20" r="3.5" fill="white"/><circle cx="15.2" cy="20" r="2" fill="#2c2c54"/><circle cx="26.2" cy="20" r="2" fill="#2c2c54"/><circle cx="15.8" cy="19.3" r="0.8" fill="white"/><circle cx="26.8" cy="19.3" r="0.8" fill="white"/><ellipse cx="20" cy="25" rx="2.5" ry="1.5" fill="#e17055"/><path d="M16 28 Q20 31 24 28" stroke="#d35400" stroke-width="1.5" fill="none" stroke-linecap="round"/></svg>` },
  { id:'robot', label:'Robot', svg:`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><defs><linearGradient id="rg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#8395a7"/><stop offset="100%" stop-color="#4a6075"/></linearGradient></defs><rect x="2" y="8" width="36" height="30" rx="6" fill="url(#rg)"/><rect x="2" y="8" width="36" height="30" rx="6" fill="none" stroke="#00ffcc" stroke-width="1.5" opacity="0.6"/><rect x="16" y="2" width="8" height="8" rx="2" fill="#4a6075"/><circle cx="20" cy="6" r="2" fill="#00ffcc"/><rect x="7" y="15" width="11" height="8" rx="3" fill="#0a0a0a"/><rect x="22" y="15" width="11" height="8" rx="3" fill="#0a0a0a"/><rect x="9" y="17" width="7" height="4" rx="1" fill="#00ffcc" opacity="0.9"/><rect x="24" y="17" width="7" height="4" rx="1" fill="#00ffcc" opacity="0.9"/><rect x="11" y="26" width="18" height="5" rx="2" fill="#0a0a0a"/><rect x="13" y="27.5" width="14" height="2" rx="1" fill="#ff2d55" opacity="0.8"/><circle cx="8" cy="22" r="2" fill="#00ffcc" opacity="0.5"/><circle cx="32" cy="22" r="2" fill="#00ffcc" opacity="0.5"/></svg>` },
  { id:'phoenix', label:'Phoenix', svg:`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><defs><radialGradient id="pg" cx="50%" cy="60%"><stop offset="0%" stop-color="#e17055"/><stop offset="100%" stop-color="#c0392b"/></radialGradient></defs><circle cx="20" cy="22" r="17" fill="url(#pg)"/><path d="M14 4 Q16 10 14 14 Q10 8 14 4Z" fill="#ffe066"/><path d="M20 2 Q22 9 20 13 Q18 9 20 2Z" fill="#ffa502"/><path d="M26 4 Q24 10 26 14 Q30 8 26 4Z" fill="#ffe066"/><path d="M10 6 Q13 12 11 16 Q8 10 10 6Z" fill="#ff7675" opacity="0.8"/><path d="M30 6 Q27 12 29 16 Q32 10 30 6Z" fill="#ff7675" opacity="0.8"/><circle cx="15" cy="21" r="3.5" fill="#2d0a00"/><circle cx="25" cy="21" r="3.5" fill="#2d0a00"/><circle cx="15" cy="21" r="2" fill="#ffe066"/><circle cx="25" cy="21" r="2" fill="#ffe066"/><circle cx="15.5" cy="20.5" r="0.8" fill="#2d0a00"/><circle cx="25.5" cy="20.5" r="0.8" fill="#2d0a00"/><path d="M14 28 Q20 33 26 28" stroke="#2d0a00" stroke-width="1.8" fill="none" stroke-linecap="round"/></svg>` },
  { id:'ghost', label:'Ghost', svg:`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><defs><radialGradient id="gg" cx="40%" cy="30%"><stop offset="0%" stop-color="#dfe6ff"/><stop offset="100%" stop-color="#a29bfe"/></radialGradient></defs><path d="M6 38 Q6 10 20 6 Q34 10 34 38 Q30 33 26 38 Q23 33 20 38 Q17 33 14 38 Q10 33 6 38Z" fill="url(#gg)"/><circle cx="15" cy="21" r="4" fill="#2d3436"/><circle cx="25" cy="21" r="4" fill="#2d3436"/><circle cx="16" cy="20" r="2" fill="white"/><circle cx="26" cy="20" r="2" fill="white"/><ellipse cx="20" cy="30" rx="4" ry="2.5" fill="#a29bfe" opacity="0.5"/><path d="M15 32 Q20 36 25 32" stroke="#6c5ce7" stroke-width="1.5" fill="none" stroke-linecap="round"/></svg>` },
  { id:'warrior', label:'Warrior', svg:`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><defs><radialGradient id="wg" cx="35%" cy="30%"><stop offset="0%" stop-color="#e55c5c"/><stop offset="100%" stop-color="#8b0000"/></radialGradient></defs><circle cx="20" cy="20" r="19" fill="url(#wg)"/><path d="M8 5 Q12 2 20 3 Q28 2 32 5 L30 14 Q20 10 10 14Z" fill="#8b0000"/><path d="M8 5 Q12 2 20 3 Q28 2 32 5 L30 12 Q20 9 10 12Z" fill="#c0392b"/><path d="M5 13 L9 11 L10 19 L6 18Z" fill="#c0392b"/><path d="M35 13 L31 11 L30 19 L34 18Z" fill="#c0392b"/><ellipse cx="20" cy="26" rx="11" ry="9" fill="#c0392b"/><circle cx="14" cy="22" r="3.5" fill="#1a0000"/><circle cx="26" cy="22" r="3.5" fill="#1a0000"/><circle cx="14" cy="22" r="2" fill="#e55c5c" opacity="0.9"/><circle cx="26" cy="22" r="2" fill="#e55c5c" opacity="0.9"/><path d="M18 22 L20 24 L22 22" stroke="#1a0000" stroke-width="1.5" fill="none"/><line x1="10" y1="20" x2="13" y2="25" stroke="#ffe066" stroke-width="1.5"/><path d="M14 30 Q20 34 26 30" stroke="#1a0000" stroke-width="1.8" fill="none" stroke-linecap="round"/></svg>` },
  { id:'mage', label:'Mage', svg:`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><defs><radialGradient id="mg" cx="40%" cy="35%"><stop offset="0%" stop-color="#a29bfe"/><stop offset="100%" stop-color="#4a0080"/></radialGradient></defs><circle cx="20" cy="20" r="19" fill="url(#mg)"/><path d="M6 12 Q13 0 20 4 Q27 0 34 12 L32 20 Q20 15 8 20Z" fill="#4a0080"/><path d="M6 12 Q13 0 20 4 Q27 0 34 12 L32 17 Q20 13 8 17Z" fill="#6c3db5"/><text x="20" y="13" text-anchor="middle" font-size="8" fill="#ffe066">✦</text><circle cx="14" cy="21" r="3.5" fill="#1a003a"/><circle cx="26" cy="21" r="3.5" fill="#1a003a"/><circle cx="14" cy="21" r="2.2" fill="#a29bfe"/><circle cx="26" cy="21" r="2.2" fill="#a29bfe"/><circle cx="14.5" cy="20.5" r="0.8" fill="white"/><circle cx="26.5" cy="20.5" r="0.8" fill="white"/><path d="M16 28 Q20 32 24 28" stroke="#1a003a" stroke-width="1.8" fill="none" stroke-linecap="round"/><text x="20" y="35" text-anchor="middle" font-size="5" fill="#ffe066" opacity="0.7">✧ ✧ ✧</text></svg>` },
  { id:'hunter', label:'Hunter', svg:`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><defs><radialGradient id="hg" cx="40%" cy="30%"><stop offset="0%" stop-color="#55efc4"/><stop offset="100%" stop-color="#00695c"/></radialGradient></defs><circle cx="20" cy="20" r="19" fill="url(#hg)"/><path d="M5 10 Q10 2 20 4 Q30 2 35 10 L34 18 Q20 12 6 18Z" fill="#00695c"/><path d="M5 10 Q10 2 20 4 Q30 2 35 10 L34 15 Q20 10 6 15Z" fill="#00897b"/><circle cx="14" cy="21" r="3.5" fill="#002a20"/><circle cx="26" cy="21" r="3.5" fill="#002a20"/><circle cx="14" cy="21" r="2" fill="#55efc4" opacity="0.8"/><circle cx="26" cy="21" r="2" fill="#55efc4" opacity="0.8"/><circle cx="14.5" cy="20.5" r="0.7" fill="#002a20"/><circle cx="26.5" cy="20.5" r="0.7" fill="#002a20"/><path d="M15 28 Q20 32 25 28" stroke="#002a20" stroke-width="1.8" fill="none" stroke-linecap="round"/><line x1="12" y1="22" x2="16" y2="17" stroke="#ffe066" stroke-width="1.2" stroke-linecap="round"/><line x1="28" y1="22" x2="24" y2="17" stroke="#ffe066" stroke-width="1.2" stroke-linecap="round"/></svg>` },
  { id:'crystal', label:'Crystal', svg:`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><defs><radialGradient id="cg" cx="40%" cy="35%"><stop offset="0%" stop-color="#81ecec"/><stop offset="100%" stop-color="#0984e3"/></radialGradient></defs><circle cx="20" cy="20" r="19" fill="url(#cg)"/><polygon points="20,2 26,12 34,10 28,18" fill="white" opacity="0.3"/><polygon points="20,2 14,12 6,10 12,18" fill="white" opacity="0.2"/><circle cx="14.5" cy="20" r="3.5" fill="#004a7c"/><circle cx="25.5" cy="20" r="3.5" fill="#004a7c"/><circle cx="14.5" cy="20" r="2" fill="#81ecec"/><circle cx="25.5" cy="20" r="2" fill="#81ecec"/><circle cx="15" cy="19.5" r="0.8" fill="white"/><circle cx="26" cy="19.5" r="0.8" fill="white"/><path d="M15 27 Q20 31 25 27" stroke="#004a7c" stroke-width="1.8" fill="none" stroke-linecap="round"/><polygon points="20,14 22,17 25,17 23,19 24,22 20,20 16,22 17,19 15,17 18,17" fill="white" opacity="0.4"/></svg>` },
  { id:'shadow', label:'Shadow', svg:`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><defs><radialGradient id="sg" cx="50%" cy="50%"><stop offset="0%" stop-color="#2d3436"/><stop offset="100%" stop-color="#0a0a0a"/></radialGradient></defs><circle cx="20" cy="20" r="19" fill="url(#sg)"/><circle cx="14" cy="20" r="4" fill="#1a0000"/><circle cx="26" cy="20" r="4" fill="#1a0000"/><circle cx="14" cy="20" r="2.5" fill="#ff2d55"/><circle cx="26" cy="20" r="2.5" fill="#ff2d55"/><circle cx="14.8" cy="19.5" r="1" fill="#ff6b6b"/><circle cx="26.8" cy="19.5" r="1" fill="#ff6b6b"/><path d="M14 27 Q20 30 26 27" stroke="#ff2d55" stroke-width="1.5" fill="none" stroke-linecap="round"/><path d="M5 20 Q8 12 20 10 Q32 12 35 20" stroke="#2d3436" stroke-width="3" fill="none" opacity="0.7"/><path d="M3 15 Q10 5 20 7 Q30 5 37 15" stroke="#1a1a1a" stroke-width="4" fill="none"/></svg>` },
  { id:'bolt', label:'Bolt', svg:`<svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"><defs><radialGradient id="bg2" cx="40%" cy="30%"><stop offset="0%" stop-color="#ffe066"/><stop offset="100%" stop-color="#e67e00"/></radialGradient></defs><circle cx="20" cy="20" r="19" fill="url(#bg2)"/><path d="M22 4 L12 20 L19 20 L17 36 L28 18 L21 18Z" fill="white" opacity="0.9"/><path d="M22 4 L12 20 L19 20 L17 36 L28 18 L21 18Z" fill="#e67e00" opacity="0.3"/><circle cx="14" cy="23" r="3" fill="#7d3c00"/><circle cx="26" cy="23" r="3" fill="#7d3c00"/><circle cx="14.5" cy="22.5" r="1.5" fill="#ffe066"/><circle cx="26.5" cy="22.5" r="1.5" fill="#ffe066"/><path d="M15 30 Q20 34 25 30" stroke="#7d3c00" stroke-width="1.8" fill="none" stroke-linecap="round"/></svg>` }
];
/* Keep a flat array of SVG strings for compatibility with indices */
const AVATARS = AVATAR_DEFS.map(d => d.svg);

/* Helper: render avatar safely in any element (supports SVG or emoji fallback) */
function renderAvatar(el, avatarStr) {
  if (!el) return;
  if (!avatarStr) { el.textContent = '👤'; return; }
  // SVG strings start with '<svg'; emoji/text fallback uses textContent
  if (avatarStr.trim().startsWith('<svg')) {
    el.innerHTML = avatarStr;
  } else {
    el.textContent = avatarStr;
  }
}
const COLORS  = [
  /* ── Neons ── */
  {val:'#00e5ff',label:'Cyan'},
  {val:'#00ffcc',label:'Mint'},
  {val:'#06ffa5',label:'Green'},
  {val:'#7b61ff',label:'Violet'},
  {val:'#ff3cac',label:'Pink'},
  {val:'#ff2d55',label:'Red'},
  {val:'#ff6b35',label:'Orange'},
  {val:'#ffd166',label:'Gold'},
  /* ── Pastels ── */
  {val:'#b5eaff',label:'Sky'},
  {val:'#c3fbd8',label:'Mint Pastel'},
  {val:'#ffc8dd',label:'Rose'},
  {val:'#ffd6a5',label:'Peach'},
  {val:'#caffbf',label:'Lime'},
  {val:'#bde0fe',label:'Periwinkle'},
  {val:'#e8c8ff',label:'Lavender'},
  {val:'#fffacd',label:'Cream'},
  /* ── Light ── */
  {val:'#ffffff',label:'White'},
  {val:'#f0e6ff',label:'Ghost'},
  {val:'#e0f7fa',label:'Ice'},
  {val:'#fff0f3',label:'Blush'},
];

/* Render avatar grid — SVG avatars, each tagged with data-avatar-id for matching */
const avatarRow = document.getElementById('avatar-row');
AVATAR_DEFS.forEach((def, i) => {
  const el = document.createElement('div');
  el.className = 'avatar-opt' + (i === 0 ? ' selected' : '');
  el.dataset.avatarId = def.id;                // for reliable matching in prefill
  el.innerHTML = def.svg;                      // render SVG (not textContent)
  el.title = def.label;
  el.addEventListener('click', () => {
    document.querySelectorAll('.avatar-opt').forEach(x => x.classList.remove('selected'));
    el.classList.add('selected');
    window.DINGO.selectedAvatar    = def.svg;   // store SVG string
    window.DINGO.selectedAvatarId  = def.id;    // store id for matching
  });
  avatarRow.appendChild(el);
});
// Apply the first avatar as default immediately
window.DINGO.selectedAvatar   = AVATAR_DEFS[0].svg;
window.DINGO.selectedAvatarId = AVATAR_DEFS[0].id;

/* ── applyAccentColor: swaps --c1 on :root so every element that uses var(--c1) updates instantly ── */
function applyAccentColor(hex) {
  document.documentElement.style.setProperty('--c1', hex);
  // Also patch the rgba variants used in inline backgrounds / borders throughout the CSS.
  // We decompose the hex into r,g,b so the rest of the hardcoded rgba(0,255,204,…) rules
  // stay visually consistent. We store these as CSS custom properties too.
  const r = parseInt(hex.slice(1,3),16);
  const g = parseInt(hex.slice(3,5),16);
  const b = parseInt(hex.slice(5,7),16);
  document.documentElement.style.setProperty('--c1-r', r);
  document.documentElement.style.setProperty('--c1-g', g);
  document.documentElement.style.setProperty('--c1-b', b);
  // Patch the splash badge live-dot, home live-dot, and progress bar which reference --c1 directly — already covered.
  // Update avatar-opt selected border, setup cell border, etc. — those already use var(--c1).
  // Save to DINGO so Firebase module can read it
  window.DINGO.selectedColor = hex;
}

/* Render colour swatches */
const colorRow = document.getElementById('color-row');
COLORS.forEach((c, i) => {
  const sw = document.createElement('div');
  sw.className = 'color-swatch' + (i === 0 ? ' selected' : '');
  sw.style.background = c.val;
  sw.title = c.label;
  sw.addEventListener('click', () => {
    document.querySelectorAll('.color-swatch').forEach(x => x.classList.remove('selected'));
    sw.classList.add('selected');
    applyAccentColor(c.val);   // ← live-update the whole site accent
  });
  colorRow.appendChild(sw);
});
// Apply default accent colour (first swatch = Cyan) on page load
applyAccentColor(COLORS[0].val);

/* Continue to lobby — save full profile */
document.getElementById('name-confirm-btn').addEventListener('click', () => {
  const name     = document.getElementById('player-name-input').value.trim() || 'Player';
  let   username = document.getElementById('username-input').value.trim().toLowerCase().replace(/[^a-z0-9_]/g,'');
  if (!username) username = suggestUsername(name);

  window.DINGO.playerName     = name;
  window.DINGO.username       = username;

  const profile = {
    name,
    username,
    avatar: window.DINGO.selectedAvatar || AVATAR_DEFS[0].svg,
    avatarId: window.DINGO.selectedAvatarId || AVATAR_DEFS[0].id,
    color:  window.DINGO.selectedColor  || '#00e5ff',
    token:  localStorage.getItem('dingo_token') || Math.random().toString(36).slice(2),
  };
  localStorage.setItem('dingo_token', profile.token);
  saveProfile(profile);

  showScreen('home');
  if (typeof refreshHomeProfile === 'function') refreshHomeProfile();
  if (typeof registerUserPresence === 'function') registerUserPresence();
});
document.getElementById('player-name-input').addEventListener('keydown', e => {
  if (e.key === 'Enter') document.getElementById('name-confirm-btn').click();
});
</script>


<!-- ═══════════════════════════════════════════════
     FIREBASE MODULE SCRIPT — all game logic
═══════════════════════════════════════════════ -->
<script>
const app = firebase.initializeApp({
  apiKey:            "AIzaSyAhhGzyMUJrfzYsOw4Uy-qu6F_IOqrh3PA",
  authDomain:        "dingo-v2-0.firebaseapp.com",
  databaseURL:       "https://dingo-v2-0-default-rtdb.firebaseio.com",
  projectId:         "dingo-v2-0",
  storageBucket:     "dingo-v2-0.firebasestorage.app",
  messagingSenderId: "908358383631",
  appId:             "1:908358383631:web:09473d12f079a230134b7a",
  measurementId:     "G-MFTX32JEDJ"
});
const db = firebase.database();

/* helper shims so the rest of the code works unchanged */
/* Fix: the codebase uses the modular SDK signature ref(db, 'path'),
   so we detect which style is being used and handle both.
   When called as ref(db, 'rooms/foo'), dbOrPath is the DB object
   and path is the string we actually want. When called as ref('rooms/foo'),
   dbOrPath is already the string path. */
function ref(dbOrPath, path)    { return db.ref(path !== undefined ? path : dbOrPath); }
function get(r)                 { return r.get(); }
function set(r, v)              { return r.set(v); }
function update(r, v)           { return r.update(v); }
function onValue(r, cb)         { r.on('value', cb); }
function push(r, v)             { return r.push(v); }

/* ── Room-scoped listener registry — call detachRoomListeners() on exit ── */
let _roomListeners = []; // [{ref, cb}]
function onRoomValue(r, cb) { r.on('value', cb); _roomListeners.push({ref: r, cb}); }
function detachRoomListeners() {
  _roomListeners.forEach(({ref: r, cb}) => { try { r.off('value', cb); } catch(e){} });
  _roomListeners = [];
}

/* ── Firebase connection health check ─────────── */
function setFirebaseStatus(ok, msg) {
  const el = document.getElementById('firebase-status');
  if (!el) return;
  el.style.display = 'block';
  el.textContent   = msg;
  if (ok) {
    el.style.background = 'rgba(6,255,165,0.1)';
    el.style.border     = '1px solid rgba(6,255,165,0.3)';
    el.style.color      = '#06ffa5';
    setTimeout(() => { el.style.display = 'none'; }, 3000);
  } else {
    el.style.background = 'rgba(255,60,172,0.12)';
    el.style.border     = '1px solid rgba(255,60,172,0.4)';
    el.style.color      = '#ff3cac';
  }
}

// Test Firebase connection using .info/connected
onValue(ref(db, '.info/connected'), snap => {
  if (snap.val() === true) {
    setFirebaseStatus(true, '✅ Connected to server');
  } else {
    setFirebaseStatus(false, '⚠️ Not connected — check your internet');
  }
});

/* ═══════════════════════════════════════════════
   REAL-TIME ONLINE COUNTER  v2
   ── Each browser tab gets its own node:
        presence/sessions/<sessionId>  = true
   ── Firebase onDisconnect removes it automatically
      even on refresh, tab-close, or lost internet.
   ── Count = number of nodes under sessions/.
   ── Free-tier safe: tiny nodes, auto-cleaned.
═══════════════════════════════════════════════ */
(function initOnlineCounter() {

  /* Unique ID for THIS tab/session — regenerated on every page load
     so a refresh is always treated as a fresh session */
  const sessionId  = Math.random().toString(36).slice(2, 10);
  const sessionRef = db.ref('presence/sessions/' + sessionId);
  const allRef     = db.ref('presence/sessions');
  const connRef    = db.ref('.info/connected');

  function updateUI(n) {
    const num  = Math.max(0, n || 0);
    const pill = document.getElementById('online-count-pill');
    const numEl= document.getElementById('online-count-num');
    const btnEl= document.getElementById('play-now-online');
    if (numEl) numEl.textContent = num;
    if (pill)  pill.classList.toggle('zero', num === 0);
    if (btnEl) btnEl.textContent = num > 1 ? `· ${num} online` : '';
  }

  /* Count child nodes = number of active sessions */
  allRef.on('value', snap => {
    const count = snap.exists() ? Object.keys(snap.val() || {}).length : 0;
    updateUI(count);
  });

  /* When connected: register this session and schedule auto-remove on disconnect */
  connRef.on('value', snap => {
    if (!snap.val()) return;
    /* onDisconnect must be set BEFORE the write — Firebase guarantee */
    sessionRef.onDisconnect().remove();
    sessionRef.set(true);
  });

})();

/* ── Game state ───────────────────────────────── */
let myPlayerId   = (localStorage.getItem('dingo_device_id') || (() => { const id = Math.random().toString(36).substring(2,9); localStorage.setItem('dingo_device_id', id); return id; })());
let roomId       = "";
let playerRole   = "";
let myBoard      = [];
let setupCounter = 1;
let chatOpen     = false;
let winShown     = false;
let countdownInterval = null;
let scores = { p1:0, p2:0 };
/* Player identity — read fresh from window.DINGO at create/join time */
let playerName   = 'Player';
let playerAvatar = AVATAR_DEFS[0].svg;
let playerColor  = '#00e5ff';

/* ═══════════════════════════════════════════════
   SOUND ENGINE
═══════════════════════════════════════════════ */
let audioCtx = null;
function getAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}
function playTone(notes, type='sine', vol=0.18) {
  try {
    const ctx = getAudio();
    notes.forEach(([freq,start,dur]) => {
      const osc=ctx.createOscillator(), gain=ctx.createGain();
      osc.type=type;
      osc.frequency.setValueAtTime(freq, ctx.currentTime+start);
      gain.gain.setValueAtTime(vol, ctx.currentTime+start);
      gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+start+dur);
      osc.connect(gain); gain.connect(ctx.destination);
      osc.start(ctx.currentTime+start);
      osc.stop(ctx.currentTime+start+dur+0.05);
    });
  } catch(e) {}
}
const sfx = {
  click:    ()=>playTone([[880,0,0.08]],'sine',0.12),
  cross:    ()=>playTone([[300,0,0.06],[200,0.04,0.1]],'triangle',0.2),
  win:      ()=>playTone([[523,0,.12],[659,.1,.12],[784,.2,.12],[1047,.3,.3],[1319,.45,.5]],'sine',0.22),
  lose:     ()=>playTone([[392,0,.12],[349,.12,.12],[294,.24,.25]],'triangle',0.18),
  ping:     ()=>playTone([[1200,0,.07],[900,.07,.12]],'sine',0.1),
  announce: ()=>playTone([[660,0,.06],[880,.06,.12]],'sine',0.15),
};

/* ═══════════════════════════════════════════════
   AI BOT ENGINE — runs entirely locally, no Firebase
═══════════════════════════════════════════════ */

// ── Shared bot game state ──
let botMode       = false;   // true when playing vs AI
let botLevel      = 'easy';  // 'easy' | 'medium' | 'hard'
let botBoard      = [];      // AI's 5×5 board layout (numbers 1-25)
let playerBotBoard= [];      // Player's 5×5 board layout
let botSelected   = [];      // numbers called so far in bot game
let botScores     = {player:0, bot:0};
let botWinShown   = false;
let botCountdownInterval = null;
const BOT_AVATARS = {easy:'🎲', medium:'🛡️', hard:'🧠', expert:'⚔️', nightmare:'💀'};
const BOT_NAMES   = {easy:'ChillBot', medium:'DefendBot', hard:'ProBot', expert:'EliteBot', nightmare:'NightmareAI'};

/* ── Generate a random shuffled board ── */
function genRandomBoard() {
  const nums = Array.from({length:25}, (_,i) => i+1);
  for (let i = nums.length-1; i > 0; i--) {
    const j = Math.floor(Math.random()*(i+1));
    [nums[i],nums[j]] = [nums[j],nums[i]];
  }
  return nums;
}

/* ─── Check win lines for a board & selected set ─── */
function botCheckLines(board, selected) {
  const hits = board.map(n => selected.includes(n) ? 1 : 0);
  let lines = 0; const winIdx = new Set();
  for (let r=0;r<5;r++){const b=r*5,row=[b,b+1,b+2,b+3,b+4];if(row.every(i=>hits[i])){row.forEach(i=>winIdx.add(i));lines++}}
  for (let c=0;c<5;c++){const col=[c,c+5,c+10,c+15,c+20];if(col.every(i=>hits[i])){col.forEach(i=>winIdx.add(i));lines++}}
  [[0,6,12,18,24],[4,8,12,16,20]].forEach(d=>{if(d.every(i=>hits[i])){d.forEach(i=>winIdx.add(i));lines++}});
  return { lines, winIdx };
}

/* ─── Count consecutive pieces in a line ─── */
function countLine(board, selected, indices) {
  return indices.filter(i => selected.includes(board[i])).length;
}
function isLineOpen(board, selected, indices) {
  // True if the line has no opponent pieces blocking (all cells are either selected or empty)
  return indices.every(i => selected.includes(board[i]) || !selected.includes(board[i]));
}

/* ═══════════════════════════════════════════════
   AI MOVE CALCULATORS
═══════════════════════════════════════════════ */

/* LEVEL 1 — Easy: pure random */
function aiMoveEasy(calledNums) {
  const available = Array.from({length:25}, (_,i)=>i+1).filter(n=>!calledNums.includes(n));
  return available[Math.floor(Math.random()*available.length)];
}

/* LEVEL 2 — Medium: Win > Block > Random near pieces */
function aiMoveMedium(calledNums, playerBoard, botBrd) {
  const ALL_LINES = [];
  for(let r=0;r<5;r++){const b=r*5;ALL_LINES.push([b,b+1,b+2,b+3,b+4])}
  for(let c=0;c<5;c++){ALL_LINES.push([c,c+5,c+10,c+15,c+20])}
  ALL_LINES.push([0,6,12,18,24],[4,8,12,16,20]);

  const available = Array.from({length:25},(_,i)=>i+1).filter(n=>!calledNums.includes(n));

  // Rule 1: Win — find a number that completes 5 on bot's board
  for (const line of ALL_LINES) {
    const vals = line.map(i => botBrd[i]);
    const uncalled = vals.filter(v => !calledNums.includes(v));
    const called   = vals.filter(v => calledNums.includes(v));
    if (called.length === 4 && uncalled.length === 1 && available.includes(uncalled[0])) {
      return uncalled[0];
    }
  }

  // Rule 2: Block — find a number that completes 5 on player's board (4-in-a-row threat)
  for (const line of ALL_LINES) {
    const vals = line.map(i => playerBoard[i]);
    const uncalled = vals.filter(v => !calledNums.includes(v));
    const called   = vals.filter(v => calledNums.includes(v));
    if (called.length === 4 && uncalled.length === 1 && available.includes(uncalled[0])) {
      return uncalled[0];
    }
  }
  // Also block open-ended 3-in-a-row on player board
  for (const line of ALL_LINES) {
    const vals = line.map(i => playerBoard[i]);
    const uncalled = vals.filter(v => !calledNums.includes(v));
    const called   = vals.filter(v => calledNums.includes(v));
    if (called.length === 3 && uncalled.length === 2) {
      const pick = uncalled.find(v => available.includes(v));
      if (pick) return pick;
    }
  }

  // Rule 3: Random near existing called pieces
  const adjacentNums = new Set();
  calledNums.forEach(n => {
    const idx = botBrd.indexOf(n);
    if (idx === -1) return;
    const r = Math.floor(idx/5), c = idx%5;
    [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]].forEach(([dr,dc]) => {
      const nr=r+dr, nc=c+dc;
      if(nr>=0&&nr<5&&nc>=0&&nc<5) adjacentNums.add(botBrd[nr*5+nc]);
    });
  });
  const nearPicks = available.filter(n => adjacentNums.has(n));
  if (nearPicks.length > 0) return nearPicks[Math.floor(Math.random()*nearPicks.length)];

  // Fallback: random
  return aiMoveEasy(calledNums);
}

/* LEVEL 3 — Hard: Heuristic scoring matrix */
function aiMoveHard(calledNums, playerBoard, botBrd) {
  const ALL_LINES = [];
  for(let r=0;r<5;r++){const b=r*5;ALL_LINES.push([b,b+1,b+2,b+3,b+4])}
  for(let c=0;c<5;c++){ALL_LINES.push([c,c+5,c+10,c+15,c+20])}
  ALL_LINES.push([0,6,12,18,24],[4,8,12,16,20]);

  const available = Array.from({length:25},(_,i)=>i+1).filter(n=>!calledNums.includes(n));
  if (!available.length) return null;

  const scores = {};
  available.forEach(n => { scores[n] = 0; });

  // Score each available number
  available.forEach(num => {
    // Center bonus: numbers near center of player's board have higher value
    const playerIdx = playerBoard.indexOf(num);
    const botIdx    = botBrd.indexOf(num);

    // Evaluate on both boards for every line containing this number
    ALL_LINES.forEach(line => {
      // ── BOT BOARD lines ──
      if (line.includes(botIdx)) {
        const vals    = line.map(i => botBrd[i]);
        const called  = vals.filter(v => calledNums.includes(v)).length;
        const blocked = vals.some(v => playerBoard.includes(v) && !calledNums.includes(v) && v !== num);
        if (!blocked) {
          // Reward building the bot's own line
          if   (called === 4) scores[num] += 15000; // WIN
          else if(called === 3) scores[num] +=  2000;
          else if(called === 2) scores[num] +=   300;
          else if(called === 1) scores[num] +=    50;
          else                  scores[num] +=    10;
        }
      }
      // ── PLAYER BOARD lines — BLOCK threats ──
      if (line.includes(playerIdx)) {
        const vals   = line.map(i => playerBoard[i]);
        const called = vals.filter(v => calledNums.includes(v)).length;
        if   (called === 4) scores[num] += 10000; // block immediate win
        else if(called === 3) scores[num] +=  1500; // block 3-in-row
        else if(called === 2) scores[num] +=   200;
        else if(called === 1) scores[num] +=    30;
      }
    });

    // Center positional bonus on bot's board (indices 6,7,8,11,12,13,16,17,18)
    const centerIdxs = [6,7,8,11,12,13,16,17,18];
    if (centerIdxs.includes(botIdx)) scores[num] += 15;
  });

  // Pick the highest-scoring number
  return available.reduce((best, n) => scores[n] > scores[best] ? n : best, available[0]);
}

/* ── Master AI move dispatcher ── */
function getAIMove(calledNums) {
  if (botLevel === 'easy')      return aiMoveEasy(calledNums);
  if (botLevel === 'medium')    return aiMoveMedium(calledNums, playerBotBoard, botBoard);
  if (botLevel === 'hard')      return aiMoveHard(calledNums, playerBotBoard, botBoard);
  if (botLevel === 'expert')    return aiMoveExpert(calledNums, playerBotBoard, botBoard);
  if (botLevel === 'nightmare') return aiMoveNightmare(calledNums, playerBotBoard, botBoard);
}

/* LEVEL 4 — Expert: Fork-hunting + multi-threat awareness */
function aiMoveExpert(calledNums, playerBoard, botBrd) {
  const ALL_LINES = [];
  for(let r=0;r<5;r++){const b=r*5;ALL_LINES.push([b,b+1,b+2,b+3,b+4])}
  for(let c=0;c<5;c++){ALL_LINES.push([c,c+5,c+10,c+15,c+20])}
  ALL_LINES.push([0,6,12,18,24],[4,8,12,16,20]);

  const available = Array.from({length:25},(_,i)=>i+1).filter(n=>!calledNums.includes(n));
  if (!available.length) return null;

  // Immediate win — always take it
  for (const line of ALL_LINES) {
    const vals = line.map(i => botBrd[i]);
    const uncalled = vals.filter(v => !calledNums.includes(v));
    if (uncalled.length === 1 && available.includes(uncalled[0]) &&
        vals.filter(v => calledNums.includes(v)).length === 4) return uncalled[0];
  }

  // Block immediate player win
  for (const line of ALL_LINES) {
    const vals = line.map(i => playerBoard[i]);
    const uncalled = vals.filter(v => !calledNums.includes(v));
    if (uncalled.length === 1 && available.includes(uncalled[0]) &&
        vals.filter(v => calledNums.includes(v)).length === 4) return uncalled[0];
  }

  const scores = {};
  available.forEach(n => { scores[n] = 0; });

  available.forEach(num => {
    const botIdx    = botBrd.indexOf(num);
    const playerIdx = playerBoard.indexOf(num);

    // Count how many bot lines this number advances (fork potential)
    let botThreats = 0, playerThreats = 0;

    ALL_LINES.forEach(line => {
      // Bot lines
      if (line.includes(botIdx)) {
        const called = line.filter(i => calledNums.includes(botBrd[i])).length;
        if (called === 4) scores[num] += 50000;
        else if (called === 3) { scores[num] += 3000; botThreats++; }
        else if (called === 2) { scores[num] += 400; botThreats++; }
        else if (called === 1)   scores[num] += 60;
        else                     scores[num] += 10;
      }
      // Player threats to block
      if (line.includes(playerIdx)) {
        const called = line.filter(i => calledNums.includes(playerBoard[i])).length;
        if (called === 4) scores[num] += 40000;
        else if (called === 3) { scores[num] += 2500; playerThreats++; }
        else if (called === 2)   scores[num] += 350;
        else if (called === 1)   scores[num] += 40;
      }
    });

    // Big bonus for FORK moves — moves that create 2+ simultaneous threats
    if (botThreats >= 2) scores[num] += botThreats * 1500;
    // Big bonus for blocking player forks
    if (playerThreats >= 2) scores[num] += playerThreats * 1200;

    // Center position bonus
    const centerIdxs = [6,7,8,11,12,13,16,17,18];
    if (centerIdxs.includes(botIdx)) scores[num] += 25;
  });

  return available.reduce((best, n) => scores[n] > scores[best] ? n : best, available[0]);
}

/* LEVEL 5 — Nightmare: Near-perfect with lookahead simulation */
function aiMoveNightmare(calledNums, playerBoard, botBrd) {
  const ALL_LINES = [];
  for(let r=0;r<5;r++){const b=r*5;ALL_LINES.push([b,b+1,b+2,b+3,b+4])}
  for(let c=0;c<5;c++){ALL_LINES.push([c,c+5,c+10,c+15,c+20])}
  ALL_LINES.push([0,6,12,18,24],[4,8,12,16,20]);

  const available = Array.from({length:25},(_,i)=>i+1).filter(n=>!calledNums.includes(n));
  if (!available.length) return null;

  /* Score a board state — returns combined threat score */
  function scoreState(called, botBrd, playerBoard) {
    let s = 0;
    ALL_LINES.forEach(line => {
      const bVals = line.map(i => botBrd[i]);
      const pVals = line.map(i => playerBoard[i]);
      const bCalled = bVals.filter(v => called.includes(v)).length;
      const pCalled = pVals.filter(v => called.includes(v)).length;
      // Bot progress
      if      (bCalled === 5) s += 1000000;
      else if (bCalled === 4) s += 50000;
      else if (bCalled === 3) s += 2000;
      else if (bCalled === 2) s += 200;
      else if (bCalled === 1) s += 20;
      // Player threats (negative — we want to minimise)
      if      (pCalled === 5) s -= 800000;
      else if (pCalled === 4) s -= 40000;
      else if (pCalled === 3) s -= 1500;
      else if (pCalled === 2) s -= 150;
    });
    return s;
  }

  /* Lookahead 1: simulate calling this number, then pick opponent's best counter */
  function lookahead(num, called) {
    const newCalled = [...called, num];
    // My immediate gain
    const myGain = scoreState(newCalled, botBrd, playerBoard) - scoreState(called, botBrd, playerBoard);
    // Simulate opponent's best reply (1-ply lookahead)
    const remaining = available.filter(n => n !== num);
    if (!remaining.length) return myGain;
    let oppBest = -Infinity;
    remaining.slice(0,8).forEach(oppNum => { // limit to 8 for performance
      const afterOpp = [...newCalled, oppNum];
      const oppGain  = scoreState(afterOpp, playerBoard, botBrd) - scoreState(newCalled, playerBoard, botBrd);
      if (oppGain > oppBest) oppBest = oppGain;
    });
    return myGain - oppBest * 0.85; // discount opponent's reply
  }

  // Immediate win check
  for (const line of ALL_LINES) {
    const vals = line.map(i => botBrd[i]);
    const uncalled = vals.filter(v => !calledNums.includes(v));
    if (uncalled.length === 1 && available.includes(uncalled[0]) &&
        vals.filter(v => calledNums.includes(v)).length === 4) return uncalled[0];
  }

  // Immediate block check
  for (const line of ALL_LINES) {
    const vals = line.map(i => playerBoard[i]);
    const uncalled = vals.filter(v => !calledNums.includes(v));
    if (uncalled.length === 1 && available.includes(uncalled[0]) &&
        vals.filter(v => calledNums.includes(v)).length === 4) return uncalled[0];
  }

  // Full scored lookahead for remaining moves
  let bestScore = -Infinity, bestMove = available[0];
  available.forEach(num => {
    const s = lookahead(num, calledNums);
    if (s > bestScore) { bestScore = s; bestMove = num; }
  });
  return bestMove;
}

/* ═══════════════════════════════════════════════
   BOT GAME — UI & FLOW (no Firebase)
═══════════════════════════════════════════════ */

/* Highlight win cells on bot game board — staggered burst + flash */
let botLastLineCount = 0;
function botHighlightWinCells(board, selected, prefix) {
  const { winIdx, lines } = botCheckLines(board, selected);
  const isNewLine = lines > botLastLineCount;
  botLastLineCount = lines;

  // Group win indices into lines so we can stagger per-line
  const newLineSegs = [];
  if (isNewLine) {
    const ALL_LINES_BOT = [];
    for(let r=0;r<5;r++){const b=r*5;ALL_LINES_BOT.push([b,b+1,b+2,b+3,b+4]);}
    for(let c=0;c<5;c++){ALL_LINES_BOT.push([c,c+5,c+10,c+15,c+20]);}
    ALL_LINES_BOT.push([0,6,12,18,24],[4,8,12,16,20]);
    const hits = board.map(n => selected.includes(n) ? 1 : 0);
    ALL_LINES_BOT.forEach(line => {
      if (line.every(i => hits[i])) {
        const el0 = document.getElementById(`${prefix}cell-${board[line[0]]}`);
        if (el0 && !el0.classList.contains('win-line')) {
          newLineSegs.push(line);
        }
      }
    });
  }

  winIdx.forEach(idx => {
    const n = board[idx];
    const cell = document.getElementById(`${prefix}cell-${n}`);
    if (cell && !cell.classList.contains('win-line')) cell.classList.add('win-line');
  });

  if (isNewLine && newLineSegs.length > 0) {
    newLineSegs.forEach(seg => {
      const els = seg.map(i => document.getElementById(`${prefix}cell-${board[i]}`)).filter(Boolean);
      triggerLineBurst(els);
    });
    fireLineFlash();
  }
}

/* Render the player's bot-game board */
function renderBotGameBoard() {
  const boardDiv = document.getElementById('game-board');
  boardDiv.innerHTML = '';
  playerBotBoard.forEach(num => {
    const cell = document.createElement('div');
    cell.className = 'cell'; cell.textContent = num; cell.id = `cell-${num}`;
    cell.addEventListener('click', () => handleBotGameClick(num));
    boardDiv.appendChild(cell);
  });
}

/* Cross off a number visually (player board) */
function botCrossCell(num) {
  const cell = document.getElementById(`cell-${num}`);
  if (cell && !cell.classList.contains('crossed')) {
    cell.classList.add('crossed');
    sfx.cross();
  }
}

/* Show turn indicator + start/stop move timer for bot game */
function botUpdateTurnUI(isPlayerTurn) {
  document.getElementById('turn-indicator').textContent = isPlayerTurn ? 'Your Turn!' : "Bot's Turn…";
  document.getElementById('p1-box').classList.toggle('active-turn', isPlayerTurn);
  document.getElementById('p2-box').classList.toggle('active-turn', !isPlayerTurn);
  document.getElementById('ai-thinking-bar').classList.toggle('show', !isPlayerTurn);
  if (isPlayerTurn) {
    startMoveTimer(true, handleBotTimerExpiry);
  } else {
    stopMoveTimer(); // no timer for bot's turn
  }
}

/* triggerBotTurn — called by timer expiry to auto-pass player's turn in bot mode */
function triggerBotTurn() {
  if (!botWinShown) executeBotTurn();
}

/* Check and handle win condition for bot game */
function botCheckWin() {
  const playerResult = botCheckLines(playerBotBoard, botSelected);
  const botResult    = botCheckLines(botBoard, botSelected);
  if (playerResult.lines >= 5 || botResult.lines >= 5) {
    const playerWon = playerResult.lines >= botResult.lines ? playerResult.lines >= 5 : false;
    const botWon    = botResult.lines >= 5;

    botWinShown = true;
    botHighlightWinCells(playerBotBoard, botSelected, '');
    if (playerWon)  botScores.player++;
    else if (botWon) botScores.bot++;
    updateBotScoreDisplay();
    setTimeout(() => showBotWinOverlay(playerWon && !botWon), 500);
    return true;
  }
  return false;
}

/* Execute the AI's turn with a short thinking delay */
function executeBotTurn() {
  botUpdateTurnUI(false);
  const delay = botLevel === 'nightmare' ? 1400
              : botLevel === 'expert'    ? 1100
              : botLevel === 'hard'      ?  900
              : botLevel === 'medium'    ?  700 : 500;
  setTimeout(() => {
    if (botWinShown) return;
    const move = getAIMove(botSelected);
    if (move == null) return;
    botSelected.push(move);
    botCrossCell(move);
    if (!botCheckWin()) botUpdateTurnUI(true);
  }, delay);
}

/* Player clicks a cell in bot game */
function handleBotGameClick(num) {
  if (botWinShown) return;
  if (botSelected.includes(num)) return;
  // Only allow on player's turn (ai-thinking-bar hidden = player's turn)
  if (document.getElementById('ai-thinking-bar').classList.contains('show')) return;
  stopMoveTimer(); // cancel the turn timer — player acted in time
  botSelected.push(num);
  botCrossCell(num);
  if (!botCheckWin()) executeBotTurn();
}

function updateBotScoreDisplay() {
  document.getElementById('score-p1').textContent = botScores.player;
  document.getElementById('score-p2').textContent = botScores.bot;
}

/* Win overlay for bot game */
function showBotWinOverlay(playerWon) {
  const winPhrases  = ['Domination! 👑','Flawless Victory! ⚡','You\'re on fire! 🔥','GG! Absolutely lethal 🎯','Champion energy! 💎'];
  const losePhrases = ['The bot outsmarted you… 🤖','GG, rematch? 💪','Respect the grind 🤝','Bot.exe wins this round 😤'];
  playerWon ? sfx.win() : sfx.lose();
  document.getElementById('win-title-text').textContent  = playerWon ? '🎉 YOU WIN!' : '🤖 BOT WINS!';
  document.getElementById('win-subtitle-text').textContent = playerWon
    ? winPhrases[Math.floor(Math.random()*winPhrases.length)]
    : losePhrases[Math.floor(Math.random()*losePhrases.length)];
  document.getElementById('win-overlay').classList.add('show');
  if (playerWon) { launchWinAnimation(); recordWin(); } else { recordLoss(); }
  // No auto-rematch — player chooses via Restart / Exit
}

/* startBotRematchCountdown removed — bot rematch uses manual buttons only */

function restartBotGame() {
  if (botCountdownInterval) clearInterval(botCountdownInterval);
  botWinShown = false; botLastLineCount = 0;
  cleanupScheduled = false;
  stopMoveTimer();
  resetLifelines();
  document.getElementById('win-overlay').classList.remove('show');
  document.querySelectorAll('.cell.win-line').forEach(c => c.classList.remove('win-line'));
  document.querySelectorAll('.cell.crossed').forEach(c => c.classList.remove('crossed'));
  document.getElementById('ai-thinking-bar').classList.remove('show');
  // Refresh boards and restart
  botSelected = [];
  botBoard = genRandomBoard();
  playerBotBoard = genRandomBoard();
  renderBotGameBoard();
  botUpdateTurnUI(true);
  sfx.click();
}

/* ── Listen for startBotGame event from plain script ── */
document.addEventListener('startBotGame', (e) => {
  readDINGO();
  botMode  = true;
  botLevel = e.detail.level;
  botWinShown  = false;
  botSelected  = [];
  botScores    = {player:0, bot:0};

  // Generate boards
  playerBotBoard = genRandomBoard();
  botBoard       = genRandomBoard();

  // Set up UI
  document.getElementById('p1-name').textContent   = playerName;
  renderAvatar(document.getElementById('p1-avatar'), playerAvatar)
  document.getElementById('p2-name').textContent   = BOT_NAMES[botLevel];
  renderAvatar(document.getElementById('p2-avatar'), BOT_AVATARS[botLevel])
  document.getElementById('p2-box').classList.add('is-bot');

  // Show AI mode pill
  const pill = document.getElementById('ai-mode-pill');
  pill.classList.add('show');
  pill.textContent = botLevel.toUpperCase();
  // Color pill per level
  const pillColors = {
    easy:      'rgba(0,255,204,.15)',
    medium:    'rgba(255,204,0,.15)',
    hard:      'rgba(255,45,85,.15)',
    expert:    'rgba(123,97,255,.2)',
    nightmare: 'rgba(255,20,20,.2)'
  };
  const pillTextColors = {
    easy:'#00ffcc', medium:'#ffcc00', hard:'#ff2d55', expert:'#a78bfa', nightmare:'#ff4444'
  };
  pill.style.background = pillColors[botLevel] || '';
  pill.style.color      = pillTextColors[botLevel] || '';

  // Score labels — use actual names instead of generic "You" / "Bot"
  document.getElementById('score-lbl-p1').textContent = playerName;
  document.getElementById('score-lbl-p2').textContent = BOT_NAMES[botLevel];
  updateBotScoreDisplay();

  // Render board and go to game screen
  showScreen('game');
  renderBotGameBoard();
  resetLifelines();
  activateMoveTimerUI();
  botUpdateTurnUI(true);

  // Hide chat FAB (bot game has no chat)
  document.getElementById('chat-fab').style.display = 'none';
  document.getElementById('chat-panel').classList.remove('open');

  sfx.click();
});

/* Patch restart/reset buttons to handle bot game */
document.getElementById('win-restart-btn').addEventListener('click', () => {
  if (botMode) restartBotGame(); else doRestart();
});
document.getElementById('restart-btn').addEventListener('click', () => {
  if (botMode) restartBotGame(); else doRestart();
});
document.getElementById('win-reset-btn').addEventListener('click', () => {
  if (botMode) { botMode=false; doReset(); } else doReset();
});
document.getElementById('reset-btn').addEventListener('click', () => {
  if (botMode) { botMode=false; doReset(); } else doReset();
});

/* Also patch home-from-game for bot mode */
document.getElementById('home-from-game').addEventListener('click', () => {
  botMode = false;
  document.getElementById('ai-mode-pill').classList.remove('show');
  document.getElementById('ai-thinking-bar').classList.remove('show');
  document.getElementById('p2-box').classList.remove('is-bot');
  leaveRoomCleanup();
  showScreen('home');
  document.getElementById('chat-fab').style.display = 'none';
  document.getElementById('chat-panel').classList.remove('open');
  document.getElementById('win-overlay').classList.remove('show');
});

/* ═══════════════════════════════════════════════
   ROOM HELPERS
═══════════════════════════════════════════════ */
function genRoomId() {
  const chars='ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  return Array.from({length:4},()=>chars[Math.floor(Math.random()*chars.length)]).join('');
}
function readDINGO() {
  playerName   = window.DINGO.playerName    || 'Player';
  playerAvatar = window.DINGO.selectedAvatar || AVATAR_DEFS[0].svg;
  playerColor  = window.DINGO.selectedColor  || '#00e5ff';
}

/* ═══════════════════════════════════════════════
   OPPONENT EXIT DETECTION (v2)
   ─ The old presence/countdown system is replaced.
   ─ Now we ONLY show "Opponent Left" when the opponent
     explicitly clicks an exit/home button — not on
     accidental disconnect or tab close.
   ─ Exit writes `p1Exited` or `p2Exited: true` to gameState.
   ─ The other player picks it up, shows a 5-second popup,
     then auto-wins. Popup only shows on game-screen.
═══════════════════════════════════════════════ */
let presenceRef        = null; // kept for API compat — not actively used now
let opponentWasPresent = false;

function setupPresence() {
  // No-op now — we no longer use Firebase presence for abandonment
  opponentWasPresent = false;
}

let oppLeftPopupTimeout  = null;
let oppLeftSecsInterval  = null;

function showOppLeftPopup() {
  // Only show if we are currently in the game screen
  const gameScreen = document.getElementById('game-screen');
  if (!gameScreen || !gameScreen.classList.contains('active')) return;

  const popup  = document.getElementById('opponent-left-popup');
  const secsEl = document.getElementById('opp-left-secs');
  const ring   = document.getElementById('opp-ring-progress');

  popup.classList.add('show');
  sfx.ping && sfx.ping();

  // Reset ring + counter
  ring.style.transition = 'none';
  ring.style.strokeDashoffset = '0';
  void ring.offsetWidth;

  let secsLeft = 5;
  secsEl.textContent = secsLeft;

  // Animate ring draining over 5 seconds
  ring.style.transition = 'stroke-dashoffset 5s linear';
  ring.style.strokeDashoffset = '100';

  if (oppLeftSecsInterval) clearInterval(oppLeftSecsInterval);
  oppLeftSecsInterval = setInterval(() => {
    secsLeft--;
    secsEl.textContent = Math.max(0, secsLeft);
  }, 1000);

  if (oppLeftPopupTimeout) clearTimeout(oppLeftPopupTimeout);
  oppLeftPopupTimeout = setTimeout(() => {
    clearInterval(oppLeftSecsInterval);
    popup.classList.remove('show');
    declareAbandonWin(); // remaining player wins after popup closes
  }, 5200);
}

function watchOpponentPresence() {
  if (!roomId || !playerRole || botMode) return;
  const opponentRole = playerRole === 'p1' ? 'p2' : 'p1';
  const exitKey      = opponentRole + 'Exited'; // e.g. 'p2Exited'

  // Listen for the exit flag the opponent writes when they click exit
  onRoomValue(ref(db, `rooms/${roomId}/gameState`), snap => {
    const state = snap.val();
    if (!state) return;
    if (state[exitKey] === true && !winShown) {
      showOppLeftPopup();
    }
  });
}

/* ─── stopAbandonCountdown — kept so existing call sites don't break ─── */
function stopAbandonCountdown(hideOnly = true) {
  // No-op — countdown removed, but we keep this so other call sites compile
}

async function declareAbandonWin() {
  document.getElementById('opponent-left-popup').classList.remove('show');
  if (!roomId) return;
  await update(ref(db, `rooms/${roomId}/gameState`), {
    winner: playerRole,
    status: 'abandoned'
  });
}

/* ─── Graceful leave: write exit flag so opponent is notified instantly ─── */
function leaveRoomCleanup() {
  stopAbandonCountdown(false);
  stopMoveTimer();
  opponentWasPresent = false;

  // Detach all room-scoped Firebase listeners first
  detachRoomListeners();

  // Write exit flag then check if BOTH players have now exited → delete room
  if (roomId && playerRole) {
    const exitKey     = playerRole + 'Exited';
    const capturedRoom = roomId; // capture before clearing below

    update(ref(db, `rooms/${capturedRoom}/gameState`), { [exitKey]: true })
      .then(() => ref(db, `rooms/${capturedRoom}/gameState`).get())
      .then(snap => {
        const state = snap.val();
        if (state && state.p1Exited && state.p2Exited) {
          // Both players have exited — safe to delete the room now
          set(ref(db, `rooms/${capturedRoom}`), null).catch(() => {});
        }
      })
      .catch(() => {});
  }

  // If we created a room but nobody ever joined (p1, no p2) — delete immediately
  if (roomId && playerRole === 'p1') {
    const capturedRoom = roomId;
    ref(db, `rooms/${capturedRoom}/players`).get().then(snap => {
      const players = snap.val();
      if (players && !players.p2) {
        set(ref(db, `rooms/${capturedRoom}`), null).catch(() => {});
      }
    }).catch(() => {});
  }

  // Reset all local game state so next match starts clean
  roomId = '';
  playerRole = '';
  myBoard = [];
  winShown = false;
  lastLineCount = 0;
  cleanupScheduled = false;
  readyListenerActive = false;
  scores = { p1: 0, p2: 0 };
  lifelineState = { p1: 3, p2: 3 };
  botMode = false;
  botSelected = [];
  botWinShown = false;
  botLastLineCount = 0;
}

/* ═══════════════════════════════════════════════
   ROOM CLEANUP — fallback deletion after win
   Triggers 10s after win is declared. In most
   cases both players will have already exited and
   deleted the room via leaveRoomCleanup(). This
   is just a safety net for edge cases (e.g. one
   player closes the app without clicking Exit).
═══════════════════════════════════════════════ */
let cleanupScheduled = false;
function scheduleRoomCleanup() {
  if (cleanupScheduled || !roomId) return;
  cleanupScheduled = true;
  const roomToDelete = roomId; // capture now — roomId may clear later
  setTimeout(async () => {
    try {
      // Only delete if room still exists (may already be gone via leaveRoomCleanup)
      const snap = await ref(db, `rooms/${roomToDelete}`).get();
      if (snap.exists()) {
        await set(ref(db, `rooms/${roomToDelete}`), null);
      }
    } catch (e) { /* already deleted — ignore */ }
  }, 10000); // 10 second safety net
}

/* ═══════════════════════════════════════════════
   STAGGERED BINGO LINE BURST + TOAST
   When a new 5-in-a-row is completed the five cells
   light up one by one (domino-style, 55 ms apart)
   and a "BINGO!" toast drops in from the top of the board.
═══════════════════════════════════════════════ */
function triggerLineBurst(cellElements) {
  // cellElements: array of DOM elements in the line, in order
  cellElements.forEach((cell, i) => {
    setTimeout(() => {
      cell.classList.add('line-burst');
      setTimeout(() => cell.classList.remove('line-burst'), 420);
    }, i * 55);
  });
  // Show the BINGO toast after the last cell lights up
  setTimeout(() => showBingoToast(), cellElements.length * 55 + 40);
}

let bingoToastTimeout = null;
function showBingoToast() {
  let toast = document.getElementById('bingo-toast');
  if (!toast) {
    toast = document.createElement('div');
    toast.id = 'bingo-toast';
    toast.style.cssText = `
      position:fixed;top:50%;left:50%;transform:translate(-50%,-50%) scale(.6);
      z-index:8000;pointer-events:none;opacity:0;
      font-family:'Black Han Sans',sans-serif;font-size:clamp(38px,10vw,64px);
      letter-spacing:6px;color:var(--c3);
      text-shadow:0 0 20px rgba(255,204,0,.8),0 0 40px rgba(255,204,0,.4);
      transition:opacity .15s,transform .15s;
    `;
    toast.textContent = 'BINGO!';
    document.body.appendChild(toast);
  }
  // Force reflow then animate in
  void toast.offsetWidth;
  toast.style.opacity = '1';
  toast.style.transform = 'translate(-50%,-50%) scale(1)';
  if (bingoToastTimeout) clearTimeout(bingoToastTimeout);
  bingoToastTimeout = setTimeout(() => {
    toast.style.opacity = '0';
    toast.style.transform = 'translate(-50%,-50%) scale(1.15)';
  }, 900);
}

/* ── PLAY NOW — instant auto-matchmaking ───────────── */
document.getElementById('play-now-btn').addEventListener('click', async () => {
  readDINGO();
  if (navigator.vibrate) navigator.vibrate([40, 15, 40]);
  const btn = document.getElementById('play-now-btn');
  const msg = document.getElementById('home-msg');
  btn.disabled = true;
  btn.innerHTML = '<span class="play-now-icon">⏳</span> FINDING MATCH…';
  msg.textContent = '';
  try {
    const roomsSnap = await get(ref(db, 'rooms'));
    const rooms = roomsSnap.val() || {};
    let foundRoom = null;
    for (const [id, room] of Object.entries(rooms)) {
      if (
        room.gameState?.status === 'waiting' &&
        room.players?.p1 &&
        !room.players?.p2
      ) { foundRoom = id; break; }
    }
    if (foundRoom) {
      roomId = foundRoom; playerRole = 'p2';
      await update(ref(db, `rooms/${roomId}/players`), { p2: myPlayerId });
      await update(ref(db, `rooms/${roomId}/playerInfo`), {
        p2: { name: playerName, avatar: playerAvatar, color: playerColor }
      });
      document.getElementById('display-room-code').innerText = roomId;
      document.getElementById('waiting-label').innerText = 'Connected!';
      initSetupBoard(); showScreen('setup'); showChat();
      setupPresence(); watchOpponentPresence();
      onRoomValue(ref(db, `rooms/${roomId}/playerInfo`), snap => {
        const info = snap.val();
        if (info?.p1) { document.getElementById('p1-name').textContent = info.p1.name; renderAvatar(document.getElementById('p1-avatar'), info.p1.avatar); if(playerRole==='p2'&&info.p1) setCurrentOpponent(info.p1.name, info.p1.username||'', info.p1.avatar||''); }
        if (info?.p2) { document.getElementById('p2-name').textContent = info.p2.name; renderAvatar(document.getElementById('p2-avatar'), info.p2.avatar); if(playerRole==='p1'&&info.p2) setCurrentOpponent(info.p2.name, info.p2.username||'', info.p2.avatar||''); }
      });
      onRoomValue(ref(db, `rooms/${roomId}/scores`), snap => {
        const s = snap.val();
        if (s) { scores.p1 = s.p1||0; scores.p2 = s.p2||0; updateScoreDisplay(); }
      });
    } else {
      roomId = genRoomId(); playerRole = 'p1';
      await set(ref(db, `rooms/${roomId}`), {
        players:    { p1: myPlayerId },
        playerInfo: { p1: { name: playerName, avatar: playerAvatar, color: playerColor } },
        gameState:  { status: 'waiting', currentTurn: 'p1', selectedNumbers: [0], winner: '' },
        scores:     { p1: 0, p2: 0 }
      });
      document.getElementById('display-room-code').innerText = roomId;
      document.getElementById('waiting-label').innerText = 'Waiting for an opponent…';
      initSetupBoard(); showScreen('setup'); showChat();
      setupPresence(); watchOpponentPresence();
      onRoomValue(ref(db, `rooms/${roomId}/playerInfo`), snap => {
        const info = snap.val();
        if (info?.p2) {
          document.getElementById('p2-name').textContent = info.p2.name;
          renderAvatar(document.getElementById('p2-avatar'), info.p2.avatar)
          document.getElementById('waiting-label').textContent = `${info.p2.name} joined!`;
        }
        if (info?.p1) {
          document.getElementById('p1-name').textContent = info.p1.name;
          renderAvatar(document.getElementById('p1-avatar'), info.p1.avatar)
        }
      });
      onRoomValue(ref(db, `rooms/${roomId}/scores`), snap => {
        const s = snap.val();
        if (s) { scores.p1 = s.p1||0; scores.p2 = s.p2||0; updateScoreDisplay(); }
      });
      msg.textContent = '🔎 Searching for opponent — share the room code!';
      msg.style.color = 'var(--c1)';
    }
  } catch(err) {
    let errMsg = `❌ ${err.message}`;
    if (err.message.includes('permission') || err.message.includes('PERMISSION')) {
      errMsg = '❌ Firebase rules blocking writes. Set rules to allow read/write.';
    }
    document.getElementById('home-msg').textContent = errMsg;
    setFirebaseStatus(false, errMsg);
  } finally {
    btn.disabled = false;
    btn.innerHTML = '<span class="play-now-icon">⚡</span> PLAY NOW';
  }
});

/* ── Create Room ──────────────────────────────── */
document.getElementById('create-btn').addEventListener('click', async () => {
  readDINGO(); sfx.click();
  if (navigator.vibrate) navigator.vibrate([30, 10, 30]);
  const btn = document.getElementById('create-btn');
  const msg = document.getElementById('home-msg');
  btn.disabled = true; btn.textContent = '⏳ Creating…'; msg.textContent = '';

  try {
    roomId = genRoomId(); playerRole = 'p1';

    const roomData = {
      players:   { p1: myPlayerId },
      playerInfo:{ p1: { name: playerName, avatar: playerAvatar, color: playerColor } },
      gameState: { status: 'waiting', currentTurn: 'p1', selectedNumbers: [0], winner: '' },
      scores:    { p1: 0, p2: 0 }
    };

    await set(ref(db, `rooms/${roomId}`), roomData);

    // Confirm the write actually landed
    const check = await get(ref(db, `rooms/${roomId}/players`));
    if (!check.exists()) throw new Error('Room write did not persist — check Firebase rules');

    document.getElementById('display-room-code').innerText  = roomId;
    document.getElementById('waiting-label').innerText      = 'Waiting for opponent…';
    initSetupBoard(); showScreen('setup'); showChat();
    setupPresence(); watchOpponentPresence();

    onRoomValue(ref(db, `rooms/${roomId}/playerInfo`), snap => {
      const info = snap.val();
      if (info?.p2) {
        document.getElementById('p2-name').textContent    = info.p2.name;
        renderAvatar(document.getElementById('p2-avatar'), info.p2.avatar)
        document.getElementById('waiting-label').textContent = `${info.p2.name} joined!`;
      }
      if (info?.p1) {
        document.getElementById('p1-name').textContent   = info.p1.name;
        renderAvatar(document.getElementById('p1-avatar'), info.p1.avatar)
      }
    });
    onRoomValue(ref(db, `rooms/${roomId}/scores`), snap => {
      const s = snap.val();
      if (s) { scores.p1 = s.p1 || 0; scores.p2 = s.p2 || 0; updateScoreDisplay(); }
    });

  } catch(err) {
    console.error('Create room error:', err);
    // Show a clear, helpful error message
    let errMsg = `❌ ${err.message}`;
    if (err.message.includes('permission') || err.message.includes('PERMISSION')) {
      errMsg = '❌ Firebase rules blocking writes. Set rules to allow read/write.';
      document.getElementById('firebase-rules-help').style.display = 'block';
    } else if (err.message.includes('network') || err.message.includes('fetch')) {
      errMsg = '❌ No internet connection. Check your network.';
    }
    msg.textContent = errMsg;
    msg.style.color = 'var(--pink)';
    setFirebaseStatus(false, errMsg);
  } finally {
    btn.disabled = false; btn.textContent = '＋ Create Room';
  }
});

/* ── Join Room ────────────────────────────────── */
document.getElementById('join-btn').addEventListener('click', async () => {
  readDINGO(); sfx.click();
  const btn=document.getElementById('join-btn'), msg=document.getElementById('home-msg');
  const code=document.getElementById('room-code-input').value.trim().toUpperCase();
  if(!code)return;
  btn.disabled=true; btn.textContent='⏳'; msg.textContent='';
  try {
    const snap=await get(ref(db,`rooms/${code}`));
    if(snap.exists()&&!snap.val().players.p2){
      roomId=code; playerRole='p2';
      await update(ref(db,`rooms/${code}`),{
        'players/p2':myPlayerId,
        'playerInfo/p2/name':playerName,
        'playerInfo/p2/avatar':playerAvatar,
        'playerInfo/p2/color':playerColor,
      });
      const info=snap.val().playerInfo||{};
      document.getElementById('display-room-code').innerText=roomId;
      document.getElementById('p1-name').textContent=info.p1?info.p1.name:'P1';
      renderAvatar(document.getElementById('p1-avatar'), info.p1?info.p1.avatar:'🎮')
      document.getElementById('p2-name').textContent=playerName;
      renderAvatar(document.getElementById('p2-avatar'), playerAvatar)
      document.getElementById('waiting-label').textContent='You joined!';
      initSetupBoard(); showScreen('setup'); showChat();
      setupPresence(); watchOpponentPresence();
      onRoomValue(ref(db,`rooms/${roomId}/scores`),s=>{
        const sc=s.val();if(sc){scores.p1=sc.p1||0;scores.p2=sc.p2||0;updateScoreDisplay()}
      });
    } else {
      msg.textContent=snap.exists()?'Room is full!':'Room not found!';
      setTimeout(()=>{msg.textContent=''},3000);
    }
  } catch(err){msg.textContent=`Error: ${err.message}`;console.error(err);}
  finally{btn.disabled=false;btn.textContent='Join'}
});

/* ─── Score display ───────────────────────────── */
function updateScoreDisplay(){
  document.getElementById('score-p1').textContent=scores.p1;
  document.getElementById('score-p2').textContent=scores.p2;
}

/* ─── Setup board ─────────────────────────────── */
function initSetupBoard(){
  const bd=document.getElementById('setup-board');
  bd.innerHTML=''; myBoard=new Array(25).fill(null); setupCounter=1;
  document.getElementById('setup-progress').style.width='0%';
  document.getElementById('ready-btn').disabled=true;
  for(let i=0;i<25;i++){
    const cell=document.createElement('div');
    cell.className='cell'; cell.dataset.idx=i;
    cell.addEventListener('click',()=>placeNumber(cell,i));
    bd.appendChild(cell);
  }
}
function placeNumber(cell,idx){
  if(cell.dataset.filled||setupCounter>25)return;
  cell.textContent=setupCounter; cell.dataset.filled='true';
  myBoard[idx]=setupCounter; setupCounter++;
  sfx.click();
  document.getElementById('setup-progress').style.width=((setupCounter-1)/25*100)+'%';
  if(setupCounter>25)document.getElementById('ready-btn').disabled=false;
}
document.getElementById('shuffle-btn').addEventListener('click',()=>{
  sfx.click();
  const nums=Array.from({length:25},(_,i)=>i+1);
  for(let i=nums.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[nums[i],nums[j]]=[nums[j],nums[i]]}
  myBoard=[...nums]; setupCounter=26;
  document.querySelectorAll('#setup-board .cell').forEach((cell,i)=>{
    cell.textContent=nums[i]; cell.dataset.filled='true';
    cell.style.animation='none'; requestAnimationFrame(()=>{cell.style.animation=''});
  });
  document.getElementById('setup-progress').style.width='100%';
  document.getElementById('ready-btn').disabled=false;
});
document.getElementById('clear-btn').addEventListener('click',()=>{sfx.click();initSetupBoard()});

/* ─── Ready ───────────────────────────────────── */
let readyListenerActive = false;
document.getElementById('ready-btn').addEventListener('click',async()=>{
  sfx.click();
  const btn=document.getElementById('ready-btn');
  btn.disabled=true; btn.textContent='⏳ Waiting…';
  await update(ref(db,`rooms/${roomId}/boards`),{[playerRole]:myBoard});
  // Guard: only register one boards listener per round
  if(!readyListenerActive){
    readyListenerActive=true;
    onRoomValue(ref(db,`rooms/${roomId}/boards`),snap=>{
      const b=snap.val();
      if(b&&b.p1&&b.p2){
        readyListenerActive=false;
        update(ref(db,`rooms/${roomId}/gameState`),{status:'playing'});
        startGame();
      }
    });
  }
});

/* ═══════════════════════════════════════════════
   MOVE TIMER + LIFELINES
   ─ 25-second countdown starts whenever it becomes
     a player's turn (both multiplayer and bot mode).
   ─ Each player has 3 lifelines. When the timer expires
     on your turn:  one lifeline is consumed and the
     turn automatically passes to your opponent.
   ─ If all 3 lifelines are gone the opponent wins
     immediately.
   ─ Timer resets every time the turn changes.
═══════════════════════════════════════════════ */
const MOVE_TIME   = 25;   // seconds per move
let moveTimerInt  = null; // setInterval handle
let moveTimerSecs = MOVE_TIME;
let lifelineState = { p1: 3, p2: 3 }; // remaining lifelines per player

/* ─── Show the timer bar (lifelines are always visible inside player boxes) ─── */
function activateMoveTimerUI() {
  document.getElementById('move-timer-wrap').classList.add('active');
  // Lifelines are embedded in player boxes — always visible, no activation needed
}

/* ─── Render lifeline chips for both players ─── */
function renderLifelines() {
  ['p1','p2'].forEach(role => {
    const container = document.getElementById('lifelines-' + role);
    if (!container) return;
    container.querySelectorAll('.lifeline-chip').forEach(chip => {
      const n = parseInt(chip.dataset.n, 10); // chip 1,2,3
      // A chip is "used" if the player has fewer lifelines than that chip's slot
      const remaining = lifelineState[role];
      chip.classList.toggle('used', n > remaining);
    });
  });
}

/* ─── Update the timer bar fill and colour based on seconds left ─── */
function updateTimerBarUI(secsLeft) {
  const fill    = document.getElementById('move-timer-bar-fill');
  const secsEl  = document.getElementById('move-timer-secs');
  const pct     = (secsLeft / MOVE_TIME) * 100;
  fill.style.width = pct + '%';
  secsEl.textContent = secsLeft;

  // Colour: green → yellow → red
  const warn = secsLeft <= 10;
  const dang = secsLeft <= 5;
  fill.classList.toggle('warning', warn && !dang);
  fill.classList.toggle('danger', dang);
  secsEl.classList.toggle('warning', warn && !dang);
  secsEl.classList.toggle('danger', dang);
}

/* ─── Stop any running timer ─── */
function stopMoveTimer() {
  if (moveTimerInt) { clearInterval(moveTimerInt); moveTimerInt = null; }
  // Reset bar to full without animation so next start is clean
  const fill = document.getElementById('move-timer-bar-fill');
  if (fill) {
    fill.style.transition = 'none';
    fill.style.width = '100%';
    fill.classList.remove('warning','danger');
    void fill.offsetWidth;
    fill.style.transition = 'width 1s linear, background .3s';
  }
  const secsEl = document.getElementById('move-timer-secs');
  if (secsEl) { secsEl.textContent = MOVE_TIME; secsEl.classList.remove('warning','danger'); }
}

/* ─── Start the 25-second move timer.
       isMyTurn: true when the local player must act.
       onExpire: callback called when the timer hits 0. ─── */
function startMoveTimer(isMyTurn, onExpire) {
  stopMoveTimer();
  moveTimerSecs = MOVE_TIME;
  updateTimerBarUI(moveTimerSecs);

  moveTimerInt = setInterval(() => {
    moveTimerSecs--;
    updateTimerBarUI(moveTimerSecs);
    if (moveTimerSecs <= 0) {
      stopMoveTimer();
      if (isMyTurn && typeof onExpire === 'function') onExpire();
    }
  }, 1000);
}

/* ─── Handle timer expiry for MULTIPLAYER ─── */
async function handleMultiplayerTimerExpiry() {
  if (!roomId || !playerRole) return;
  const myLifelines = lifelineState[playerRole];

  if (myLifelines <= 1) {
    // Last lifeline gone — opponent wins
    lifelineState[playerRole] = 0;
    renderLifelines();
    // Write lifelines + winner to Firebase so opponent sees both
    await update(ref(db, `rooms/${roomId}/gameState`), {
      winner: playerRole === 'p1' ? 'p2' : 'p1',
      status: 'timeout',
      [`lifelines_${playerRole}`]: 0
    });
  } else {
    // Consume a lifeline and pass the turn
    lifelineState[playerRole] = myLifelines - 1;
    renderLifelines();
    // Pass turn without selecting a number, also broadcast lifeline count
    const stateRef = ref(db, `rooms/${roomId}/gameState`);
    const snap = await get(stateRef);
    const state = snap.val();
    if (state && state.currentTurn === playerRole && !state.winner) {
      await update(stateRef, {
        currentTurn: playerRole === 'p1' ? 'p2' : 'p1',
        [`lifelines_${playerRole}`]: lifelineState[playerRole]
      });
    }
  }
}

/* ─── Handle timer expiry for BOT MODE ─── */
function handleBotTimerExpiry() {
  const myLifelines = lifelineState.p1; // player is always p1 in bot mode

  if (myLifelines <= 1) {
    lifelineState.p1 = 0;
    renderLifelines();
    // Bot wins by timeout
    botWinShown = true;
    stopMoveTimer();
    document.getElementById('win-title-text').textContent = '⏰ TIME OUT';
    document.getElementById('win-subtitle-text').textContent = 'All lifelines used — bot wins!';
    document.getElementById('win-overlay').classList.add('show');
    sfx.lose && sfx.lose();
  } else {
    lifelineState.p1 = myLifelines - 1;
    renderLifelines();
    // Auto-pass: trigger bot's turn immediately
    triggerBotTurn();
  }
}

/* ─── Reset lifelines for a fresh game ─── */
function resetLifelines() {
  lifelineState = { p1: 3, p2: 3 };
  renderLifelines();
  // Sync initial lifeline state to Firebase for multiplayer
  if (roomId) {
    update(ref(db, `rooms/${roomId}/gameState`), {
      lifelines_p1: 3,
      lifelines_p2: 3
    }).catch(() => {});
  }
}
let announceTimer=null;
function showAnnouncement(num,callerName,isMe){
  sfx.announce();
  const bubble=document.getElementById('announce-bubble');
  bubble.classList.remove('pop','fade-out'); void bubble.offsetWidth;
  document.getElementById('announce-who').textContent=isMe?'YOU CALLED':callerName.toUpperCase();
  document.getElementById('announce-num').textContent=num;
  document.getElementById('announce-sub').textContent=isMe?'nicely done':'crosses it out';
  bubble.classList.add('pop');
  if(announceTimer)clearTimeout(announceTimer);
  announceTimer=setTimeout(()=>{bubble.classList.remove('pop');bubble.classList.add('fade-out')},1600);
}

/* ═══════════════════════════════════════════════
   START GAME
═══════════════════════════════════════════════ */
function startGame(){
  winShown=false; // always clear on fresh start
  showScreen('game');
  const boardDiv=document.getElementById('game-board');
  boardDiv.innerHTML='';
  let lastLen=0;
  stopMoveTimer();
  resetLifelines();
  activateMoveTimerUI();
  // Re-register opponent presence watcher (detached on rematch cleanup)
  if(!botMode) watchOpponentPresence();

  onRoomValue(ref(db,`rooms/${roomId}/playerInfo`),snap=>{
    const info=snap.val()||{};
    if(info.p1){
      document.getElementById('p1-name').textContent=info.p1.name;
      renderAvatar(document.getElementById('p1-avatar'), info.p1.avatar)
      document.getElementById('score-lbl-p1').textContent=info.p1.name;
    }
    if(info.p2){
      document.getElementById('p2-name').textContent=info.p2.name;
      renderAvatar(document.getElementById('p2-avatar'), info.p2.avatar)
      document.getElementById('score-lbl-p2').textContent=info.p2.name;
    }
  });

  // Re-register scores listener (needed after rematch listener detach)
  if(!botMode){
    onRoomValue(ref(db,`rooms/${roomId}/scores`),snap=>{
      const s=snap.val();
      if(s){scores.p1=s.p1||0;scores.p2=s.p2||0;updateScoreDisplay();}
    });
  }

  myBoard.forEach(num=>{
    const cell=document.createElement('div');
    cell.className='cell'; cell.textContent=num; cell.id=`cell-${num}`;
    cell.addEventListener('click',()=>handleNumberClick(num));
    boardDiv.appendChild(cell);
  });

  onRoomValue(ref(db,`rooms/${roomId}/gameState`),snap=>{
    const state=snap.val(); if(!state)return;
    const turnText=document.getElementById('turn-indicator');
    document.getElementById('p1-box').classList.toggle('active-turn',state.currentTurn==='p1');
    document.getElementById('p2-box').classList.toggle('active-turn',state.currentTurn==='p2');

    // ── Sync lifelines from Firebase so BOTH players see the same state ──
    const opponentRole = playerRole === 'p1' ? 'p2' : 'p1';
    if (typeof state.lifelines_p1 === 'number') lifelineState.p1 = state.lifelines_p1;
    if (typeof state.lifelines_p2 === 'number') lifelineState.p2 = state.lifelines_p2;
    renderLifelines();

    if(state.winner&&!winShown){
      winShown=true;
      stopMoveTimer();
      stopAbandonCountdown(false);
      const iWon=state.winner===playerRole;
      const wasAbandoned = state.status === 'abandoned';
      if(iWon){scores[playerRole]++;update(ref(db,`rooms/${roomId}/scores`),{[playerRole]:scores[playerRole]})}
      if(state.selectedNumbers)checkAndHighlightWin(state.selectedNumbers);
      setTimeout(()=>{
        showWinOverlay(iWon, wasAbandoned);
      },500);
      // The player who did NOT declare the win also schedules cleanup
      // (so cleanup fires even if the declarer disconnects right after)
      scheduleRoomCleanup();
      turnText.innerText=''; return;
    }
    turnText.innerText=state.currentTurn===playerRole?'Your Turn!':"Opponent's Turn…";
    // ── Start 25-second move timer on every turn change ──
    const isMyTurn = state.currentTurn === playerRole;
    startMoveTimer(isMyTurn, handleMultiplayerTimerExpiry);

    if(state.selectedNumbers){
      if(state.selectedNumbers.length>lastLen){
        const newNum=state.selectedNumbers[state.selectedNumbers.length-1];
        if(newNum!==0){
          /* announcement popup removed — number cross animation on cell is enough */
        }
      }
      lastLen=state.selectedNumbers.length;
      state.selectedNumbers.forEach(num=>{
        if(num!==0){
          const c=document.getElementById(`cell-${num}`);
          if(c&&!c.classList.contains('crossed')){c.classList.add('crossed');sfx.cross()}
        }
      });
      checkAndHighlightWin(state.selectedNumbers);
    }
  });
}

/* ─── Handle click ────────────────────────────── */
async function handleNumberClick(num){
  const stateRef=ref(db,`rooms/${roomId}/gameState`);
  const snap=await get(stateRef); const state=snap.val();
  if(state.currentTurn===playerRole&&!state.winner&&!state.selectedNumbers.includes(num)){
    stopMoveTimer(); // player acted in time — cancel the turn timer
    await update(stateRef,{selectedNumbers:[...state.selectedNumbers,num],currentTurn:playerRole==='p1'?'p2':'p1'});
  }
}

/* ─── Win check + highlight ───────────────────── */
/* ─── Screen flash helper ─────────────────────────── */
let flashTimeout = null;
function fireLineFlash() {
  const el = document.getElementById('line-flash');
  el.classList.remove('flash');
  void el.offsetWidth;
  el.classList.add('flash');
  if (flashTimeout) clearTimeout(flashTimeout);
  flashTimeout = setTimeout(() => el.classList.remove('flash'), 500);
}

/* ─── Win check + highlight (multiplayer) ─────────── */
let lastLineCount = 0;

// ALL_LINES definition shared with win-check helpers
const BOARD_LINES = [];
for(let r=0;r<5;r++){const b=r*5;BOARD_LINES.push([b,b+1,b+2,b+3,b+4]);}
for(let c=0;c<5;c++){BOARD_LINES.push([c,c+5,c+10,c+15,c+20]);}
BOARD_LINES.push([0,6,12,18,24],[4,8,12,16,20]);

function checkAndHighlightWin(sel){
  const hits = myBoard.map(n => sel.includes(n) ? 1 : 0);
  let lines = 0;
  const winIdx = new Set();
  // Track which new line cells to burst (per line so we can stagger in order)
  const newLineSegments = [];

  BOARD_LINES.forEach(line => {
    if (line.every(i => hits[i])) {
      // This line is complete
      const isNew = !line.some(i => {
        const c = document.getElementById(`cell-${myBoard[i]}`);
        return c && c.classList.contains('win-line');
      });
      line.forEach(i => winIdx.add(i));
      lines++;
      if (isNew) newLineSegments.push(line);
    }
  });

  const isNewLine = lines > lastLineCount;
  lastLineCount = lines;

  // Apply win-line class to all winning cells
  winIdx.forEach(idx => {
    const c = document.getElementById(`cell-${myBoard[idx]}`);
    if (c && !c.classList.contains('win-line')) c.classList.add('win-line');
  });

  // Staggered burst for every newly completed line
  if (isNewLine && newLineSegments.length > 0) {
    newLineSegments.forEach(seg => {
      const els = seg.map(i => document.getElementById(`cell-${myBoard[i]}`)).filter(Boolean);
      triggerLineBurst(els);
    });
    fireLineFlash();
    sfx.cross && sfx.cross();
  }

  if (lines >= 5) {
    update(ref(db, `rooms/${roomId}/gameState`), {winner: playerRole});
    scheduleRoomCleanup(); // ← delete Firebase data 15 s after win is declared
  }
}

/* ═══════════════════════════════════════════════
   WIN OVERLAY
═══════════════════════════════════════════════ */
const winPhrases =['Domination! 👑','Flawless Victory! ⚡','You\'re on fire! 🔥','GG! Absolutely lethal 🎯','Champion energy! 💎'];
const losePhrases=['So close… Try again 💪','Next time you\'ll have it!','Respect the grind 🤝'];
function showWinOverlay(iWon, wasAbandoned){
  iWon?sfx.win():sfx.lose();
  if (wasAbandoned && iWon) {
    document.getElementById('win-title-text').textContent = '🏆 YOU WIN!';
    document.getElementById('win-subtitle-text').textContent = '🏃 Opponent fled the arena!';
  } else if (wasAbandoned && !iWon) {
    document.getElementById('win-title-text').textContent = '😔 YOU LEFT';
    document.getElementById('win-subtitle-text').textContent = 'Opponent claimed the victory.';
  } else {
    document.getElementById('win-title-text').textContent=iWon?'🎉 YOU WIN!':'😢 YOU LOSE';
    document.getElementById('win-subtitle-text').textContent=iWon
      ?winPhrases[Math.floor(Math.random()*winPhrases.length)]
      :losePhrases[Math.floor(Math.random()*losePhrases.length)];
  }
  document.getElementById('win-overlay').classList.add('show');
  if(iWon){ launchWinAnimation(); recordWin(); } else { recordLoss(); }
  updateScoreDisplay();
}

/* ─── Rematch countdown ───────────────────────── */
/* auto-rematch countdown removed — players use Restart / Exit buttons manually */

/* ─── Confetti ────────────────────────────────── */
function launchConfetti(){
  const canvas=document.getElementById('confetti-canvas'),ctx=canvas.getContext('2d');
  canvas.width=window.innerWidth; canvas.height=window.innerHeight;
  const cols=['#00e5ff','#ff3cac','#ffd166','#06ffa5','#ffffff','#ff6b6b'];
  const pieces=Array.from({length:200},()=>({
    x:Math.random()*canvas.width,y:Math.random()*canvas.height-canvas.height,
    w:6+Math.random()*8,h:10+Math.random()*14,
    c:cols[Math.floor(Math.random()*cols.length)],
    r:Math.random()*Math.PI*2,rd:(Math.random()-.5)*.2,
    vy:3+Math.random()*5,vx:(Math.random()-.5)*3
  }));
  let frame;
  (function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    pieces.forEach(p=>{
      p.y+=p.vy;p.x+=p.vx;p.r+=p.rd;p.vy+=.08;
      if(p.y>canvas.height){p.y=-20;p.x=Math.random()*canvas.width}
      ctx.save();ctx.translate(p.x+p.w/2,p.y+p.h/2);ctx.rotate(p.r);
      ctx.fillStyle=p.c;ctx.globalAlpha=.85;ctx.fillRect(-p.w/2,-p.h/2,p.w,p.h);ctx.restore();
    });
    frame=requestAnimationFrame(draw);
  })();
  setTimeout(()=>{cancelAnimationFrame(frame);ctx.clearRect(0,0,canvas.width,canvas.height)},5000);
}

/* ═══════════════════════════════════════════════
   FEATURE 11 — WIN ANIMATIONS
   Player picks their celebration style in stats popup
═══════════════════════════════════════════════ */
let selectedWinAnim = localStorage.getItem('winAnim') || 'confetti';

const WIN_ANIMS = [
  { id:'confetti',  emoji:'🎊', label:'Confetti' },
  { id:'lightning', emoji:'⚡', label:'Lightning' },
  { id:'fire',      emoji:'🔥', label:'Fire' },
  { id:'diamond',   emoji:'💎', label:'Diamond' },
];

function renderWinAnimPicker() {
  const row = document.getElementById('win-anim-row');
  if (!row) return;
  row.innerHTML = '';
  WIN_ANIMS.forEach(a => {
    const el = document.createElement('div');
    el.className = 'win-anim-opt' + (selectedWinAnim === a.id ? ' active' : '');
    el.innerHTML = `${a.emoji}<span>${a.label}</span>`;
    el.addEventListener('click', () => {
      selectedWinAnim = a.id;
      localStorage.setItem('winAnim', a.id);
      row.querySelectorAll('.win-anim-opt').forEach(x => x.classList.remove('active'));
      el.classList.add('active');
    });
    row.appendChild(el);
  });
}

function launchWinAnimation() {
  if      (selectedWinAnim === 'confetti')  launchConfetti();
  else if (selectedWinAnim === 'lightning') launchLightning();
  else if (selectedWinAnim === 'fire')      launchFire();
  else if (selectedWinAnim === 'diamond')   launchDiamond();
}

function launchLightning() {
  const canvas = document.getElementById('lightning-canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = window.innerWidth; canvas.height = window.innerHeight;
  canvas.style.display = 'block';
  let t = 0;
  function bolt(x1,y1,x2,y2,depth){
    if(depth===0){ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.stroke();return;}
    const mx=(x1+x2)/2+(Math.random()-.5)*60;
    const my=(y1+y2)/2+(Math.random()-.5)*60;
    bolt(x1,y1,mx,my,depth-1); bolt(mx,my,x2,y2,depth-1);
  }
  let frame;
  (function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if(t<12){
      ctx.strokeStyle=`rgba(255,220,0,${0.9-t*0.04})`;
      ctx.lineWidth=3-t*0.15; ctx.shadowBlur=20; ctx.shadowColor='#ffcc00';
      for(let i=0;i<3;i++) bolt(Math.random()*canvas.width,0,Math.random()*canvas.width,canvas.height,4);
      t++; frame=requestAnimationFrame(draw);
    } else {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      canvas.style.display='none';
    }
  })();
}

function launchFire() {
  const canvas = document.getElementById('fire-canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = window.innerWidth; canvas.height = window.innerHeight;
  canvas.style.display = 'block';
  const particles = Array.from({length:120},()=>({
    x: Math.random()*canvas.width,
    y: canvas.height + 20,
    vx: (Math.random()-.5)*3,
    vy: -(4+Math.random()*6),
    size: 8+Math.random()*16,
    life: 1,
    decay: 0.015+Math.random()*0.02,
  }));
  let frame;
  (function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    let alive = false;
    particles.forEach(p=>{
      p.x+=p.vx; p.y+=p.vy; p.vy*=0.98; p.life-=p.decay;
      if(p.life>0){
        alive=true;
        const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.size);
        g.addColorStop(0,`rgba(255,230,50,${p.life})`);
        g.addColorStop(0.4,`rgba(255,80,0,${p.life*0.8})`);
        g.addColorStop(1,`rgba(255,0,0,0)`);
        ctx.fillStyle=g;
        ctx.beginPath();ctx.arc(p.x,p.y,p.size,0,Math.PI*2);ctx.fill();
      }
    });
    if(alive) frame=requestAnimationFrame(draw);
    else { ctx.clearRect(0,0,canvas.width,canvas.height); canvas.style.display='none'; }
  })();
}

function launchDiamond() {
  const canvas = document.getElementById('diamond-canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = window.innerWidth; canvas.height = window.innerHeight;
  canvas.style.display = 'block';
  const gems = Array.from({length:40},()=>({
    x: Math.random()*canvas.width,
    y: Math.random()*canvas.height,
    size: 8+Math.random()*18,
    angle: Math.random()*Math.PI*2,
    vr: (Math.random()-.5)*0.1,
    vx: (Math.random()-.5)*4,
    vy: (Math.random()-.5)*4,
    life: 1,
    decay: 0.008+Math.random()*0.01,
    hue: [180,300,200,60][Math.floor(Math.random()*4)],
  }));
  let frame;
  function drawGem(x,y,s,angle,alpha,hue){
    ctx.save(); ctx.translate(x,y); ctx.rotate(angle);
    ctx.globalAlpha=alpha;
    ctx.fillStyle=`hsl(${hue},100%,75%)`; ctx.strokeStyle=`hsl(${hue},100%,90%)`;
    ctx.shadowBlur=12; ctx.shadowColor=`hsl(${hue},100%,70%)`;
    ctx.beginPath();
    ctx.moveTo(0,-s);ctx.lineTo(s*0.6,-s*0.3);ctx.lineTo(s*0.6,s*0.3);
    ctx.lineTo(0,s);ctx.lineTo(-s*0.6,s*0.3);ctx.lineTo(-s*0.6,-s*0.3);ctx.closePath();
    ctx.fill(); ctx.lineWidth=1.5; ctx.stroke();
    ctx.restore();
  }
  (function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    let alive=false;
    gems.forEach(g=>{
      g.x+=g.vx; g.y+=g.vy; g.angle+=g.vr; g.life-=g.decay;
      if(g.life>0){ alive=true; drawGem(g.x,g.y,g.size,g.angle,g.life,g.hue); }
    });
    if(alive) frame=requestAnimationFrame(draw);
    else { ctx.clearRect(0,0,canvas.width,canvas.height); canvas.style.display='none'; }
  })();
}

/* ═══════════════════════════════════════════════
   FEATURE 6 — PERSONAL STATS
   Stored in localStorage — zero Firebase cost
═══════════════════════════════════════════════ */
function loadStats() {
  return JSON.parse(localStorage.getItem('dingo_stats') || '{"played":0,"wins":0,"losses":0}');
}
function saveStats(s) { localStorage.setItem('dingo_stats', JSON.stringify(s)); }
function recordWin()  { const s=loadStats(); s.played++; s.wins++;    saveStats(s); }
function recordLoss() { const s=loadStats(); s.played++; s.losses++;  saveStats(s); }

function openStatsPopup() {
  const d = window.DINGO || {};
  const s = loadStats();
  renderAvatar(document.getElementById('stats-avatar'), d.selectedAvatar || AVATAR_DEFS[0].svg);
  document.getElementById('stats-name').textContent    = d.playerName     || 'Player';
  document.getElementById('stats-color-dot').style.background = d.selectedColor || '#00e5ff';
  document.getElementById('stats-color-label').textContent    = d.selectedColor || '#00e5ff';
  document.getElementById('stat-played').textContent   = s.played;
  document.getElementById('stat-wins').textContent     = s.wins;
  document.getElementById('stat-losses').textContent   = s.losses;
  const wr = s.played > 0 ? Math.round(s.wins/s.played*100) : 0;
  document.getElementById('stat-winrate').textContent  = wr + '%';
  renderWinAnimPicker();
  document.getElementById('stats-popup').classList.add('show');
}

document.getElementById('home-avatar-display').addEventListener('click', openStatsPopup);
document.getElementById('stats-close-btn').addEventListener('click', () => {
  document.getElementById('stats-popup').classList.remove('show');
});
document.getElementById('stats-reset-btn').addEventListener('click', () => {
  if(confirm('Reset all stats?')){ saveStats({played:0,wins:0,losses:0}); openStatsPopup(); }
});

/* ═══════════════════════════════════════════════
   FEATURE 12 — PLAYER CARD
═══════════════════════════════════════════════ */
const RANK_TITLES = ['Rookie','Arena Fighter','Champion','Legend','DiNGo Master'];
function getRankTitle() {
  const s = loadStats();
  if(s.wins >= 50) return RANK_TITLES[4];
  if(s.wins >= 20) return RANK_TITLES[3];
  if(s.wins >= 10) return RANK_TITLES[2];
  if(s.wins >= 3)  return RANK_TITLES[1];
  return RANK_TITLES[0];
}

function openPlayerCard() {
  const d = window.DINGO || {};
  const color = d.selectedColor || '#00e5ff';
  renderAvatar(document.getElementById('pc-avatar'), d.selectedAvatar || AVATAR_DEFS[0].svg);
  document.getElementById('pc-name').textContent   = d.playerName    || 'Player';
  document.getElementById('pc-color-bar').style.background = color;
  document.getElementById('pc-badge').textContent  = getRankTitle();
  document.getElementById('pc-badge').style.background   = color + '22';
  document.getElementById('pc-badge').style.color        = color;
  document.getElementById('pc-badge').style.borderColor  = color + '55';
  document.getElementById('player-card-popup').classList.add('show');
}

document.getElementById('show-card-btn').addEventListener('click', openPlayerCard);
document.getElementById('pc-close-btn').addEventListener('click', () => {
  document.getElementById('player-card-popup').classList.remove('show');
});
document.getElementById('pc-share-btn').addEventListener('click', () => {
  if(navigator.share){
    navigator.share({ title:'DiNGo Player Card', text:`Check out my DiNGo card! I'm a ${getRankTitle()} 🎯`, url: window.location.href });
  } else {
    alert('📋 Copy this link to share:\n' + window.location.href);
  }
});

/* ═══════════════════════════════════════════════
   FEATURE 9 — BOARD THEMES
═══════════════════════════════════════════════ */
const BOARD_THEMES = [
  { id:'default', name:'Neon',   bg:'#0d0d0f', cell:'#00ffcc', win:'#ffcc00' },
  { id:'retro',   name:'Retro',  bg:'#001100', cell:'#00ff00', win:'#ffff00' },
  { id:'ice',     name:'Ice',    bg:'#050d1a', cell:'#7ee8ff', win:'#b8f0ff' },
  { id:'fire',    name:'Fire',   bg:'#1a0500', cell:'#ff6a00', win:'#ffcc00' },
  { id:'purple',  name:'Void',   bg:'#0a0014', cell:'#bf7aff', win:'#ff7aff' },
  { id:'rose',    name:'Rose',   bg:'#1a000a', cell:'#ff6eb4', win:'#ffd6ec' },
];
let activeTheme = localStorage.getItem('boardTheme') || 'default';

function buildThemeGrid() {
  const grid = document.getElementById('theme-grid');
  if(!grid) return;
  grid.innerHTML='';
  BOARD_THEMES.forEach(t => {
    const opt = document.createElement('div');
    opt.className = 'theme-opt' + (activeTheme===t.id?' active':'');
    const preview = document.createElement('div');
    preview.className='theme-opt-preview';
    preview.style.background=t.bg;
    for(let i=0;i<25;i++){
      const c=document.createElement('div');
      c.className='tp-cell';
      const winCells=[6,7,8,11,12];
      c.style.background=winCells.includes(i)?t.win+'55':t.cell+'22';
      c.style.border=`1px solid ${winCells.includes(i)?t.win+'88':t.cell+'44'}`;
      preview.appendChild(c);
    }
    opt.appendChild(preview);
    const lbl=document.createElement('div');
    lbl.className='theme-opt-name'; lbl.textContent=t.name;
    opt.appendChild(lbl);
    opt.addEventListener('click',()=>{
      activeTheme=t.id; localStorage.setItem('boardTheme',t.id);
      applyBoardTheme(t.id);
      grid.querySelectorAll('.theme-opt').forEach(x=>x.classList.remove('active'));
      opt.classList.add('active');
    });
    grid.appendChild(opt);
  });
}

function applyBoardTheme(id) {
  BOARD_THEMES.forEach(t=>document.body.classList.remove('theme-'+t.id));
  if(id!=='default') document.body.classList.add('theme-'+id);
}

document.getElementById('theme-picker-btn').addEventListener('click',()=>{
  buildThemeGrid();
  document.getElementById('theme-picker-modal').classList.add('show');
});
document.getElementById('theme-modal-close').addEventListener('click',()=>{
  document.getElementById('theme-picker-modal').classList.remove('show');
});
// Apply saved theme on load
applyBoardTheme(activeTheme);

/* ═══════════════════════════════════════════════
   FEATURE 10 — BACKGROUND MUSIC  (5 relaxing tracks)
   All audio is synthesized via Web Audio API — no files needed.
   Each track is a self-contained composer function that schedules
   notes/pads/bass into a shared AudioContext and loops seamlessly.
═══════════════════════════════════════════════ */
let musicAudioCtx = null, musicPlaying = false, musicNodes = [], musicTrack = 0;

/* ── 5 named tracks ───────────────────────────────────────────────────────── */
const MUSIC_TRACKS = [
  { name: 'Ocean Drift',   fn: 'composeOceanDrift'   },
  { name: 'Lo-Fi Chill',   fn: 'composeLoFiChill'    },
  { name: 'Neon Night',    fn: 'composeNeonNight'     },
  { name: 'Pixel Rain',    fn: 'composePixelRain'     },
  { name: 'Forest Hum',    fn: 'composeForestHum'     },
];

function getMusicCtx() {
  if (!musicAudioCtx) musicAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (musicAudioCtx.state === 'suspended') musicAudioCtx.resume();
  return musicAudioCtx;
}

function updateMusicUI() {
  const playBtn = document.getElementById('music-play-btn');
  const toggleBtn = document.getElementById('music-toggle-btn');
  const trackName = document.getElementById('music-track-name');
  const styleBtn  = document.getElementById('music-style-btn');
  if (playBtn)   playBtn.textContent  = musicPlaying ? '⏸' : '▶';
  if (toggleBtn) { toggleBtn.innerHTML = musicPlaying ? '⏸' : '🎵'; toggleBtn.classList.toggle('playing', musicPlaying); }
  if (trackName) trackName.textContent = MUSIC_TRACKS[musicTrack].name;
  if (styleBtn)  styleBtn.textContent  = MUSIC_TRACKS[musicTrack].name;
}

function stopMusic() {
  musicNodes.forEach(n => { try { n.stop(); } catch(e){} try { n.disconnect(); } catch(e){} });
  musicNodes = [];
  musicPlaying = false;
  updateMusicUI();
}

function playMusic() {
  stopMusic();
  try {
    const ctx = getMusicCtx();
    const composerName = MUSIC_TRACKS[musicTrack].fn;
    window[composerName](ctx);   // each composer pushes its nodes into musicNodes
    musicPlaying = true;
    updateMusicUI();
  } catch(e) {
    console.warn('Music error:', e);
    musicPlaying = false;
    updateMusicUI();
  }
}

/* ── Shared helpers ─────────────────────────────────────────────────────────
   makeGain  : create a GainNode and connect it to a destination
   makeOsc   : create a scheduled oscillator through a gain node
   schedLoop : schedule N bars of notes and re-call playMusic when done
──────────────────────────────────────────────────────────────────────────── */
function makeGain(ctx, val, dest) {
  const g = ctx.createGain();
  g.gain.value = val;
  g.connect(dest || ctx.destination);
  musicNodes.push(g);
  return g;
}

function schedNote(ctx, dest, freq, t, dur, type='sine', vol=0.18) {
  const osc  = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  gain.gain.setValueAtTime(0, t);
  gain.gain.linearRampToValueAtTime(vol, t + 0.015);
  gain.gain.exponentialRampToValueAtTime(0.0001, t + dur * 0.92);
  osc.connect(gain); gain.connect(dest);
  osc.start(t); osc.stop(t + dur);
  musicNodes.push(osc); musicNodes.push(gain);
}

function schedLoop(ctx, durationSec) {
  // When the track finishes, restart if still in "playing" state
  const tid = setTimeout(() => { if (musicPlaying) playMusic(); }, (durationSec + 0.2) * 1000);
  musicNodes.push({ stop: () => clearTimeout(tid), disconnect: () => {} });
}

/* ══════════════════════════════════════════════════════════════════════════
   TRACK 1 — Ocean Drift
   Slow, ambient pads built from detuned sine waves in C-major pentatonic.
   A gentle reverb-like effect is created by stacking 3 slightly detuned
   oscillators per note (a classic "chorus pad" technique).
══════════════════════════════════════════════════════════════════════════ */
function composeOceanDrift(ctx) {
  const master = makeGain(ctx, 0.18);
  // C-major pentatonic: C3 D3 E3 G3 A3 C4 D4 E4
  const freqs = [130.81, 146.83, 164.81, 196.00, 220.00, 261.63, 293.66, 329.63];
  const chord1 = [0, 2, 4];   // C E G
  const chord2 = [1, 4, 5];   // D A C
  const barsec = 3.6;          // very slow
  const bars   = 8;

  for (let b = 0; b < bars; b++) {
    const chord = b % 2 === 0 ? chord1 : chord2;
    const t = ctx.currentTime + b * barsec;
    chord.forEach((idx, i) => {
      const f = freqs[idx];
      // Stacked detuned sines = warm pad
      [-3, 0, 3].forEach(detune => {
        const osc  = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = f * Math.pow(2, detune / 1200);
        gain.gain.setValueAtTime(0, t + i * 0.08);
        gain.gain.linearRampToValueAtTime(0.12, t + i * 0.08 + 0.6);
        gain.gain.linearRampToValueAtTime(0.08, t + barsec - 0.4);
        gain.gain.linearRampToValueAtTime(0.0001, t + barsec);
        osc.connect(gain); gain.connect(master);
        osc.start(t + i * 0.08); osc.stop(t + barsec + 0.1);
        musicNodes.push(osc); musicNodes.push(gain);
      });
    });
    // Low sub bass pulse
    schedNote(ctx, master, freqs[chord[0]] / 2, t + 0.1, barsec * 0.4, 'sine', 0.22);
  }

  schedLoop(ctx, bars * barsec);
}

/* ══════════════════════════════════════════════════════════════════════════
   TRACK 2 — Lo-Fi Chill
   Classic lo-fi formula: soft muted piano notes (triangle wave), lazy drum
   hits (short noise bursts), and a warm bass line.  Tempo: 78 BPM.
══════════════════════════════════════════════════════════════════════════ */
function composeLoFiChill(ctx) {
  const master = makeGain(ctx, 0.15);
  const bpm    = 78;
  const beat   = 60 / bpm;
  const bars   = 16;  // 16 beats
  const dur    = bars * beat;

  // Chord voicings (Fmaj7 → Am7 → Dm7 → Cmaj7) in Hz — each lasts 4 beats
  const chords = [
    [174.61, 220.00, 261.63, 349.23],   // Fmaj7
    [220.00, 261.63, 329.63, 440.00],   // Am7
    [146.83, 174.61, 220.00, 293.66],   // Dm7
    [130.81, 164.81, 196.00, 261.63],   // Cmaj7
  ];

  // Piano notes — two notes per beat, alternating chords
  chords.forEach((ch, ci) => {
    const chStart = ctx.currentTime + ci * 4 * beat;
    ch.forEach((f, ni) => {
      schedNote(ctx, master, f,         chStart + ni * 0.06,          beat * 3.8, 'triangle', 0.14);
      schedNote(ctx, master, f * 0.999, chStart + ni * 0.06 + 0.025,  beat * 3.6, 'triangle', 0.08);
    });
  });

  // Bass: root of each chord, quarter notes
  const roots = [87.31, 110.00, 73.42, 65.41];
  roots.forEach((r, ci) => {
    for (let b = 0; b < 4; b++) {
      const t = ctx.currentTime + (ci * 4 + b) * beat;
      schedNote(ctx, master, r, t, beat * 0.7, 'sine', 0.28);
    }
  });

  // Lo-fi drum hits: kick (low thud) + snare (noise burst)
  for (let b = 0; b < bars; b++) {
    const t = ctx.currentTime + b * beat;
    // Kick on beats 1 & 3 (0, 2, 4, 6 ...)
    if (b % 4 === 0 || b % 4 === 2) {
      const osc = ctx.createOscillator(); const g = ctx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(120, t);
      osc.frequency.exponentialRampToValueAtTime(40, t + 0.08);
      g.gain.setValueAtTime(0.35, t);
      g.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
      osc.connect(g); g.connect(master);
      osc.start(t); osc.stop(t + 0.15);
      musicNodes.push(osc); musicNodes.push(g);
    }
    // Snare on beats 2 & 4
    if (b % 4 === 1 || b % 4 === 3) {
      const buf = ctx.createBuffer(1, ctx.sampleRate * 0.08, ctx.sampleRate);
      const d   = buf.getChannelData(0);
      for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * 0.4;
      const src = ctx.createBufferSource(); const g = ctx.createGain();
      src.buffer = buf;
      g.gain.setValueAtTime(0.18, t);
      g.gain.exponentialRampToValueAtTime(0.001, t + 0.07);
      src.connect(g); g.connect(master);
      src.start(t);
      musicNodes.push(src); musicNodes.push(g);
    }
  }

  schedLoop(ctx, dur);
}

/* ══════════════════════════════════════════════════════════════════════════
   TRACK 3 — Neon Night
   Slow synthwave: arpeggiated sawtooth chords over a pulsing bass and
   a gentle high-pass filtered hi-hat.  Tempo: 95 BPM.
══════════════════════════════════════════════════════════════════════════ */
function composeNeonNight(ctx) {
  const master = makeGain(ctx, 0.13);
  // Low-pass filter for warmth
  const lpf = ctx.createBiquadFilter();
  lpf.type = 'lowpass'; lpf.frequency.value = 2800; lpf.Q.value = 0.8;
  lpf.connect(master);

  const bpm  = 95;
  const beat = 60 / bpm;
  const bars = 16;

  // Arpeggios — Am pentatonic descending
  const arp = [440, 392, 329.63, 261.63, 220, 196, 164.81, 130.81];
  for (let i = 0; i < bars * 2; i++) {
    const f = arp[i % arp.length];
    const t = ctx.currentTime + i * beat * 0.5;
    const osc  = ctx.createOscillator(); const g = ctx.createGain();
    osc.type = 'sawtooth'; osc.frequency.value = f;
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.18, t + 0.02);
    g.gain.exponentialRampToValueAtTime(0.001, t + beat * 0.45);
    osc.connect(g); g.connect(lpf);
    osc.start(t); osc.stop(t + beat * 0.5);
    musicNodes.push(osc); musicNodes.push(g);
  }

  // Pulsing bass (one note per 2 beats)
  const bassLine = [55, 55, 65.41, 55, 49, 55, 65.41, 49];
  bassLine.forEach((f, i) => {
    const t = ctx.currentTime + i * beat * 2;
    schedNote(ctx, master, f, t, beat * 1.7, 'sine', 0.32);
  });

  // Pad chord swell every 4 beats
  [[110, 138.59, 164.81], [98, 123.47, 146.83]].forEach((ch, ci) => {
    ch.forEach(f => {
      const t = ctx.currentTime + ci * beat * 8;
      const osc = ctx.createOscillator(); const g = ctx.createGain();
      osc.type = 'triangle'; osc.frequency.value = f;
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(0.07, t + 1.5);
      g.gain.linearRampToValueAtTime(0.0001, t + beat * 8 - 0.3);
      osc.connect(g); g.connect(lpf);
      osc.start(t); osc.stop(t + beat * 8);
      musicNodes.push(osc); musicNodes.push(g);
    });
  });

  schedLoop(ctx, bars * beat);
}

/* ══════════════════════════════════════════════════════════════════════════
   TRACK 4 — Pixel Rain
   Calm chiptune: square-wave melody in G-major pentatonic with a
   light pulse bass.  Quiet and meditative.  Tempo: 90 BPM.
══════════════════════════════════════════════════════════════════════════ */
function composePixelRain(ctx) {
  const master = makeGain(ctx, 0.10);
  const bpm    = 90;
  const beat   = 60 / bpm;

  // G-major pentatonic: G4 A4 B4 D5 E5 G5
  const scale = [392, 440, 493.88, 587.33, 659.25, 783.99];
  // A gentle melody — pattern over 16 beats
  const melody = [0,2,4,2, 1,3,5,3, 2,4,3,1, 0,2,1,null];
  melody.forEach((idx, b) => {
    if (idx === null) return;
    const t = ctx.currentTime + b * beat;
    schedNote(ctx, master, scale[idx], t, beat * 0.55, 'square', 0.12);
    // Harmony a third below on alternate beats
    if (b % 2 === 0 && idx >= 2) {
      schedNote(ctx, master, scale[idx - 2], t + 0.01, beat * 0.45, 'square', 0.06);
    }
  });

  // Bass: root notes, half notes
  [196, 220, 196, 174.61].forEach((f, i) => {
    const t = ctx.currentTime + i * beat * 4;
    schedNote(ctx, master, f, t, beat * 3.6, 'sine', 0.22);
  });

  schedLoop(ctx, 16 * beat);
}

/* ══════════════════════════════════════════════════════════════════════════
   TRACK 5 — Forest Hum
   Ambient drone: overlapping sine tones tuned to natural harmonics (C2 and
   its 3rd, 5th, 7th, 9th) that shift slowly in volume, creating the organic
   swelling texture of insects and distant wind.
══════════════════════════════════════════════════════════════════════════ */
function composeForestHum(ctx) {
  const master = makeGain(ctx, 0.14);
  const root = 65.41; // C2
  // Natural harmonic series
  const harmonics = [1, 1.5, 2, 2.5, 3, 4, 5, 6].map(h => root * h);
  const totalDur  = 28;

  harmonics.forEach((f, i) => {
    const delay  = i * 0.9;
    const dur    = totalDur - delay;
    const osc    = ctx.createOscillator();
    const gain   = ctx.createGain();
    osc.type     = 'sine';
    osc.frequency.value = f;
    // Each harmonic swells in and out at a slightly different phase
    const t0 = ctx.currentTime + delay;
    gain.gain.setValueAtTime(0, t0);
    gain.gain.linearRampToValueAtTime(0.06 / (1 + i * 0.4), t0 + dur * 0.3);
    gain.gain.linearRampToValueAtTime(0.03 / (1 + i * 0.4), t0 + dur * 0.6);
    gain.gain.linearRampToValueAtTime(0.0001, t0 + dur - 0.3);
    osc.connect(gain); gain.connect(master);
    osc.start(t0); osc.stop(t0 + dur);
    musicNodes.push(osc); musicNodes.push(gain);
  });

  // Random bird-like trill notes (triangle, very soft)
  for (let i = 0; i < 8; i++) {
    const t = ctx.currentTime + 2 + i * 3.2 + Math.random() * 1.5;
    const f = [880, 1047, 1174.66, 1318.51][Math.floor(Math.random() * 4)];
    schedNote(ctx, master, f, t, 0.08, 'triangle', 0.04);
    schedNote(ctx, master, f * 1.125, t + 0.09, 0.07, 'triangle', 0.03);
  }

  schedLoop(ctx, totalDur);
}

/* ── Toolbar button: toggle panel + auto-start first track ─────────────── */
document.getElementById('music-toggle-btn').addEventListener('click', () => {
  const panel = document.getElementById('music-panel');
  if (!panel) return;
  const isShown = panel.style.display === 'flex';
  panel.style.display = isShown ? 'none' : 'flex';
  if (!isShown && !musicPlaying) playMusic();
  else if (isShown && musicPlaying) stopMusic();
});
document.getElementById('music-play-btn').addEventListener('click', () => {
  if (musicPlaying) stopMusic(); else playMusic();
});
document.getElementById('music-prev-btn').addEventListener('click', () => {
  musicTrack = (musicTrack - 1 + MUSIC_TRACKS.length) % MUSIC_TRACKS.length;
  if (musicPlaying) playMusic(); else updateMusicUI();
});
document.getElementById('music-next-btn').addEventListener('click', () => {
  musicTrack = (musicTrack + 1) % MUSIC_TRACKS.length;
  if (musicPlaying) playMusic(); else updateMusicUI();
});
document.getElementById('music-style-btn').addEventListener('click', () => {
  musicTrack = (musicTrack + 1) % MUSIC_TRACKS.length;
  if (musicPlaying) playMusic(); else updateMusicUI();
});
/* ═══════════════════════════════════════════════
   FEATURE 14 — GAME HISTORY
   Records every completed match locally and displays
   in a popup with opponent name, result, date, and
   a quick "Add Friend" button.
═══════════════════════════════════════════════ */

/* -- Storage helpers ---------------------------------------------------- */
const HISTORY_KEY = 'dingo_history';
function loadHistory() {
  try { return JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]'); } catch(e) { return []; }
}
function saveHistory(arr) {
  // Keep only the 50 most recent entries to avoid bloat
  localStorage.setItem(HISTORY_KEY, JSON.stringify(arr.slice(-50)));
}

/* _currentOpponent: filled in during multiplayer setup so that
   recordWin/recordLoss can embed opponent info in the history entry. */
let _currentOpponent = null; // { name, username, avatar }

/* Call this once opponent's playerInfo is known (after Firebase playerInfo update) */
function setCurrentOpponent(name, username, avatar) {
  _currentOpponent = { name: name || 'Unknown', username: username || '', avatar: avatar || '' };
}

/* Augment the existing recordWin / recordLoss helpers -------------------- */
const _origRecordWin  = recordWin;
const _origRecordLoss = recordLoss;

// Override recordWin to also log the history entry
recordWin = function() {
  _origRecordWin();
  addHistoryEntry('win');
};
recordLoss = function() {
  _origRecordLoss();
  addHistoryEntry('loss');
};

function addHistoryEntry(result) {
  const history = loadHistory();
  history.push({
    result,
    opponent: _currentOpponent ? { ..._currentOpponent } : null,
    ts: Date.now()
  });
  saveHistory(history);
  _currentOpponent = null; // reset after recording
}

/* -- Render history popup ----------------------------------------------- */
function openHistoryPopup() {
  const history = loadHistory().reverse(); // most recent first
  const list    = document.getElementById('history-list');
  const myProfile = loadProfile();

  if (!history.length) {
    list.innerHTML = '<div style="text-align:center;color:var(--ink3);font-size:12px;padding:20px 0">No matches played yet — go win some! 🎯</div>';
  } else {
    list.innerHTML = '';
    history.forEach(entry => {
      const won   = entry.result === 'win';
      const opp   = entry.opponent;
      const date  = entry.ts ? new Date(entry.ts).toLocaleDateString(undefined, { month:'short', day:'numeric', hour:'2-digit', minute:'2-digit' }) : '—';

      // Build avatar HTML safely (SVG vs emoji)
      let avHtml = '<span style="font-size:22px">👤</span>';
      if (opp && opp.avatar) {
        avHtml = opp.avatar.trim().startsWith('<svg')
          ? `<span style="display:inline-block;width:28px;height:28px;border-radius:6px;overflow:hidden;vertical-align:middle">${opp.avatar}</span>`
          : `<span style="font-size:22px">${opp.avatar}</span>`;
      }

      const card = document.createElement('div');
      card.style.cssText = `
        display:flex;align-items:center;gap:10px;
        background:var(--panel2);border:2px solid ${won ? 'rgba(0,229,255,.3)' : 'rgba(255,60,100,.25)'};
        border-radius:var(--r);padding:9px 11px;margin-bottom:7px;
      `;
      card.innerHTML = `
        <div style="flex-shrink:0">${avHtml}</div>
        <div style="flex:1;min-width:0">
          <div style="font-weight:700;font-size:13px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">
            ${opp ? (opp.name || 'Unknown') : 'vs Bot'}
          </div>
          <div style="font-size:10px;color:var(--ink3)">${opp && opp.username ? '@' + opp.username : ''} · ${date}</div>
        </div>
        <div style="display:flex;flex-direction:column;align-items:flex-end;gap:5px;flex-shrink:0">
          <div style="font-size:11px;font-weight:800;letter-spacing:1px;
            color:${won ? 'var(--c1)' : 'var(--c2)'};
            background:${won ? 'rgba(0,229,255,.1)' : 'rgba(255,60,100,.1)'};
            border-radius:4px;padding:2px 7px">
            ${won ? '🏆 WIN' : '💀 LOSS'}
          </div>
          ${(opp && opp.username && myProfile && opp.username !== myProfile.username)
            ? `<button class="btn btn-ghost hist-add-btn"
                 data-username="${opp.username}"
                 data-name="${(opp.name||'').replace(/"/g,'&quot;')}"
                 data-avatar="${opp.avatar ? 'svg' : ''}"
                 style="font-size:9px;padding:2px 8px;border-color:rgba(0,229,255,.3);color:var(--c5)">
                 ＋ Friend
               </button>`
            : ''}
        </div>
      `;
      // Attach friend request button safely
      const addBtn = card.querySelector('.hist-add-btn');
      if (addBtn) {
        addBtn.addEventListener('click', async () => {
          const u = addBtn.dataset.username;
          const n = addBtn.dataset.name;
          const av = opp && opp.avatar ? opp.avatar : '';
          await sendFriendRequest(u, n, av);
          addBtn.textContent = '✓ Sent';
          addBtn.disabled = true;
          addBtn.style.opacity = '0.5';
        });
      }
      list.appendChild(card);
    });
  }

  document.getElementById('history-popup').style.display  = 'block';
  document.getElementById('history-overlay').style.display = 'block';
}

function closeHistoryPopup() {
  document.getElementById('history-popup').style.display  = 'none';
  document.getElementById('history-overlay').style.display = 'none';
}

/* sendFriendRequest: reusable — sends a request to Firebase */
async function sendFriendRequest(toUsername, toName, toAvatar) {
  const myProfile = loadProfile();
  if (!myProfile || !myProfile.username) return;
  if (toUsername === myProfile.username) return;
  await db.ref('friendRequests/' + toUsername + '/' + myProfile.username).set({
    from:   myProfile.username,
    name:   myProfile.name   || myProfile.username,
    avatar: myProfile.avatar || '',
    status: 'pending',
    ts:     Date.now()
  });
}

/* Wire up history button and popup close actions */
document.getElementById('history-btn').addEventListener('click', openHistoryPopup);
document.getElementById('history-close-btn').addEventListener('click', closeHistoryPopup);
document.getElementById('history-overlay').addEventListener('click', closeHistoryPopup);


/* ═══════════════════════════════════════════════
   FEATURE 15 — MAILBOX (missed friend requests)
   Watches friendRequests/<myUsername> in Firebase.
   Any pending request that hasn't been acted on yet
   (status === 'pending') shows in the mailbox panel
   so players can accept/decline anytime, even after
   they return from being offline.
═══════════════════════════════════════════════ */

let _mailboxOpen = false;

function openMailbox() {
  const panel = document.getElementById('mailbox-panel');
  _mailboxOpen = true;
  panel.style.display = 'block';
  loadMailboxEntries();
}

function closeMailbox() {
  const panel = document.getElementById('mailbox-panel');
  _mailboxOpen = false;
  panel.style.display = 'none';
}

document.getElementById('mailbox-btn').addEventListener('click', () => {
  if (_mailboxOpen) { closeMailbox(); } else { openMailbox(); }
});

/* Watch for pending friend requests and update badge + live list */
function watchMailbox(myUsername) {
  if (!myUsername) return;
  db.ref('friendRequests/' + myUsername).on('value', snap => {
    const data   = snap.val() || {};
    const pending = Object.entries(data).filter(([,v]) => v && v.status === 'pending');
    const count  = pending.length;

    // Update badge
    const badge = document.getElementById('mailbox-badge');
    if (badge) {
      if (count > 0) {
        badge.style.display = 'flex';
        badge.textContent   = count > 9 ? '9+' : String(count);
      } else {
        badge.style.display = 'none';
      }
    }

    // If panel is open, refresh it live
    if (_mailboxOpen) loadMailboxEntries();
  });
}

/* Render all pending requests into the mailbox panel */
async function loadMailboxEntries() {
  const myProfile = loadProfile();
  const listEl    = document.getElementById('mailbox-list');
  if (!myProfile || !myProfile.username) {
    listEl.innerHTML = '<div style="font-size:11px;color:var(--ink3);text-align:center;padding:10px">Set up your profile first</div>';
    return;
  }

  const snap   = await db.ref('friendRequests/' + myProfile.username).get();
  const data   = snap.exists() ? snap.val() : {};
  const pending = Object.entries(data).filter(([,v]) => v && v.status === 'pending');

  if (!pending.length) {
    listEl.innerHTML = '<div style="font-size:11px;color:var(--ink3);text-align:center;padding:12px 0">No missed requests 👋</div>';
    return;
  }

  listEl.innerHTML = '';
  pending.forEach(([fromUsername, reqData]) => {
    const isSvg = reqData.avatar && reqData.avatar.trim().startsWith('<svg');
    const avHtml = isSvg
      ? `<span style="display:inline-block;width:24px;height:24px;border-radius:5px;overflow:hidden;vertical-align:middle;flex-shrink:0">${reqData.avatar}</span>`
      : `<span style="font-size:20px;flex-shrink:0">${reqData.avatar || '👤'}</span>`;

    const row = document.createElement('div');
    row.style.cssText = 'display:flex;align-items:center;gap:8px;margin-bottom:8px;padding:7px 8px;background:var(--panel);border:1px solid var(--edge);border-radius:var(--r)';
    row.innerHTML = `
      ${avHtml}
      <div style="flex:1;min-width:0">
        <div style="font-weight:700;font-size:12px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">${reqData.name || fromUsername}</div>
        <div style="font-size:10px;color:var(--ink3)">@${fromUsername}</div>
      </div>
      <div style="display:flex;gap:5px;flex-shrink:0">
        <button class="btn btn-primary mbox-accept" data-from="${fromUsername}"
          style="font-size:10px;padding:3px 10px">✓</button>
        <button class="btn btn-ghost mbox-decline" data-from="${fromUsername}"
          style="font-size:10px;padding:3px 10px">✕</button>
      </div>
    `;
    // Accept
    row.querySelector('.mbox-accept').addEventListener('click', async () => {
      const from = fromUsername;
      const mp   = loadProfile();
      if (!mp) return;
      await db.ref('friends/' + mp.username + '/' + from).set({
        name: reqData.name, avatar: reqData.avatar, username: from, online: false
      });
      await db.ref('friends/' + from + '/' + mp.username).set({
        name: mp.name, avatar: mp.avatar, username: mp.username, online: false
      });
      await db.ref('friendRequests/' + mp.username + '/' + from).remove();
      row.remove();
      // Refresh the live friends list if visible
      if (document.getElementById('friends-screen').classList.contains('active')) {
        renderFriendsList();
      }
      showToast('✓ ' + (reqData.name || from) + ' added as friend!', 2500);
    });
    // Decline
    row.querySelector('.mbox-decline').addEventListener('click', async () => {
      const mp = loadProfile();
      if (mp) await db.ref('friendRequests/' + mp.username + '/' + fromUsername).remove();
      row.remove();
    });
    listEl.appendChild(row);
  });
}

/* Small generic toast (reuse if exists, else make a simple one) */
function showToast(msg, ms) {
  let t = document.getElementById('generic-toast');
  if (!t) {
    t = document.createElement('div');
    t.id = 'generic-toast';
    t.style.cssText = 'position:fixed;bottom:130px;left:50%;transform:translateX(-50%);z-index:999;background:var(--panel);border:2px solid var(--c1);border-radius:20px;padding:8px 18px;font-size:12px;font-weight:700;color:var(--c1);pointer-events:none;transition:opacity .4s';
    document.body.appendChild(t);
  }
  t.textContent = msg;
  t.style.opacity = '1';
  clearTimeout(t._to);
  t._to = setTimeout(() => { t.style.opacity = '0'; }, ms || 2000);
}



/* ═══════════════════════════════════════════════
   FEATURE 13 — TOURNAMENT MODE
   Host creates 4-player bracket with a room code.
   All state stored in Firebase under tournaments/<code>
   Free-tier safe: small data, deleted after completion.
═══════════════════════════════════════════════ */
let tournCode='', tournRole='', tournData=null;

function genTournCode(){
  return Math.random().toString(36).slice(2,6).toUpperCase();
}

function showTournView(view){
  ['tourn-choice-view','tourn-host-view','tourn-join-view','tourn-bracket-view']
    .forEach(id=>{ const el=document.getElementById(id); if(el) el.style.display='none'; });
  const el=document.getElementById(view);
  if(el) el.style.display='block';
}

function renderTournSlots(players){
  const slots=document.getElementById('tourn-slots');
  if(!slots) return;
  slots.innerHTML='';
  const filled=Object.keys(players||{});
  for(let i=1;i<=4;i++){
    const p=players&&players['p'+i];
    const div=document.createElement('div');
    div.className='tourn-slot'+(p?' filled':'');
    div.innerHTML=`<span class="tourn-slot-num">${i}</span>
      <span class="tourn-slot-avatar">${p?p.avatar:'⬜'}</span>
      <span class="tourn-slot-name">${p?p.name:'Waiting…'}</span>
      <span class="tourn-slot-status">${p?'Ready':'—'}</span>`;
    slots.appendChild(div);
  }
  const count=filled.length;
  document.getElementById('tourn-status-bar').textContent=
    count>=4?'All players ready! Start when you\'re ready.':
    `${count}/4 players joined — waiting for ${4-count} more…`;
  const startBtn=document.getElementById('tourn-start-btn');
  if(startBtn) startBtn.disabled=count<4;
}

function renderTournBracket(data){
  const div=document.getElementById('tourn-bracket');
  if(!div||!data) return;
  div.innerHTML='';
  const sf=data.semiFinals||[];
  const fi=data.final||null;
  // Semi Finals
  const sfDiv=document.createElement('div'); sfDiv.className='bracket-round';
  sfDiv.innerHTML='<div class="bracket-round-label">Semi Finals</div>';
  sf.forEach((m,i)=>{
    const p1=data.players&&data.players[m.p1];
    const p2=data.players&&data.players[m.p2];
    const md=document.createElement('div');
    md.className='bracket-match'+(m.winner?'':' current');
    md.innerHTML=`<div class="bracket-player ${m.winner===m.p1?'winner':m.winner?'loser':''}">
        ${p1?p1.avatar:'?'} ${p1?p1.name:'TBD'}</div>
      <div class="bracket-vs">VS</div>
      <div class="bracket-player ${m.winner===m.p2?'winner':m.winner?'loser':''}">
        ${p2?p2.avatar:'?'} ${p2?p2.name:'TBD'}</div>`;
    sfDiv.appendChild(md);
  });
  div.appendChild(sfDiv);
  // Final
  if(fi){
    const fiDiv=document.createElement('div'); fiDiv.className='bracket-round';
    fiDiv.innerHTML='<div class="bracket-round-label">🏆 Final</div>';
    const p1=data.players&&fi.p1&&data.players[fi.p1];
    const p2=data.players&&fi.p2&&data.players[fi.p2];
    if(p1||p2){
      const md=document.createElement('div');
      md.className='bracket-match'+(fi.winner?'':' current');
      md.innerHTML=`<div class="bracket-player ${fi.winner===fi.p1?'winner':fi.winner?'loser':''}">
          ${p1?p1.avatar:'TBD'} ${p1?p1.name:'TBD'}</div>
        <div class="bracket-vs">VS</div>
        <div class="bracket-player ${fi.winner===fi.p2?'winner':fi.winner?'loser':''}">
          ${p2?p2.avatar:'TBD'} ${p2?p2.name:'TBD'}</div>`;
      fiDiv.appendChild(md);
    }
    div.appendChild(fiDiv);
    if(fi.winner&&data.players[fi.winner]){
      const champ=document.createElement('div');
      champ.style='text-align:center;padding:10px;font-family:"Black Han Sans",sans-serif;font-size:20px;color:var(--c3)';
      champ.textContent='🏆 '+data.players[fi.winner].name+' WINS!';
      div.appendChild(champ);
    }
  }
}

function watchTournament(code){
  db.ref(`tournaments/${code}`).on('value',snap=>{
    const data=snap.val();
    if(!data) return;
    tournData=data;
    if(data.status==='lobby'){
      renderTournSlots(data.players);
    } else if(data.status==='bracket'||data.status==='final'){
      showTournView('tourn-bracket-view');
      renderTournBracket(data);
      // Check if it's my match
      const myMatchBtn=document.getElementById('tourn-play-match-btn');
      let myMatch=null;
      const sf=data.semiFinals||[];
      sf.forEach(m=>{ if(!m.winner&&(m.p1===tournRole||m.p2===tournRole)) myMatch=m; });
      if(!myMatch&&data.final&&!data.final.winner&&(data.final.p1===tournRole||data.final.p2===tournRole)) myMatch=data.final;
      if(myMatchBtn) myMatchBtn.style.display=myMatch?'block':'none';
      const statusEl=document.getElementById('tourn-bracket-status');
      if(statusEl){
        if(data.status==='final'&&data.final&&data.final.winner){
          statusEl.textContent=data.players[data.final.winner]?.name+' is the Champion! 🏆';
        } else if(myMatch){
          statusEl.textContent='Your match is ready! Click below to play.';
        } else {
          statusEl.textContent='Waiting for your next match…';
        }
      }
    }
  });
}

document.getElementById('tournament-btn').addEventListener('click',()=>{
  showTournView('tourn-choice-view');
  showScreen('tournament');
});

/* ══════════════════════════════════════════════════════════════
   PHASE 3 — FRIENDS SYSTEM
   Firebase structure:
     users/<username>/  { name, avatar, color, online: true/false }
     friendRequests/<to>/<from>/ { name, avatar, username, status:'pending' }
     friends/<username>/<friendUsername>/ { name, avatar, online }
     gameInvites/<username>/ { from, fromName, fromAvatar, roomId }
══════════════════════════════════════════════════════════════ */

let _friendsListeners = [];
let _pendingFriendReq = null; // { from, fromName, fromAvatar }
let _pendingGameInvite = null; // { from, fromName, fromAvatar, roomId }

/* Register user in Firebase so friends can find them */
function registerUserPresence() {
  const p = loadProfile();
  if (!p || !p.username) return;
  const userRef = db.ref('users/' + p.username);
  userRef.update({ name: p.name, avatar: p.avatar, color: p.color, online: true, lastSeen: Date.now() });
  userRef.child('online').onDisconnect().set(false);
  window.DINGO.username = p.username;
  // Update my-username display in friends screen
  const el = document.getElementById('my-username-display');
  if (el) el.textContent = '@' + p.username;
  // Watch for incoming friend requests
  watchFriendRequests(p.username);
  // Watch for game invites
  watchGameInvites(p.username);
  // Watch friends online status
  watchFriendsStatus(p.username);
  watchMailbox(p.username);
}

/* Show friends screen */
document.getElementById('friends-btn').addEventListener('click', () => {
  const p = loadProfile();
  const el = document.getElementById('my-username-display');
  if (el && p) el.textContent = '@' + (p.username || '—');
  renderFriendsList();
  showScreen('friends');
});
document.getElementById('friends-back-btn').addEventListener('click', () => {
  detachFriendStatusListeners(); // stop live Firebase listeners when leaving
  showScreen('home');
});

/* Copy username */
document.getElementById('copy-username-btn').addEventListener('click', () => {
  const p = loadProfile();
  if (!p) return;
  const text = '@' + p.username;
  if (navigator.clipboard) navigator.clipboard.writeText(text);
  document.getElementById('copy-username-btn').textContent = '✅ Copied!';
  setTimeout(() => document.getElementById('copy-username-btn').textContent = '📋 Copy', 2000);
});

/* Add friend */
document.getElementById('add-friend-btn').addEventListener('click', async () => {
  const myProfile = loadProfile();
  if (!myProfile) return;
  let target = document.getElementById('add-friend-input').value.trim().toLowerCase().replace(/^@/, '');
  const msgEl = document.getElementById('add-friend-msg');
  if (!target) return;
  if (target === myProfile.username) { msgEl.textContent = "That's you! 😄"; return; }

  msgEl.textContent = '⏳ Searching…';
  msgEl.style.color = 'var(--ink2)';
  try {
    const snap = await db.ref('users/' + target).get();
    if (!snap.exists()) {
      msgEl.textContent = '❌ @' + target + ' not found';
      msgEl.style.color = 'var(--c2)';
      return;
    }
    const theirData = snap.val();
    // Send friend request
    await db.ref('friendRequests/' + target + '/' + myProfile.username).set({
      name:   myProfile.name,
      avatar: myProfile.avatar,
      username: myProfile.username,
      status: 'pending',
      ts: Date.now()
    });
    msgEl.textContent = '✅ Request sent to @' + target + '!';
    msgEl.style.color = 'var(--c1)';
    document.getElementById('add-friend-input').value = '';
  } catch(e) {
    msgEl.textContent = '❌ Error: ' + e.message;
    msgEl.style.color = 'var(--c2)';
  }
});

/* Watch for incoming friend requests */
function watchFriendRequests(myUsername) {
  const reqRef = db.ref('friendRequests/' + myUsername);
  reqRef.on('child_added', snap => {
    const fromUsername = snap.key;
    const data = snap.val();
    if (data && data.status === 'pending') {
      showFriendRequestToast(fromUsername, data);
    }
  });
}

function showFriendRequestToast(fromUsername, data) {
  _pendingFriendReq = { from: fromUsername, ...data };
  // Build avatar safely — SVG must go via innerHTML (textContent would print raw markup)
  const isSvg = data.avatar && data.avatar.trim().startsWith('<svg');
  const avHtml = isSvg
    ? `<span style="display:inline-block;width:22px;height:22px;vertical-align:middle;border-radius:4px;overflow:hidden">${data.avatar}</span>`
    : `<span style="vertical-align:middle;font-size:18px">${data.avatar || '\u{1F464}'}</span>`;
  const freqEl = document.getElementById('freq-text');
  if (freqEl) freqEl.innerHTML = avHtml + ' <strong>' + (data.name || fromUsername) + '</strong> <span style="color:var(--ink3)">(@' + fromUsername + ')</span> wants to be friends!';
  document.getElementById('friend-req-toast').style.display = 'block';
  const dot = document.getElementById('friends-notif-dot');
  if (dot) { dot.style.display = 'block'; dot.style.background = 'var(--c1)'; }
}

document.getElementById('freq-accept-btn').addEventListener('click', async () => {
  if (!_pendingFriendReq) return;
  const myProfile = loadProfile();
  if (!myProfile) return;
  const from = _pendingFriendReq.from;
  // Add each other as friends
  await db.ref('friends/' + myProfile.username + '/' + from).set({
    name: _pendingFriendReq.name, avatar: _pendingFriendReq.avatar, username: from, online: false
  });
  await db.ref('friends/' + from + '/' + myProfile.username).set({
    name: myProfile.name, avatar: myProfile.avatar, username: myProfile.username, online: false
  });
  // Remove request
  await db.ref('friendRequests/' + myProfile.username + '/' + from).remove();
  document.getElementById('friend-req-toast').style.display = 'none';
  document.getElementById('friends-notif-dot').style.display = 'none';
  _pendingFriendReq = null;
  renderFriendsList();
});

document.getElementById('freq-decline-btn').addEventListener('click', async () => {
  if (!_pendingFriendReq) return;
  const myProfile = loadProfile();
  if (myProfile) await db.ref('friendRequests/' + myProfile.username + '/' + _pendingFriendReq.from).remove();
  document.getElementById('friend-req-toast').style.display = 'none';
  _pendingFriendReq = null;
});

/* Watch friends online status */
/* ─── Realtime online-status listeners for the friends screen ───────────────
   We keep a map of { username → Firebase ref } so we can detach every listener
   the moment the user leaves the friends screen.  This prevents ghost callbacks
   from firing on unrelated screens.
──────────────────────────────────────────────────────────────────────────── */
let _friendStatusListeners = {}; // { username: dbRef }

function detachFriendStatusListeners() {
  Object.entries(_friendStatusListeners).forEach(([u, r]) => {
    try { r.off('value'); } catch(e) {}
  });
  _friendStatusListeners = {};
}

/* watchFriendsStatus — simplified: just keeps the friend count badge live.
   Per-card live status is now owned by renderFriendsList itself. */
function watchFriendsStatus(myUsername) {
  db.ref('friends/' + myUsername).on('value', snap => {
    const count = snap.exists() ? Object.keys(snap.val() || {}).length : 0;
    const countEl = document.getElementById('friends-count');
    if (countEl) countEl.textContent = '(' + count + ')';
  });
}

/* Local friends cache — kept for legacy compat */
function getLocalFriends() {
  try { return JSON.parse(localStorage.getItem('dingo_friends') || '{}'); } catch(e) { return {}; }
}
function setLocalFriends(data) {
  localStorage.setItem('dingo_friends', JSON.stringify(data));
}

/* ─── applyOnlineStatus ──────────────────────────────────────────────────────
   Updates the three status elements inside a friend card in-place, without
   rebuilding the whole card.  Called once immediately (current value) and
   again automatically every time Firebase changes the value.
──────────────────────────────────────────────────────────────────────────── */
function applyOnlineStatus(card, username, isOnline) {
  if (!card) return;
  const dot    = card.querySelector('.fs-dot');
  const label  = card.querySelector('.fs-label');
  const invRow = card.querySelector('.fs-invite-row');

  if (dot) {
    dot.style.background = isOnline ? 'var(--c1)' : 'var(--ink3)';
    dot.style.boxShadow  = isOnline ? '0 0 6px var(--c1)' : 'none';
  }
  if (label) {
    label.textContent = isOnline ? 'Online' : 'Offline';
    label.style.color = isOnline ? 'var(--c1)' : 'var(--ink3)';
  }
  // Show invite button only when friend is online
  if (invRow) invRow.style.display = isOnline ? 'block' : 'none';
}

/* ─── renderFriendsList ──────────────────────────────────────────────────────
   Builds the friends list once from a snapshot, then attaches a LIVE Firebase
   listener to each card so the online/offline dot updates in real-time.
   Key difference from the old code: we use .on('value') instead of .get(),
   which fires immediately with the current state AND on every future change.
──────────────────────────────────────────────────────────────────────────── */
async function renderFriendsList() {
  // Detach any previous status listeners before rebuilding the list
  detachFriendStatusListeners();

  const myProfile = loadProfile();
  const container = document.getElementById('friends-list');
  const emptyEl   = document.getElementById('friends-empty');
  const countEl   = document.getElementById('friends-count');

  if (!myProfile || !myProfile.username) {
    container.innerHTML = '<div style="text-align:center;color:var(--ink3);font-size:12px;padding:20px 0">Set up your profile first!</div>';
    return;
  }

  try {
    const snap = await db.ref('friends/' + myProfile.username).get();

    if (!snap.exists()) {
      if (emptyEl) emptyEl.style.display = 'block';
      if (countEl) countEl.textContent   = '(0)';
      container.querySelectorAll('.friend-card').forEach(el => el.remove());
      return;
    }

    const friends = snap.val() || {};
    const keys    = Object.keys(friends);

    if (countEl) countEl.textContent   = '(' + keys.length + ')';
    if (emptyEl) emptyEl.style.display = keys.length ? 'none' : 'block';
    container.querySelectorAll('.friend-card').forEach(el => el.remove());

    for (const username of keys) {
      const f = friends[username];

      // Avatar — SVG or emoji fallback
      const avatarHtml = (f.avatar && f.avatar.trim().startsWith('<svg'))
        ? `<div style="width:40px;height:40px;flex-shrink:0;border-radius:8px;overflow:hidden">${f.avatar}</div>`
        : `<div style="font-size:28px;flex-shrink:0;width:40px;text-align:center">${f.avatar || '👤'}</div>`;

      const card = document.createElement('div');
      card.className = 'friend-card';
      card.dataset.username = username; // used by applyOnlineStatus to find the card
      card.style.cssText = `
        display:flex;align-items:center;gap:12px;
        background:var(--panel2);border:2px solid var(--edge2);
        border-radius:var(--r);padding:10px 12px;
        transition:border-color .15s;
      `;

      // The .fs-dot, .fs-label and .fs-invite-row are deliberately classed
      // so applyOnlineStatus() can update them cheaply without innerHTML rebuilds.
      card.innerHTML = `
        ${avatarHtml}
        <div style="flex:1;min-width:0">
          <div style="font-weight:700;font-size:14px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">${f.name || username}</div>
          <div style="font-size:11px;color:var(--ink2)">@${username}</div>
        </div>
        <div style="display:flex;flex-direction:column;align-items:flex-end;gap:6px;flex-shrink:0">
          <div style="display:flex;align-items:center;gap:5px">
            <span class="fs-dot"   style="width:8px;height:8px;border-radius:50%;background:var(--ink3);flex-shrink:0;transition:background .35s,box-shadow .35s"></span>
            <span class="fs-label" style="font-size:11px;font-weight:600;letter-spacing:.5px;color:var(--ink3);transition:color .35s">...</span>
          </div>
          <div class="fs-invite-row" style="display:none">
            <button class="btn btn-ghost fs-invite-btn"
              style="font-size:10px;padding:3px 10px;border-color:rgba(255,204,0,.4);color:var(--c3);white-space:nowrap">
              🎮 Invite
            </button>
          </div>
        </div>
      `;

      // Safe event listener — no inline onclick
      card.querySelector('.fs-invite-btn')
          .addEventListener('click', () => inviteFriend(username));

      container.appendChild(card);

      // ── Attach LIVE listener — this is the core fix ──────────────────────
      // Firebase fires immediately with the current stored value, which gives
      // us the correct initial state.  Then it fires again automatically
      // whenever the friend's online field changes — no polling or re-renders.
      const statusRef = db.ref('users/' + username + '/online');
      statusRef.on('value', snap => {
        const isOnline = snap.val() === true;
        // Query the card fresh in case the list was rebuilt since this fired
        const liveCard = container.querySelector(`.friend-card[data-username="${username}"]`);
        applyOnlineStatus(liveCard, username, isOnline);
      });
      _friendStatusListeners[username] = statusRef; // track so we can detach later
    }

  } catch(e) {
    console.error('renderFriendsList error:', e);
    container.innerHTML = '<div style="color:var(--c2);font-size:12px;text-align:center;padding:16px 0">Could not load friends — check your connection.</div>';
  }
}

/* Invite friend to a game — improved:
   1. Creates the room immediately so the code is valid when friend joins
   2. Navigates the inviter to the setup screen as host (room code shown)
   3. Sends the invite to Firebase with roomId + notification badge
   4. Shows a dismissable in-app toast instead of alert()
*/
async function inviteFriend(username) {
  const myProfile = loadProfile();
  if (!myProfile) return;

  // Read current DINGO profile into game state vars
  readDINGO();

  // Generate a room and create it in Firebase so it's live when friend joins
  const inviteRoomId = genRoomId();
  try {
    await set(ref(db, `rooms/${inviteRoomId}`), {
      players:    { p1: myPlayerId },
      playerInfo: { p1: { name: playerName, avatar: playerAvatar, color: playerColor } },
      gameState:  { status: 'waiting', currentTurn: 'p1', selectedNumbers: [0], winner: '' },
      scores:     { p1: 0, p2: 0 }
    });

    // Write the invite to the friend's gameInvites node
    await db.ref('gameInvites/' + username).push({
      from:       myProfile.username,
      fromName:   myProfile.name,
      fromAvatar: myProfile.avatar,
      roomId:     inviteRoomId,
      ts:         Date.now()
    });

    // Navigate the inviter to the setup screen as host (p1)
    roomId     = inviteRoomId;
    playerRole = 'p1';
    document.getElementById('display-room-code').innerText = roomId;
    document.getElementById('waiting-label').innerText     = 'Waiting for ' + username + '…';
    initSetupBoard();
    showScreen('setup');
    showChat();
    setupPresence();
    watchOpponentPresence();

    // Listen for p2 joining
    onRoomValue(ref(db, `rooms/${roomId}/playerInfo`), snap => {
      const info = snap.val();
      if (info?.p2) {
        renderAvatar(document.getElementById('p2-avatar'), info.p2.avatar);
        document.getElementById('p2-name').textContent = info.p2.name;
        document.getElementById('waiting-label').textContent = info.p2.name + ' joined!';
      }
      if (info?.p1) {
        renderAvatar(document.getElementById('p1-avatar'), info.p1.avatar);
        document.getElementById('p1-name').textContent = info.p1.name;
      }
    });
    onRoomValue(ref(db, `rooms/${roomId}/scores`), snap => {
      const s = snap.val();
      if (s) { scores.p1 = s.p1 || 0; scores.p2 = s.p2 || 0; updateScoreDisplay(); }
    });

    // Show a success toast in the setup screen
    showInviteSentToast(username, inviteRoomId);

  } catch(err) {
    console.error('Invite error:', err);
    const msg = document.getElementById('home-msg');
    if (msg) { msg.textContent = '❌ Could not send invite: ' + err.message; msg.style.color = 'var(--c2)'; }
  }
}

/* Small "Invite sent!" toast that appears briefly in the setup screen */
function showInviteSentToast(username, code) {
  let t = document.getElementById('invite-sent-toast');
  if (!t) {
    t = document.createElement('div');
    t.id = 'invite-sent-toast';
    t.style.cssText = `
      position:fixed;top:80px;left:50%;transform:translateX(-50%);
      z-index:9000;background:var(--panel);
      border:2px solid var(--c3);border-radius:var(--r-lg);
      padding:10px 18px;text-align:center;
      box-shadow:4px 4px 0 rgba(0,0,0,.4);
      font-family:'Space Grotesk',sans-serif;
      opacity:0;transition:opacity .25s;pointer-events:none;
    `;
    document.body.appendChild(t);
  }
  t.innerHTML = `<div style="font-size:11px;color:var(--ink2);letter-spacing:1px;text-transform:uppercase;font-weight:700;margin-bottom:3px">⚡ Invite sent to @${username}</div>
                 <div style="font-size:14px;font-weight:800;color:var(--c3);letter-spacing:3px">${code}</div>`;
  t.style.opacity = '1';
  t.style.pointerEvents = 'none';
  clearTimeout(t._timer);
  t._timer = setTimeout(() => { t.style.opacity = '0'; }, 3500);
}

/* Watch for game invites */
let _gameInviteBadgeCount = 0;
function watchGameInvites(myUsername) {
  db.ref('gameInvites/' + myUsername).on('child_added', snap => {
    const data = snap.val();
    if (!data) return;
    _pendingGameInvite = { ...data, key: snap.key };

    // Build avatar html for toast
    const avHtml = (data.fromAvatar && data.fromAvatar.trim().startsWith('<svg'))
      ? `<span style="display:inline-block;width:24px;height:24px;vertical-align:middle">${data.fromAvatar}</span>`
      : (data.fromAvatar || '🎮');
    document.getElementById('ginv-text').innerHTML =
      avHtml + ' <strong>@' + data.from + '</strong> invited you to play!';
    document.getElementById('game-invite-toast').style.display = 'block';

    // Notification badge on the Friends button
    _gameInviteBadgeCount++;
    const dot = document.getElementById('friends-notif-dot');
    if (dot) {
      dot.style.display = 'block';
      dot.textContent   = _gameInviteBadgeCount > 1 ? _gameInviteBadgeCount : '';
      dot.style.cssText += ';background:var(--c3);color:#000;font-size:7px;line-height:8px;text-align:center;font-weight:800';
    }

    // Ping sound
    if (typeof sfx !== 'undefined') sfx.ping();

    // Clean up old invite from Firebase
    db.ref('gameInvites/' + myUsername + '/' + snap.key).remove();
  });
}

document.getElementById('ginv-accept-btn').addEventListener('click', () => {
  if (!_pendingGameInvite) return;
  document.getElementById('game-invite-toast').style.display = 'none';
  // Clear notification badge
  _gameInviteBadgeCount = 0;
  const dot = document.getElementById('friends-notif-dot');
  if (dot) { dot.style.display = 'none'; dot.textContent = ''; }
  document.getElementById('room-code-input').value = _pendingGameInvite.roomId;
  document.getElementById('join-row').style.display = 'flex';
  showScreen('home');
  setTimeout(() => document.getElementById('join-btn').click(), 300);
  _pendingGameInvite = null;
});

document.getElementById('ginv-decline-btn').addEventListener('click', () => {
  document.getElementById('game-invite-toast').style.display = 'none';
  _gameInviteBadgeCount = Math.max(0, _gameInviteBadgeCount - 1);
  const dot = document.getElementById('friends-notif-dot');
  if (dot && _gameInviteBadgeCount === 0) { dot.style.display = 'none'; dot.textContent = ''; }
  _pendingGameInvite = null;
});


document.getElementById('tourn-back-btn').addEventListener('click',()=>showScreen('home'));
document.getElementById('tourn-host-btn').addEventListener('click',()=>{
  tournCode=genTournCode();
  tournRole='p1';
  document.getElementById('tourn-code-display').textContent=tournCode;
  const d=window.DINGO||{};
  db.ref(`tournaments/${tournCode}`).set({
    status:'lobby',
    host:'p1',
    players:{ p1:{ name:d.playerName||'Player', avatar:d.selectedAvatar||AVATAR_DEFS[0].svg } }
  });
  watchTournament(tournCode);
  document.getElementById('tourn-sub').textContent='Share code · '+tournCode;
  showTournView('tourn-host-view');
});
document.getElementById('tourn-join-btn').addEventListener('click',()=>showTournView('tourn-join-view'));
document.getElementById('tourn-join-cancel-btn').addEventListener('click',()=>showTournView('tourn-choice-view'));
document.getElementById('tourn-cancel-btn').addEventListener('click',()=>{
  if(tournCode) db.ref(`tournaments/${tournCode}`).remove();
  db.ref(`tournaments/${tournCode}`).off();
  showScreen('home');
});
document.getElementById('tourn-leave-btn').addEventListener('click',()=>{
  if(tournCode) db.ref(`tournaments/${tournCode}`).off();
  tournCode=''; tournRole='';
  showScreen('home');
});

document.getElementById('tourn-join-confirm-btn').addEventListener('click',async()=>{
  const code=document.getElementById('tourn-join-input').value.trim().toUpperCase();
  if(code.length!==4){ alert('Enter a 4-letter code'); return; }
  const snap=await db.ref(`tournaments/${code}`).get();
  const data=snap.val();
  if(!data){ alert('Tournament not found'); return; }
  if(data.status!=='lobby'){ alert('This tournament has already started'); return; }
  const taken=Object.keys(data.players||{});
  if(taken.length>=4){ alert('Tournament is full'); return; }
  const slot='p'+(taken.length+1);
  tournCode=code; tournRole=slot;
  const d=window.DINGO||{};
  await db.ref(`tournaments/${code}/players/${slot}`).set({
    name:d.playerName||'Player', avatar:d.selectedAvatar||AVATAR_DEFS[0].svg
  });
  watchTournament(code);
  document.getElementById('tourn-sub').textContent='Joined · '+code;
  showTournView('tourn-bracket-view');
  showScreen('tournament');
});

document.getElementById('tourn-start-btn').addEventListener('click',async()=>{
  if(!tournCode) return;
  // Build bracket: p1 vs p2, p3 vs p4
  await db.ref(`tournaments/${tournCode}`).update({
    status:'bracket',
    semiFinals:[
      {p1:'p1',p2:'p2',winner:null,roomId:null},
      {p1:'p3',p2:'p4',winner:null,roomId:null},
    ],
    final:{p1:null,p2:null,winner:null,roomId:null}
  });
});

/* ─── Restart / reset ─────────────────────────── */
async function doRestart(){
  if(countdownInterval)clearInterval(countdownInterval);
  winShown=false; lastLineCount=0; cleanupScheduled=false; botWinShown=false;
  stopMoveTimer();
  stopAbandonCountdown(false);
  document.getElementById('win-overlay').classList.remove('show');
  document.querySelectorAll('.cell.win-line').forEach(c=>c.classList.remove('win-line'));
  document.querySelectorAll('.cell.crossed').forEach(c=>c.classList.remove('crossed'));

  // Detach ALL old room listeners — new ones will be registered fresh when ready-btn is clicked
  detachRoomListeners();

  // Reset Firebase room state for new round
  await update(ref(db,`rooms/${roomId}/gameState`),{
    status:'waiting', currentTurn:'p1', selectedNumbers:[0], winner:'',
    lifelines_p1:3, lifelines_p2:3
  });
  await set(ref(db,`rooms/${roomId}/boards`),null);

  // Reset local lifeline state (without writing to Firebase since we just did above)
  lifelineState = { p1:3, p2:3 };
  renderLifelines();

  initSetupBoard(); showScreen('setup');
  const rb=document.getElementById('ready-btn');
  rb.disabled=false; rb.textContent="✓ I'm Ready!";
  sfx.click();
}
function doReset(){
  if(countdownInterval)clearInterval(countdownInterval);
  winShown = false;
  lastLineCount = 0;
  cleanupScheduled = false;
  botWinShown = false;
  // Clean up Firebase listeners, presence & room before leaving
  leaveRoomCleanup();
  // Go home — never back to the splash/welcome screen
  showScreen('home');
  document.getElementById('chat-fab').style.display='none';
  document.getElementById('chat-panel').classList.remove('open');
  document.getElementById('win-overlay').classList.remove('show');
}

/* original restart/reset handled above with bot-mode awareness */
/* ── Keeping doRestart / doReset for multiplayer mode ── */

/* ═══════════════════════════════════════════════
   CHAT SYSTEM
   — emoji + text
   — last message shown in BOTH players' profile boxes
═══════════════════════════════════════════════ */
const CHAT_EMOJIS=['👍','🔥','😂','😱','🎯','💀','🏆','😤','🤯','👏','😈','🫡'];

/* Track last seen message ts to avoid re-processing */
let lastChatTs = 0;

/* Update the little status line under a player's name —
   works on BOTH screens since both players share the same DOM structure */
function updatePlayerStatus(senderRole, text) {
  // Update on THIS player's screen under the correct player box
  const el = document.getElementById(senderRole + '-status');
  if (!el) return;
  el.textContent = text.length > 22 ? text.slice(0,21)+'…' : text;
  el.classList.remove('visible');
  // Force reflow so the animation re-triggers
  void el.offsetWidth;
  el.classList.add('visible');
  clearTimeout(el._fadeTimer);
  el._fadeTimer = setTimeout(() => el.classList.remove('visible'), 7000);
}

function showChat(){
  document.getElementById('chat-fab').style.display='flex';
  const emojiBar=document.getElementById('chat-emojis');
  emojiBar.innerHTML='';
  CHAT_EMOJIS.forEach(em=>{
    const btn=document.createElement('button');
    btn.className='emoji-btn'; btn.textContent=em;
    btn.addEventListener('click',()=>{
      sendMessage(em,true);
      chatOpen=false;
      document.getElementById('chat-panel').classList.remove('open');
    });
    emojiBar.appendChild(btn);
  });

  onRoomValue(ref(db,`rooms/${roomId}/chat`),snap=>{
    const msgs=snap.val(); if(!msgs)return;
    const container=document.getElementById('chat-messages');
    container.innerHTML='';
    const list=Object.values(msgs).slice(-40);

    list.forEach(m=>{
      const wrap=document.createElement('div');
      wrap.className='chat-msg'+(m.sender===playerRole?' mine':'');
      const bubble=document.createElement('div');
      bubble.className='chat-bubble'+(m.isEmoji?' emoji-only':'');
      bubble.textContent=m.text;
      const sender=document.createElement('div');
      sender.className='chat-sender'; sender.textContent=m.senderName;
      wrap.appendChild(bubble); wrap.appendChild(sender);
      container.appendChild(wrap);
    });
    container.scrollTop=container.scrollHeight;

    // ── Always update BOTH players' status boxes from the latest message ──
    // This fires on BOTH clients via Firebase realtime, so both screens update
    if(list.length>0){
      const last=list[list.length-1];
      // Only process if this is a genuinely new message
      if((last.ts||0) > lastChatTs){
        lastChatTs = last.ts||Date.now();
        // Update the sender's status box on this screen (works for both players)
        updatePlayerStatus(last.sender, last.text);
        // Show badge + ping only for the receiver (not the sender)
        if(last.sender !== playerRole){
          if(!chatOpen){
            document.getElementById('chat-badge').classList.add('show');
            sfx.ping();
          }
        }
      }
    }
  });
}

async function sendMessage(text,isEmoji=false){
  if(!text.trim())return;
  await push(ref(db,`rooms/${roomId}/chat`),{text,isEmoji,sender:playerRole,senderName:playerName,ts:Date.now()});
}

document.getElementById('chat-send-btn').addEventListener('click',()=>{
  const input=document.getElementById('chat-text-input');
  const txt=input.value.trim();
  if(txt){sendMessage(txt,false);input.value='';chatOpen=false;document.getElementById('chat-panel').classList.remove('open')}
});
document.getElementById('chat-text-input').addEventListener('keydown',e=>{
  if(e.key==='Enter')document.getElementById('chat-send-btn').click();
});
document.getElementById('chat-fab').addEventListener('click',()=>{
  chatOpen=!chatOpen;
  document.getElementById('chat-panel').classList.toggle('open',chatOpen);
  if(chatOpen){document.getElementById('chat-badge').classList.remove('show');document.getElementById('chat-messages').scrollTop=9999}
});

/* ── Fullscreen toggle ── */
(function initFullscreen() {
  const btn  = document.getElementById('fullscreen-btn');
  const icon = document.getElementById('fullscreen-icon');
  if(!btn || !icon) return;
  function updateIcon() {
    const isFs = !!(document.fullscreenElement || document.webkitFullscreenElement);
    icon.textContent = isFs ? '✕' : '⛶';
    btn.title = isFs ? 'Exit Fullscreen' : 'Fullscreen';
  }
  btn.addEventListener('click', () => {
    try {
      if (!document.fullscreenElement && !document.webkitFullscreenElement) {
        const el = document.documentElement;
        if (el.requestFullscreen) el.requestFullscreen().catch(()=>{});
        else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
      } else {
        if (document.exitFullscreen) document.exitFullscreen().catch(()=>{});
        else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
      }
    } catch(e) { console.warn('Fullscreen error:', e); }
  });
  document.addEventListener('fullscreenchange', updateIcon);
  document.addEventListener('webkitfullscreenchange', updateIcon);
})();
</script>

<!-- ═══════════════════════════════════════════════
     PWA — Service Worker registration + Install Prompt
     Uses real sw.js and manifest.json files (NOT blobs)
═══════════════════════════════════════════════ -->
<script>
(function initPWA() {

  /* ── 1. Register the real Service Worker ── */
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js', { scope: './' })
        .then(reg => {
          console.log('[DiNGo SW] Registered, scope:', reg.scope);
          /* If a new SW is waiting, prompt user to refresh */
          reg.addEventListener('updatefound', () => {
            const newSW = reg.installing;
            newSW.addEventListener('statechange', () => {
              if (newSW.state === 'installed' && navigator.serviceWorker.controller) {
                newSW.postMessage({ type: 'SKIP_WAITING' });
              }
            });
          });
        })
        .catch(err => console.warn('[DiNGo SW] Registration failed:', err));
    });
  }

  /* ── 2. Install prompt banner logic ── */
  const banner     = document.getElementById('pwa-install-banner');
  const installBtn = document.getElementById('pwa-install-btn');
  const dismissBtn = document.getElementById('pwa-dismiss-btn');
  let deferredPrompt = null;

  /* Don't show if dismissed within last 7 days */
  const lastDismiss    = parseInt(localStorage.getItem('pwa_dismiss') || '0', 10);
  const wasDismissed   = (Date.now() - lastDismiss) < 7 * 24 * 3600 * 1000;
  /* Don't show if already running as installed PWA */
  const alreadyInstalled = window.matchMedia('(display-mode: standalone)').matches
                        || window.navigator.standalone === true;

  if (!wasDismissed && !alreadyInstalled) {
    window.addEventListener('beforeinstallprompt', e => {
      e.preventDefault();
      deferredPrompt = e;
      /* Delay banner slightly so it doesn't clash with the splash */
      setTimeout(() => banner && banner.classList.add('show'), 3500);
    });
  }

  installBtn && installBtn.addEventListener('click', async () => {
    banner.classList.remove('show');
    if (deferredPrompt) {
      deferredPrompt.prompt();
      const { outcome } = await deferredPrompt.userChoice;
      deferredPrompt = null;
      console.log('[DiNGo PWA] Install outcome:', outcome);
    } else {
      /* iOS Safari fallback */
      alert('📲 To install on iPhone/iPad:\nTap the Share button → "Add to Home Screen"');
    }
  });

  dismissBtn && dismissBtn.addEventListener('click', () => {
    banner.classList.remove('show');
    localStorage.setItem('pwa_dismiss', String(Date.now()));
  });

  /* Hide banner once gameplay starts */
  const origShowForPWA = window.showScreen;
  window.showScreen = function(name) {
    if (origShowForPWA) origShowForPWA.call(this, name);
    if (name !== 'splash' && name !== 'name') {
      banner && banner.classList.remove('show');
    }
  };

  /* ── 3. Show "installed" toast when launched as PWA ── */
  if (alreadyInstalled) {
    console.log('[DiNGo] Running as installed PWA ✅');
  }

})();
</script>
<!-- ── FOOTER ── -->
<div id="game-footer">
  <div class="footer-left">
    <span class="footer-brand">DiNGo</span> &nbsp;·&nbsp; Live Multiplayer Bingo
  </div>
  <div class="footer-right">
    Crafted by&nbsp;<span class="footer-author">KGames</span>&nbsp;·&nbsp;© 2025
  </div>
</div>

</body>
</html>
